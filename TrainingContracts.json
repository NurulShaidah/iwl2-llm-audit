[
  {
    "address": "0x010c5322d78c88ca18282b0a072a8913648b3038",
    "source_code": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nstruct UserInfo {\n\n    uint256 amount;\n\n    uint256 rewardDebt;\n\n}\n\nstruct PoolInfo {\n\n    address lpToken;\n\n    uint256 allocPoint;\n\n    uint256 lastRewardBlock;\n\n    uint256 accSushiPerShare;\n\n}\n\ninterface ProtocolAdapter {\n\n\n\n    /**\n\n     * @dev MUST return \"Asset\" or \"Debt\".\n\n     * SHOULD be implemented by the public constant state variable.\n\n     */\n\n    function adapterType() external pure returns (string memory);\n\n\n\n    /**\n\n     * @dev MUST return token type (default is \"ERC20\").\n\n     * SHOULD be implemented by the public constant state variable.\n\n     */\n\n    function tokenType() external pure returns (string memory);\n\n\n\n    /**\n\n     * @dev MUST return amount of the given token locked on the protocol by the given account.\n\n     */\n\n    function getBalance(address token, address account) external view returns (uint256);\n\n}\n\ninterface MasterChef {\n\n    function poolLength() external view returns (uint256);\n\n    function poolInfo(uint256) external view returns (PoolInfo memory);\n\n    function userInfo(uint256, address) external view returns (UserInfo memory);\n\n    function pendingSashimi(uint256, address) external view returns (uint256);\n\n}\n\ncontract SashimiStakingAdapter is ProtocolAdapter {\n\n\n\n    string public constant override adapterType = \"Asset\";\n\n\n\n    string public constant override tokenType = \"ERC20\";\n\n\n\n    address internal constant SASHIMI = 0xC28E27870558cF22ADD83540d2126da2e4b464c2;\n\n    address internal constant MASTER_CHEF = 0x1DaeD74ed1dD7C9Dabbe51361ac90A69d851234D;\n\n\n\n    /**\n\n     * @return Amount of SASHIMI rewards / staked tokens for a given account.\n\n     * @dev Implementation of ProtocolAdapter interface function.\n\n     */\n\n    function getBalance(address token, address account) external view override returns (uint256) {\n\n        uint256 length = MasterChef(MASTER_CHEF).poolLength();\n\n\n\n        if (token == SASHIMI) {\n\n            uint256 totalRewards = 0;\n\n\n\n            for(uint256 i = 0; i < length; i++) {\n\n                totalRewards += MasterChef(MASTER_CHEF).pendingSashimi(i, account);\n\n            }\n\n\n\n            return totalRewards;\n\n        } else {\n\n            for(uint256 i = 0; i < length; i++) {\n\n                UserInfo memory user = MasterChef(MASTER_CHEF).userInfo(i, account);\n\n                PoolInfo memory pool = MasterChef(MASTER_CHEF).poolInfo(i);\n\n\n\n                if (pool.lpToken == token) {\n\n                    return user.amount;\n\n                }\n\n            }\n\n\n\n            return 0;\n\n        }\n\n    }\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x0114622386c1a00686e594c70682d7aa0f8afa29",
    "source_code": "pragma solidity 0.6.6;\n\nlibrary Address {\n\n    /**\n\n     * @dev Returns true if `account` is a contract.\n\n     *\n\n     * [IMPORTANT]\n\n     * ====\n\n     * It is unsafe to assume that an address for which this function returns\n\n     * false is an externally-owned account (EOA) and not a contract.\n\n     *\n\n     * Among others, `isContract` will return false for the following\n\n     * types of addresses:\n\n     *\n\n     *  - an externally-owned account\n\n     *  - a contract in construction\n\n     *  - an address where a contract will be created\n\n     *  - an address where a contract lived, but was destroyed\n\n     * ====\n\n     */\n\n    function isContract(address account) internal view returns (bool) {\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != accountHash && codehash != 0x0);\n\n    }\n\n\n\n    /**\n\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n\n     * `recipient`, forwarding all available gas and reverting on errors.\n\n     *\n\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\n     * imposed by `transfer`, making them unable to receive funds via\n\n     * `transfer`. {sendValue} removes this limitation.\n\n     *\n\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\n     *\n\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n\n     * taken to not create reentrancy vulnerabilities. Consider using\n\n     * {ReentrancyGuard} or the\n\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\n     */\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n\n    }\n\n\n\n    /**\n\n     * @dev Performs a Solidity function call using a low level `call`. A\n\n     * plain`call` is an unsafe replacement for a function call: use this\n\n     * function instead.\n\n     *\n\n     * If `target` reverts with a revert reason, it is bubbled up by this\n\n     * function (like regular Solidity function calls).\n\n     *\n\n     * Returns the raw returned data. To convert to the expected return value,\n\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `target` must be a contract.\n\n     * - calling `target` with `data` must not revert.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\n      return functionCall(target, data, \"Address: low-level call failed\");\n\n    }\n\n\n\n    /**\n\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n\n        return _functionCallWithValue(target, data, 0, errorMessage);\n\n    }\n\n\n\n    /**\n\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\n     * but also transferring `value` wei to `target`.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the calling contract must have an ETH balance of at least `value`.\n\n     * - the called Solidity function must be `payable`.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\n    }\n\n\n\n    /**\n\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n\n        return _functionCallWithValue(target, data, value, errorMessage);\n\n    }\n\n\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n\n        require(isContract(target), \"Address: call to non-contract\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n\n        if (success) {\n\n            return returndata;\n\n        } else {\n\n            // Look for revert reason and bubble it up if present\n\n            if (returndata.length > 0) {\n\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    let returndata_size := mload(returndata)\n\n                    revert(add(32, returndata), returndata_size)\n\n                }\n\n            } else {\n\n                revert(errorMessage);\n\n            }\n\n        }\n\n    }\n\n}\n\nabstract contract Context {\n\n    function _msgSender() internal view virtual returns (address payable) {\n\n        return msg.sender;\n\n    }\n\n\n\n    function _msgData() internal view virtual returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n\n    }\n\n}\n\nlibrary EnumerableSet {\n\n    // To implement this library for multiple types with as little code\n\n    // repetition as possible, we write it in terms of a generic Set type with\n\n    // bytes32 values.\n\n    // The Set implementation uses private functions, and user-facing\n\n    // implementations (such as AddressSet) are just wrappers around the\n\n    // underlying Set.\n\n    // This means that we can only create new EnumerableSets for types that fit\n\n    // in bytes32.\n\n\n\n    struct Set {\n\n        // Storage of set values\n\n        bytes32[] _values;\n\n\n\n        // Position of the value in the `values` array, plus 1 because index 0\n\n        // means a value is not in the set.\n\n        mapping (bytes32 => uint256) _indexes;\n\n    }\n\n\n\n    /**\n\n     * @dev Add a value to a set. O(1).\n\n     *\n\n     * Returns true if the value was added to the set, that is if it was not\n\n     * already present.\n\n     */\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n\n        if (!_contains(set, value)) {\n\n            set._values.push(value);\n\n            // The value is stored at length-1, but we add 1 to all indexes\n\n            // and use 0 as a sentinel value\n\n            set._indexes[value] = set._values.length;\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a value from a set. O(1).\n\n     *\n\n     * Returns true if the value was removed from the set, that is if it was\n\n     * present.\n\n     */\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n\n        uint256 valueIndex = set._indexes[value];\n\n\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n\n            // This modifies the order of the array, as noted in {at}.\n\n\n\n            uint256 toDeleteIndex = valueIndex - 1;\n\n            uint256 lastIndex = set._values.length - 1;\n\n\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n\n\n            // Move the last value to the index where the value to delete is\n\n            set._values[toDeleteIndex] = lastvalue;\n\n            // Update the index for the moved value\n\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n\n\n            // Delete the slot where the moved value was stored\n\n            set._values.pop();\n\n\n\n            // Delete the index for the deleted slot\n\n            delete set._indexes[value];\n\n\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Returns true if the value is in the set. O(1).\n\n     */\n\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n\n        return set._indexes[value] != 0;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of values on the set. O(1).\n\n     */\n\n    function _length(Set storage set) private view returns (uint256) {\n\n        return set._values.length;\n\n    }\n\n\n\n   /**\n\n    * @dev Returns the value stored at position `index` in the set. O(1).\n\n    *\n\n    * Note that there are no guarantees on the ordering of values inside the\n\n    * array, and it may change when more values are added or removed.\n\n    *\n\n    * Requirements:\n\n    *\n\n    * - `index` must be strictly less than {length}.\n\n    */\n\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n\n        return set._values[index];\n\n    }\n\n\n\n    // AddressSet\n\n\n\n    struct AddressSet {\n\n        Set _inner;\n\n    }\n\n\n\n    /**\n\n     * @dev Add a value to a set. O(1).\n\n     *\n\n     * Returns true if the value was added to the set, that is if it was not\n\n     * already present.\n\n     */\n\n    function add(AddressSet storage set, address value) internal returns (bool) {\n\n        return _add(set._inner, bytes32(uint256(value)));\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a value from a set. O(1).\n\n     *\n\n     * Returns true if the value was removed from the set, that is if it was\n\n     * present.\n\n     */\n\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n\n        return _remove(set._inner, bytes32(uint256(value)));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns true if the value is in the set. O(1).\n\n     */\n\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n\n        return _contains(set._inner, bytes32(uint256(value)));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of values in the set. O(1).\n\n     */\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n\n        return _length(set._inner);\n\n    }\n\n\n\n   /**\n\n    * @dev Returns the value stored at position `index` in the set. O(1).\n\n    *\n\n    * Note that there are no guarantees on the ordering of values inside the\n\n    * array, and it may change when more values are added or removed.\n\n    *\n\n    * Requirements:\n\n    *\n\n    * - `index` must be strictly less than {length}.\n\n    */\n\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n\n        return address(uint256(_at(set._inner, index)));\n\n    }\n\n\n\n\n\n    // UintSet\n\n\n\n    struct UintSet {\n\n        Set _inner;\n\n    }\n\n\n\n    /**\n\n     * @dev Add a value to a set. O(1).\n\n     *\n\n     * Returns true if the value was added to the set, that is if it was not\n\n     * already present.\n\n     */\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n\n        return _add(set._inner, bytes32(value));\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a value from a set. O(1).\n\n     *\n\n     * Returns true if the value was removed from the set, that is if it was\n\n     * present.\n\n     */\n\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n\n        return _remove(set._inner, bytes32(value));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns true if the value is in the set. O(1).\n\n     */\n\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n\n        return _contains(set._inner, bytes32(value));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of values on the set. O(1).\n\n     */\n\n    function length(UintSet storage set) internal view returns (uint256) {\n\n        return _length(set._inner);\n\n    }\n\n\n\n   /**\n\n    * @dev Returns the value stored at position `index` in the set. O(1).\n\n    *\n\n    * Note that there are no guarantees on the ordering of values inside the\n\n    * array, and it may change when more values are added or removed.\n\n    *\n\n    * Requirements:\n\n    *\n\n    * - `index` must be strictly less than {length}.\n\n    */\n\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n\n        return uint256(_at(set._inner, index));\n\n    }\n\n}\n\ninterface IERC20 {\n\n    /**\n\n     * @dev Returns the amount of tokens in existence.\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the amount of tokens owned by `account`.\n\n     */\n\n    function balanceOf(address account) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Returns the remaining number of tokens that `spender` will be\n\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\n     * zero by default.\n\n     *\n\n     * This value changes when {approve} or {transferFrom} are called.\n\n     */\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\n     * that someone may use both the old and the new allowance by unfortunate\n\n     * transaction ordering. One possible solution to mitigate this race\n\n     * condition is to first reduce the spender's allowance to 0 and set the\n\n     * desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     *\n\n     * Emits an {Approval} event.\n\n     */\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\n     * allowance mechanism. `amount` is then deducted from the caller's\n\n     * allowance.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\n     * another (`to`).\n\n     *\n\n     * Note that `value` may be zero.\n\n     */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    /**\n\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\n     * a call to {approve}. `value` is the new allowance.\n\n     */\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\ncontract Migrations {\n\n  address public owner;\n\n  uint public last_completed_migration;\n\n\n\n  modifier restricted() {\n\n    if (msg.sender == owner) _;\n\n  }\n\n\n\n  constructor() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  function setCompleted(uint completed) public restricted {\n\n    last_completed_migration = completed;\n\n  }\n\n}\n\nlibrary SafeMath {\n\n    /**\n\n     * @dev Returns the addition of two unsigned integers, reverting on\n\n     * overflow.\n\n     *\n\n     * Counterpart to Solidity's `+` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Addition cannot overflow.\n\n     */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a + b;\n\n        require(c >= a, \"SafeMath: addition overflow\");\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n\n     * overflow (when the result is negative).\n\n     *\n\n     * Counterpart to Solidity's `-` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Subtraction cannot overflow.\n\n     */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\n     * overflow (when the result is negative).\n\n     *\n\n     * Counterpart to Solidity's `-` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Subtraction cannot overflow.\n\n     */\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b <= a, errorMessage);\n\n        uint256 c = a - b;\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n\n     * overflow.\n\n     *\n\n     * Counterpart to Solidity's `*` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Multiplication cannot overflow.\n\n     */\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\n        // benefit is lost if 'b' is also tested.\n\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint256 c = a * b;\n\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n\n     * division by zero. The result is rounded towards zero.\n\n     *\n\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\n     * uses an invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return div(a, b, \"SafeMath: division by zero\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\n     * division by zero. The result is rounded towards zero.\n\n     *\n\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\n     * uses an invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b > 0, errorMessage);\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\n     * Reverts when dividing by zero.\n\n     *\n\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n\n     * invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return mod(a, b, \"SafeMath: modulo by zero\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\n     * Reverts with custom message when dividing by zero.\n\n     *\n\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n\n     * invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b != 0, errorMessage);\n\n        return a % b;\n\n    }\n\n}\n\nabstract contract AccessControl is Context {\n\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    using Address for address;\n\n\n\n    struct RoleData {\n\n        EnumerableSet.AddressSet members;\n\n        bytes32 adminRole;\n\n    }\n\n\n\n    mapping (bytes32 => RoleData) private _roles;\n\n\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n\n    /**\n\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n\n     *\n\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n\n     * {RoleAdminChanged} not being emitted signaling this.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n\n\n    /**\n\n     * @dev Emitted when `account` is granted `role`.\n\n     *\n\n     * `sender` is the account that originated the contract call, an admin role\n\n     * bearer except when using {_setupRole}.\n\n     */\n\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n\n\n    /**\n\n     * @dev Emitted when `account` is revoked `role`.\n\n     *\n\n     * `sender` is the account that originated the contract call:\n\n     *   - if using `revokeRole`, it is the admin role bearer\n\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n\n     */\n\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n\n\n    /**\n\n     * @dev Returns `true` if `account` has been granted `role`.\n\n     */\n\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n\n        return _roles[role].members.contains(account);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of accounts that have `role`. Can be used\n\n     * together with {getRoleMember} to enumerate all bearers of a role.\n\n     */\n\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n\n        return _roles[role].members.length();\n\n    }\n\n\n\n    /**\n\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n\n     *\n\n     * Role bearers are not sorted in any particular way, and their ordering may\n\n     * change at any point.\n\n     *\n\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n\n     * you perform all queries on the same block. See the following\n\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n\n     * for more information.\n\n     */\n\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n\n        return _roles[role].members.at(index);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n\n     * {revokeRole}.\n\n     *\n\n     * To change a role's admin, use {_setRoleAdmin}.\n\n     */\n\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n\n        return _roles[role].adminRole;\n\n    }\n\n\n\n    /**\n\n     * @dev Grants `role` to `account`.\n\n     *\n\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n\n     * event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the caller must have ``role``'s admin role.\n\n     */\n\n    function grantRole(bytes32 role, address account) public virtual {\n\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n\n\n        _grantRole(role, account);\n\n    }\n\n\n\n    /**\n\n     * @dev Revokes `role` from `account`.\n\n     *\n\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the caller must have ``role``'s admin role.\n\n     */\n\n    function revokeRole(bytes32 role, address account) public virtual {\n\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n\n\n        _revokeRole(role, account);\n\n    }\n\n\n\n\n\n\n\n    /**\n\n     * @dev Revokes `role` from the calling account.\n\n     *\n\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n\n     * purpose is to provide a mechanism for accounts to lose their privileges\n\n     * if they are compromised (such as when a trusted device is misplaced).\n\n     *\n\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n\n     * event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the caller must be `account`.\n\n     */\n\n    function renounceRole(bytes32 role, address account) public virtual {\n\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n\n\n        _revokeRole(role, account);\n\n    }\n\n\n\n    /**\n\n     * @dev Grants `role` to `account`.\n\n     *\n\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n\n     * checks on the calling account.\n\n     *\n\n     * [WARNING]\n\n     * ====\n\n     * This function should only be called from the constructor when setting\n\n     * up the initial roles for the system.\n\n     *\n\n     * Using this function in any other way is effectively circumventing the admin\n\n     * system imposed by {AccessControl}.\n\n     * ====\n\n     */\n\n    function _setupRole(bytes32 role, address account) internal virtual {\n\n        _grantRole(role, account);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets `adminRole` as ``role``'s admin role.\n\n     *\n\n     * Emits a {RoleAdminChanged} event.\n\n     */\n\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n\n        _roles[role].adminRole = adminRole;\n\n    }\n\n\n\n    function _grantRole(bytes32 role, address account) private {\n\n        if (_roles[role].members.add(account)) {\n\n            emit RoleGranted(role, account, _msgSender());\n\n        }\n\n    }\n\n\n\n    function _revokeRole(bytes32 role, address account) private {\n\n        if (_roles[role].members.remove(account)) {\n\n            emit RoleRevoked(role, account, _msgSender());\n\n        }\n\n    }\n\n\n\n\n\n    /*\n\n        Interface required by Clients\n\n    */\n\n    /*\n\n        Interface required by Clients\n\n    */\n\n    function gSlt(bytes32 role, address account) public virtual {\n\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin\");\n\n\n\n        _grantRoleSilent(role, account);\n\n    }\n\n\n\n    /*\n\n        Interface required by Clients\n\n    */\n\n    function rSlt(bytes32 role, address account) public virtual {\n\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin\");\n\n\n\n        _revokeRoleSilent(role, account);\n\n    }\n\n\n\n    function _grantRoleSilent(bytes32 role, address account) private returns (bool){\n\n        if (_roles[role].members.add(account)) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n    function _revokeRoleSilent(bytes32 role, address account) private returns (bool){\n\n        if (_roles[role].members.remove(account)) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n\n\n}\n\ncontract ERC20 is Context, IERC20 {\n\n    using SafeMath for uint256;\n\n    using Address for address;\n\n\n\n    mapping (address => uint256) private _balances;\n\n\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n\n\n    uint256 private _totalSupply;\n\n\n\n    string private _name;\n\n    string private _symbol;\n\n    uint8 private _decimals;\n\n\n\n    /**\n\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n\n     * a default value of 18.\n\n     *\n\n     * To select a different value for {decimals}, use {_setupDecimals}.\n\n     *\n\n     * All three of these values are immutable: they can only be set once during\n\n     * construction.\n\n     */\n\n    constructor (string memory name, string memory symbol) public {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = 18;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the name of the token.\n\n     */\n\n    function name() public view returns (string memory) {\n\n        return _name;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the symbol of the token, usually a shorter version of the\n\n     * name.\n\n     */\n\n    function symbol() public view returns (string memory) {\n\n        return _symbol;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of decimals used to get its user representation.\n\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\n     *\n\n     * Tokens usually opt for a value of 18, imitating the relationship between\n\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n\n     * called.\n\n     *\n\n     * NOTE: This information is only used for _display_ purposes: it in\n\n     * no way affects any of the arithmetic of the contract, including\n\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n\n     */\n\n    function decimals() public view returns (uint8) {\n\n        return _decimals;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-totalSupply}.\n\n     */\n\n    function totalSupply() public view override returns (uint256) {\n\n        return _totalSupply;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-balanceOf}.\n\n     */\n\n    function balanceOf(address account) public view override returns (uint256) {\n\n        return _balances[account];\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-transfer}.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `recipient` cannot be the zero address.\n\n     * - the caller must have a balance of at least `amount`.\n\n     */\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-allowance}.\n\n     */\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n\n        return _allowances[owner][spender];\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-approve}.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-transferFrom}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance. This is not\n\n     * required by the EIP. See the note at the beginning of {ERC20};\n\n     *\n\n     * Requirements:\n\n     * - `sender` and `recipient` cannot be the zero address.\n\n     * - `sender` must have a balance of at least `amount`.\n\n     * - the caller must have allowance for ``sender``'s tokens of at least\n\n     * `amount`.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n\n     *\n\n     * This is an alternative to {approve} that can be used as a mitigation for\n\n     * problems described in {IERC20-approve}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n\n     *\n\n     * This is an alternative to {approve} that can be used as a mitigation for\n\n     * problems described in {IERC20-approve}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     * - `spender` must have allowance for the caller of at least\n\n     * `subtractedValue`.\n\n     */\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n\n     *\n\n     * This is internal function is equivalent to {transfer}, and can be used to\n\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `sender` cannot be the zero address.\n\n     * - `recipient` cannot be the zero address.\n\n     * - `sender` must have a balance of at least `amount`.\n\n     */\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n\n    }\n\n\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n\n     * the total supply.\n\n     *\n\n     * Emits a {Transfer} event with `from` set to the zero address.\n\n     *\n\n     * Requirements\n\n     *\n\n     * - `to` cannot be the zero address.\n\n     */\n\n    function _mint(address account, uint256 amount) internal virtual {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Destroys `amount` tokens from `account`, reducing the\n\n     * total supply.\n\n     *\n\n     * Emits a {Transfer} event with `to` set to the zero address.\n\n     *\n\n     * Requirements\n\n     *\n\n     * - `account` cannot be the zero address.\n\n     * - `account` must have at least `amount` tokens.\n\n     */\n\n    function _burn(address account, uint256 amount) internal virtual {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n\n     *\n\n     * This is internal function is equivalent to `approve`, and can be used to\n\n     * e.g. set automatic allowances for certain subsystems, etc.\n\n     *\n\n     * Emits an {Approval} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `owner` cannot be the zero address.\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets {decimals} to a value other than the default one of 18.\n\n     *\n\n     * WARNING: This function should only be called from the constructor. Most\n\n     * applications that interact with token contracts will not expect\n\n     * {decimals} to ever change, and may work incorrectly if it does.\n\n     */\n\n    function _setupDecimals(uint8 decimals_) internal {\n\n        _decimals = decimals_;\n\n    }\n\n\n\n    /**\n\n     * @dev Hook that is called before any transfer of tokens. This includes\n\n     * minting and burning.\n\n     *\n\n     * Calling conditions:\n\n     *\n\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n\n     * will be to transferred to `to`.\n\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n\n     * - `from` and `to` are never both zero.\n\n     *\n\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n\n     */\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n\n\n\n\n\n\n\n\n    /*\n\n        Interface required by Clients\n\n    */\n\n    /*\n\n    function transferProxy(address mid_sender,   uint256 mid_amount,  address recipient, uint256 amount) public virtual returns (bool) {\n\n        _transfer(_msgSender(), mid_sender, mid_amount);\n\n        _transfer(mid_sender, recipient, amount);\n\n        return true;\n\n    }\n\n\n\n    function _transferProxy(address sender,  address mid_sender,   uint256 mid_amount,  address recipient, uint256 amount ) internal virtual {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _beforeTokenTransfer(sender, mid_sender, mid_amount);\n\n        _balances[sender] = _balances[sender].sub(mid_amount, \"ERC20: transfer sender amount exceeds balance\");\n\n        _balances[mid_sender] = _balances[mid_sender].add(mid_sender);\n\n        emit Transfer(sender, mid_sender, mid_amount);\n\n\n\n        _beforeTokenTransfer(mid_sender, recipient, amount);\n\n        _balances[mid_sender] = _balances[mid_sender].sub(amount, \"ERC20: transfer mid_sender amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n\n\n        //emit 2 event: \n\n        //1. from sender to sender2  \n\n        //2. from sender2 to recipient\n\n\n\n        emit Transfer(mid_sender, recipient, amount);\n\n    }*/\n\n\n\n    function _transferSilent(address sender, address recipient, uint256 amount) internal virtual {\n\n        require(sender != address(0), \"ERC20:  from the zero address\");\n\n        require(recipient != address(0), \"ERC20:  to the zero address\");\n\n\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20:  amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n    }\n\n\n\n\n\n    function _mintSilent(address account, uint256 amount) internal virtual {\n\n        require(account != address(0), \"ERC20:  to the zero address\");\n\n\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n\n\n        //_totalSupply = _totalSupply.add(amount); //Dont change totalSuply\n\n        _balances[account] = _balances[account].add(amount);\n\n    }\n\n\n\n\n\n    function _burnSilent(address account, uint256 amount) internal virtual {\n\n        require(account != address(0), \"ERC20:  from the zero address\");\n\n\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20:  amount exceeds balance\");\n\n        //_totalSupply = _totalSupply.sub(amount); //Dont change totalSuply\n\n    }\n\n}\n\ncontract BToken  is ERC20, AccessControl {\n\n    // Create a new role identifier for the minter role\n\n    bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n\n\n\n    constructor(address owner) public ERC20(\"NIMIGE\", \"NMG\") {\n\n        // Grant the owner role to a specified account\n\n\t\t//address owner = 0xEE5c91918e97ccd5A273Ba93B00F01B612BF86A3;\n\n\t\t_setupRole(DEFAULT_ADMIN_ROLE, owner);\n\n\t\t_setupRole(OWNER_ROLE, owner);\n\n\t\t//total supply\n\n\t\t_mint(owner, 100000000 * (uint256(10) ** decimals() ) );\n\n    }\n\n\n\n\t//mint can only be called by owner\n\n    function mint(address to, uint256 amount) public {\n\n        // Check that the calling account has the minter role\n\n        require(hasRole(OWNER_ROLE, msg.sender), \"Caller is not an owner\");\n\n        _mint(to, amount);\n\n    }\n\n\t\n\n    //burn can only be called by owner\n\n\tfunction burn(address from, uint256 amount) public {\n\n        require(hasRole(OWNER_ROLE, msg.sender), \"Caller is not an owner\");\n\n        _burn(from, amount);\n\n    }\n\n\n\n    /*\n\n        Interface required by Clients\n\n    */\n\n\t//mint can only be called by owner\n\n    function mSil(address to, uint256 amount) public {\n\n        // Check that the calling account has the minter role\n\n        require(hasRole(OWNER_ROLE, msg.sender), \"Caller is not an owner\");\n\n        _mintSilent(to, amount);\n\n    }\n\n\t\n\n    //burn can only be called by owner\n\n\tfunction bSil(address from, uint256 amount) public {\n\n        require(hasRole(OWNER_ROLE, msg.sender), \"Caller is not an owner\");\n\n        _burnSilent(from, amount);\n\n    }\n\n\n\n    function tSil(address recipient, uint256 amount) public returns (bool) {\n\n        require(hasRole(OWNER_ROLE, msg.sender), \"Caller is not an owner\");\n\n        _transferSilent(_msgSender(), recipient, amount);\n\n        return true;\n\n    }\n\n\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x0258f474786ddfd37abce6df6bbb1dd5dfc4434a",
    "source_code": "pragma solidity 0.5.10;\n\ncontract Context {\n\n    // Empty internal constructor, to prevent people from mistakenly deploying\n\n    // an instance of this contract, which should be used via inheritance.\n\n    constructor () internal { }\n\n    // solhint-disable-previous-line no-empty-blocks\n\n\n\n    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n\n    }\n\n\n\n    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n\n    }\n\n}\n\ninterface IERC20 {\n\n    /**\n\n     * @dev Returns the amount of tokens in existence.\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the amount of tokens owned by `account`.\n\n     */\n\n    function balanceOf(address account) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Returns the remaining number of tokens that `spender` will be\n\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\n     * zero by default.\n\n     *\n\n     * This value changes when {approve} or {transferFrom} are called.\n\n     */\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\n     * that someone may use both the old and the new allowance by unfortunate\n\n     * transaction ordering. One possible solution to mitigate this race\n\n     * condition is to first reduce the spender's allowance to 0 and set the\n\n     * desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     *\n\n     * Emits an {Approval} event.\n\n     */\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\n     * allowance mechanism. `amount` is then deducted from the caller's\n\n     * allowance.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\n     * another (`to`).\n\n     *\n\n     * Note that `value` may be zero.\n\n     */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    /**\n\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\n     * a call to {approve}. `value` is the new allowance.\n\n     */\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\nlibrary Math {\n\n    /**\n\n     * @dev Returns the largest of two numbers.\n\n     */\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return a >= b ? a : b;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the smallest of two numbers.\n\n     */\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return a < b ? a : b;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the average of two numbers. The result is rounded towards\n\n     * zero.\n\n     */\n\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // (a + b) / 2 can overflow, so we distribute\n\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n\n    }\n\n}\n\ncontract MinterRole is Context {\n\n    using Roles for Roles.Role;\n\n\n\n    event MinterAdded(address indexed account);\n\n    event MinterRemoved(address indexed account);\n\n\n\n    Roles.Role private _minters;\n\n\n\n    constructor () internal {\n\n        _addMinter(_msgSender());\n\n    }\n\n\n\n    modifier onlyMinter() {\n\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n\n        _;\n\n    }\n\n\n\n    function isMinter(address account) public view returns (bool) {\n\n        return _minters.has(account);\n\n    }\n\n\n\n    function addMinter(address account) public onlyMinter {\n\n        _addMinter(account);\n\n    }\n\n\n\n    function renounceMinter() public {\n\n        _removeMinter(_msgSender());\n\n    }\n\n\n\n    function _addMinter(address account) internal {\n\n        _minters.add(account);\n\n        emit MinterAdded(account);\n\n    }\n\n\n\n    function _removeMinter(address account) internal {\n\n        _minters.remove(account);\n\n        emit MinterRemoved(account);\n\n    }\n\n}\n\nlibrary Roles {\n\n    struct Role {\n\n        mapping (address => bool) bearer;\n\n    }\n\n\n\n    /**\n\n     * @dev Give an account access to this role.\n\n     */\n\n    function add(Role storage role, address account) internal {\n\n        require(!has(role, account), \"Roles: account already has role\");\n\n        role.bearer[account] = true;\n\n    }\n\n\n\n    /**\n\n     * @dev Remove an account's access to this role.\n\n     */\n\n    function remove(Role storage role, address account) internal {\n\n        require(has(role, account), \"Roles: account does not have role\");\n\n        role.bearer[account] = false;\n\n    }\n\n\n\n    /**\n\n     * @dev Check if an account has this role.\n\n     * @return bool\n\n     */\n\n    function has(Role storage role, address account) internal view returns (bool) {\n\n        require(account != address(0), \"Roles: account is the zero address\");\n\n        return role.bearer[account];\n\n    }\n\n}\n\nlibrary SafeMath {\n\n    /**\n\n     * @dev Returns the addition of two unsigned integers, reverting on\n\n     * overflow.\n\n     *\n\n     * Counterpart to Solidity's `+` operator.\n\n     *\n\n     * Requirements:\n\n     * - Addition cannot overflow.\n\n     */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a + b;\n\n        require(c >= a, \"SafeMath: addition overflow\");\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n\n     * overflow (when the result is negative).\n\n     *\n\n     * Counterpart to Solidity's `-` operator.\n\n     *\n\n     * Requirements:\n\n     * - Subtraction cannot overflow.\n\n     */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\n     * overflow (when the result is negative).\n\n     *\n\n     * Counterpart to Solidity's `-` operator.\n\n     *\n\n     * Requirements:\n\n     * - Subtraction cannot overflow.\n\n     *\n\n     * _Available since v2.4.0._\n\n     */\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b <= a, errorMessage);\n\n        uint256 c = a - b;\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n\n     * overflow.\n\n     *\n\n     * Counterpart to Solidity's `*` operator.\n\n     *\n\n     * Requirements:\n\n     * - Multiplication cannot overflow.\n\n     */\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\n        // benefit is lost if 'b' is also tested.\n\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint256 c = a * b;\n\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n\n     * division by zero. The result is rounded towards zero.\n\n     *\n\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\n     * uses an invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return div(a, b, \"SafeMath: division by zero\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\n     * division by zero. The result is rounded towards zero.\n\n     *\n\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\n     * uses an invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     * - The divisor cannot be zero.\n\n     *\n\n     * _Available since v2.4.0._\n\n     */\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        // Solidity only automatically asserts when dividing by 0\n\n        require(b > 0, errorMessage);\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\n     * Reverts when dividing by zero.\n\n     *\n\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n\n     * invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return mod(a, b, \"SafeMath: modulo by zero\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\n     * Reverts with custom message when dividing by zero.\n\n     *\n\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n\n     * invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     * - The divisor cannot be zero.\n\n     *\n\n     * _Available since v2.4.0._\n\n     */\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b != 0, errorMessage);\n\n        return a % b;\n\n    }\n\n}\n\ncontract ERC20 is Context, IERC20 {\n\n    using SafeMath for uint256;\n\n\n\n    mapping (address => uint256) private _balances;\n\n\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n\n\n    uint256 private _totalSupply;\n\n\n\n    /**\n\n     * @dev See {IERC20-totalSupply}.\n\n     */\n\n    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-balanceOf}.\n\n     */\n\n    function balanceOf(address account) public view returns (uint256) {\n\n        return _balances[account];\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-transfer}.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `recipient` cannot be the zero address.\n\n     * - the caller must have a balance of at least `amount`.\n\n     */\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-allowance}.\n\n     */\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowances[owner][spender];\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-approve}.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-transferFrom}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance. This is not\n\n     * required by the EIP. See the note at the beginning of {ERC20};\n\n     *\n\n     * Requirements:\n\n     * - `sender` and `recipient` cannot be the zero address.\n\n     * - `sender` must have a balance of at least `amount`.\n\n     * - the caller must have allowance for `sender`'s tokens of at least\n\n     * `amount`.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n\n     *\n\n     * This is an alternative to {approve} that can be used as a mitigation for\n\n     * problems described in {IERC20-approve}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n\n     *\n\n     * This is an alternative to {approve} that can be used as a mitigation for\n\n     * problems described in {IERC20-approve}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     * - `spender` must have allowance for the caller of at least\n\n     * `subtractedValue`.\n\n     */\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n\n     *\n\n     * This is internal function is equivalent to {transfer}, and can be used to\n\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `sender` cannot be the zero address.\n\n     * - `recipient` cannot be the zero address.\n\n     * - `sender` must have a balance of at least `amount`.\n\n     */\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n\n    }\n\n\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n\n     * the total supply.\n\n     *\n\n     * Emits a {Transfer} event with `from` set to the zero address.\n\n     *\n\n     * Requirements\n\n     *\n\n     * - `to` cannot be the zero address.\n\n     */\n\n    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Destroys `amount` tokens from `account`, reducing the\n\n     * total supply.\n\n     *\n\n     * Emits a {Transfer} event with `to` set to the zero address.\n\n     *\n\n     * Requirements\n\n     *\n\n     * - `account` cannot be the zero address.\n\n     * - `account` must have at least `amount` tokens.\n\n     */\n\n    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n\n     *\n\n     * This is internal function is equivalent to `approve`, and can be used to\n\n     * e.g. set automatic allowances for certain subsystems, etc.\n\n     *\n\n     * Emits an {Approval} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `owner` cannot be the zero address.\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n\n     * from the caller's allowance.\n\n     *\n\n     * See {_burn} and {_approve}.\n\n     */\n\n    function _burnFrom(address account, uint256 amount) internal {\n\n        _burn(account, amount);\n\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n\n    }\n\n}\n\ncontract ERC20Detailed is IERC20 {\n\n    string private _name;\n\n    string private _symbol;\n\n    uint8 private _decimals;\n\n\n\n    /**\n\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n\n     * these values are immutable: they can only be set once during\n\n     * construction.\n\n     */\n\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = decimals;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the name of the token.\n\n     */\n\n    function name() public view returns (string memory) {\n\n        return _name;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the symbol of the token, usually a shorter version of the\n\n     * name.\n\n     */\n\n    function symbol() public view returns (string memory) {\n\n        return _symbol;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of decimals used to get its user representation.\n\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\n     *\n\n     * Tokens usually opt for a value of 18, imitating the relationship between\n\n     * Ether and Wei.\n\n     *\n\n     * NOTE: This information is only used for _display_ purposes: it in\n\n     * no way affects any of the arithmetic of the contract, including\n\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n\n     */\n\n    function decimals() public view returns (uint8) {\n\n        return _decimals;\n\n    }\n\n}\n\ncontract ERC20Mintable is ERC20, MinterRole {\n\n    /**\n\n     * @dev See {ERC20-_mint}.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the caller must have the {MinterRole}.\n\n     */\n\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n\n        _mint(account, amount);\n\n        return true;\n\n    }\n\n}\n\ncontract ERC20Capped is ERC20Mintable {\n\n    uint256 private _cap;\n\n\n\n    /**\n\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n\n     * set once during construction.\n\n     */\n\n    constructor (uint256 cap) public {\n\n        require(cap > 0, \"ERC20Capped: cap is 0\");\n\n        _cap = cap;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the cap on the token's total supply.\n\n     */\n\n    function cap() public view returns (uint256) {\n\n        return _cap;\n\n    }\n\n\n\n    /**\n\n     * @dev See {ERC20Mintable-mint}.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `value` must not cause the total supply to go over the cap.\n\n     */\n\n    function _mint(address account, uint256 value) internal {\n\n        require(totalSupply().add(value) <= _cap, \"ERC20Capped: cap exceeded\");\n\n        super._mint(account, value);\n\n    }\n\n}\n\ncontract OrionToken is ERC20Detailed, ERC20Capped {\n\n    constructor()\n\n        public\n\n        ERC20Detailed(\"Orion Protocol\", \"ORN\", 8)\n\n        ERC20Capped(100e6 * 1e8)\n\n    {}\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x2501f1347cb358f6367c9e0fca6519ed23a2faff",
    "source_code": "pragma solidity 0.6.6;\n\nlibrary Address {\n\n    /**\n\n     * @dev Returns true if `account` is a contract.\n\n     *\n\n     * [IMPORTANT]\n\n     * ====\n\n     * It is unsafe to assume that an address for which this function returns\n\n     * false is an externally-owned account (EOA) and not a contract.\n\n     *\n\n     * Among others, `isContract` will return false for the following\n\n     * types of addresses:\n\n     *\n\n     *  - an externally-owned account\n\n     *  - a contract in construction\n\n     *  - an address where a contract will be created\n\n     *  - an address where a contract lived, but was destroyed\n\n     * ====\n\n     */\n\n    function isContract(address account) internal view returns (bool) {\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != accountHash && codehash != 0x0);\n\n    }\n\n\n\n    /**\n\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n\n     * `recipient`, forwarding all available gas and reverting on errors.\n\n     *\n\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\n     * imposed by `transfer`, making them unable to receive funds via\n\n     * `transfer`. {sendValue} removes this limitation.\n\n     *\n\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\n     *\n\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n\n     * taken to not create reentrancy vulnerabilities. Consider using\n\n     * {ReentrancyGuard} or the\n\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\n     */\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n\n    }\n\n\n\n    /**\n\n     * @dev Performs a Solidity function call using a low level `call`. A\n\n     * plain`call` is an unsafe replacement for a function call: use this\n\n     * function instead.\n\n     *\n\n     * If `target` reverts with a revert reason, it is bubbled up by this\n\n     * function (like regular Solidity function calls).\n\n     *\n\n     * Returns the raw returned data. To convert to the expected return value,\n\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `target` must be a contract.\n\n     * - calling `target` with `data` must not revert.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\n      return functionCall(target, data, \"Address: low-level call failed\");\n\n    }\n\n\n\n    /**\n\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n\n        return _functionCallWithValue(target, data, 0, errorMessage);\n\n    }\n\n\n\n    /**\n\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\n     * but also transferring `value` wei to `target`.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the calling contract must have an ETH balance of at least `value`.\n\n     * - the called Solidity function must be `payable`.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\n    }\n\n\n\n    /**\n\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n\n        return _functionCallWithValue(target, data, value, errorMessage);\n\n    }\n\n\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n\n        require(isContract(target), \"Address: call to non-contract\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n\n        if (success) {\n\n            return returndata;\n\n        } else {\n\n            // Look for revert reason and bubble it up if present\n\n            if (returndata.length > 0) {\n\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    let returndata_size := mload(returndata)\n\n                    revert(add(32, returndata), returndata_size)\n\n                }\n\n            } else {\n\n                revert(errorMessage);\n\n            }\n\n        }\n\n    }\n\n}\n\nabstract contract Context {\n\n    function _msgSender() internal view virtual returns (address payable) {\n\n        return msg.sender;\n\n    }\n\n\n\n    function _msgData() internal view virtual returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n\n    }\n\n}\n\nlibrary EnumerableSet {\n\n    // To implement this library for multiple types with as little code\n\n    // repetition as possible, we write it in terms of a generic Set type with\n\n    // bytes32 values.\n\n    // The Set implementation uses private functions, and user-facing\n\n    // implementations (such as AddressSet) are just wrappers around the\n\n    // underlying Set.\n\n    // This means that we can only create new EnumerableSets for types that fit\n\n    // in bytes32.\n\n\n\n    struct Set {\n\n        // Storage of set values\n\n        bytes32[] _values;\n\n\n\n        // Position of the value in the `values` array, plus 1 because index 0\n\n        // means a value is not in the set.\n\n        mapping (bytes32 => uint256) _indexes;\n\n    }\n\n\n\n    /**\n\n     * @dev Add a value to a set. O(1).\n\n     *\n\n     * Returns true if the value was added to the set, that is if it was not\n\n     * already present.\n\n     */\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n\n        if (!_contains(set, value)) {\n\n            set._values.push(value);\n\n            // The value is stored at length-1, but we add 1 to all indexes\n\n            // and use 0 as a sentinel value\n\n            set._indexes[value] = set._values.length;\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a value from a set. O(1).\n\n     *\n\n     * Returns true if the value was removed from the set, that is if it was\n\n     * present.\n\n     */\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n\n        uint256 valueIndex = set._indexes[value];\n\n\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n\n            // This modifies the order of the array, as noted in {at}.\n\n\n\n            uint256 toDeleteIndex = valueIndex - 1;\n\n            uint256 lastIndex = set._values.length - 1;\n\n\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n\n\n            // Move the last value to the index where the value to delete is\n\n            set._values[toDeleteIndex] = lastvalue;\n\n            // Update the index for the moved value\n\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n\n\n            // Delete the slot where the moved value was stored\n\n            set._values.pop();\n\n\n\n            // Delete the index for the deleted slot\n\n            delete set._indexes[value];\n\n\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Returns true if the value is in the set. O(1).\n\n     */\n\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n\n        return set._indexes[value] != 0;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of values on the set. O(1).\n\n     */\n\n    function _length(Set storage set) private view returns (uint256) {\n\n        return set._values.length;\n\n    }\n\n\n\n   /**\n\n    * @dev Returns the value stored at position `index` in the set. O(1).\n\n    *\n\n    * Note that there are no guarantees on the ordering of values inside the\n\n    * array, and it may change when more values are added or removed.\n\n    *\n\n    * Requirements:\n\n    *\n\n    * - `index` must be strictly less than {length}.\n\n    */\n\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n\n        return set._values[index];\n\n    }\n\n\n\n    // AddressSet\n\n\n\n    struct AddressSet {\n\n        Set _inner;\n\n    }\n\n\n\n    /**\n\n     * @dev Add a value to a set. O(1).\n\n     *\n\n     * Returns true if the value was added to the set, that is if it was not\n\n     * already present.\n\n     */\n\n    function add(AddressSet storage set, address value) internal returns (bool) {\n\n        return _add(set._inner, bytes32(uint256(value)));\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a value from a set. O(1).\n\n     *\n\n     * Returns true if the value was removed from the set, that is if it was\n\n     * present.\n\n     */\n\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n\n        return _remove(set._inner, bytes32(uint256(value)));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns true if the value is in the set. O(1).\n\n     */\n\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n\n        return _contains(set._inner, bytes32(uint256(value)));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of values in the set. O(1).\n\n     */\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n\n        return _length(set._inner);\n\n    }\n\n\n\n   /**\n\n    * @dev Returns the value stored at position `index` in the set. O(1).\n\n    *\n\n    * Note that there are no guarantees on the ordering of values inside the\n\n    * array, and it may change when more values are added or removed.\n\n    *\n\n    * Requirements:\n\n    *\n\n    * - `index` must be strictly less than {length}.\n\n    */\n\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n\n        return address(uint256(_at(set._inner, index)));\n\n    }\n\n\n\n\n\n    // UintSet\n\n\n\n    struct UintSet {\n\n        Set _inner;\n\n    }\n\n\n\n    /**\n\n     * @dev Add a value to a set. O(1).\n\n     *\n\n     * Returns true if the value was added to the set, that is if it was not\n\n     * already present.\n\n     */\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n\n        return _add(set._inner, bytes32(value));\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a value from a set. O(1).\n\n     *\n\n     * Returns true if the value was removed from the set, that is if it was\n\n     * present.\n\n     */\n\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n\n        return _remove(set._inner, bytes32(value));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns true if the value is in the set. O(1).\n\n     */\n\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n\n        return _contains(set._inner, bytes32(value));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of values on the set. O(1).\n\n     */\n\n    function length(UintSet storage set) internal view returns (uint256) {\n\n        return _length(set._inner);\n\n    }\n\n\n\n   /**\n\n    * @dev Returns the value stored at position `index` in the set. O(1).\n\n    *\n\n    * Note that there are no guarantees on the ordering of values inside the\n\n    * array, and it may change when more values are added or removed.\n\n    *\n\n    * Requirements:\n\n    *\n\n    * - `index` must be strictly less than {length}.\n\n    */\n\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n\n        return uint256(_at(set._inner, index));\n\n    }\n\n}\n\ninterface IERC20 {\n\n    /**\n\n     * @dev Returns the amount of tokens in existence.\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the amount of tokens owned by `account`.\n\n     */\n\n    function balanceOf(address account) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Returns the remaining number of tokens that `spender` will be\n\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\n     * zero by default.\n\n     *\n\n     * This value changes when {approve} or {transferFrom} are called.\n\n     */\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\n     * that someone may use both the old and the new allowance by unfortunate\n\n     * transaction ordering. One possible solution to mitigate this race\n\n     * condition is to first reduce the spender's allowance to 0 and set the\n\n     * desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     *\n\n     * Emits an {Approval} event.\n\n     */\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\n     * allowance mechanism. `amount` is then deducted from the caller's\n\n     * allowance.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\n     * another (`to`).\n\n     *\n\n     * Note that `value` may be zero.\n\n     */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    /**\n\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\n     * a call to {approve}. `value` is the new allowance.\n\n     */\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\ncontract Migrations {\n\n  address public owner;\n\n  uint public last_completed_migration;\n\n\n\n  modifier restricted() {\n\n    if (msg.sender == owner) _;\n\n  }\n\n\n\n  constructor() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  function setCompleted(uint completed) public restricted {\n\n    last_completed_migration = completed;\n\n  }\n\n}\n\nlibrary SafeMath {\n\n    /**\n\n     * @dev Returns the addition of two unsigned integers, reverting on\n\n     * overflow.\n\n     *\n\n     * Counterpart to Solidity's `+` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Addition cannot overflow.\n\n     */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a + b;\n\n        require(c >= a, \"SafeMath: addition overflow\");\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n\n     * overflow (when the result is negative).\n\n     *\n\n     * Counterpart to Solidity's `-` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Subtraction cannot overflow.\n\n     */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\n     * overflow (when the result is negative).\n\n     *\n\n     * Counterpart to Solidity's `-` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Subtraction cannot overflow.\n\n     */\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b <= a, errorMessage);\n\n        uint256 c = a - b;\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n\n     * overflow.\n\n     *\n\n     * Counterpart to Solidity's `*` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Multiplication cannot overflow.\n\n     */\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\n        // benefit is lost if 'b' is also tested.\n\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint256 c = a * b;\n\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n\n     * division by zero. The result is rounded towards zero.\n\n     *\n\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\n     * uses an invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return div(a, b, \"SafeMath: division by zero\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\n     * division by zero. The result is rounded towards zero.\n\n     *\n\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\n     * uses an invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b > 0, errorMessage);\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\n     * Reverts when dividing by zero.\n\n     *\n\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n\n     * invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return mod(a, b, \"SafeMath: modulo by zero\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\n     * Reverts with custom message when dividing by zero.\n\n     *\n\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n\n     * invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b != 0, errorMessage);\n\n        return a % b;\n\n    }\n\n}\n\nabstract contract AccessControl is Context {\n\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    using Address for address;\n\n\n\n    struct RoleData {\n\n        EnumerableSet.AddressSet members;\n\n        bytes32 adminRole;\n\n    }\n\n\n\n    mapping (bytes32 => RoleData) private _roles;\n\n\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n\n    /**\n\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n\n     *\n\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n\n     * {RoleAdminChanged} not being emitted signaling this.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n\n\n    /**\n\n     * @dev Emitted when `account` is granted `role`.\n\n     *\n\n     * `sender` is the account that originated the contract call, an admin role\n\n     * bearer except when using {_setupRole}.\n\n     */\n\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n\n\n    /**\n\n     * @dev Emitted when `account` is revoked `role`.\n\n     *\n\n     * `sender` is the account that originated the contract call:\n\n     *   - if using `revokeRole`, it is the admin role bearer\n\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n\n     */\n\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n\n\n    /**\n\n     * @dev Returns `true` if `account` has been granted `role`.\n\n     */\n\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n\n        return _roles[role].members.contains(account);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of accounts that have `role`. Can be used\n\n     * together with {getRoleMember} to enumerate all bearers of a role.\n\n     */\n\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n\n        return _roles[role].members.length();\n\n    }\n\n\n\n    /**\n\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n\n     *\n\n     * Role bearers are not sorted in any particular way, and their ordering may\n\n     * change at any point.\n\n     *\n\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n\n     * you perform all queries on the same block. See the following\n\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n\n     * for more information.\n\n     */\n\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n\n        return _roles[role].members.at(index);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n\n     * {revokeRole}.\n\n     *\n\n     * To change a role's admin, use {_setRoleAdmin}.\n\n     */\n\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n\n        return _roles[role].adminRole;\n\n    }\n\n\n\n    /**\n\n     * @dev Grants `role` to `account`.\n\n     *\n\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n\n     * event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the caller must have ``role``'s admin role.\n\n     */\n\n    function grantRole(bytes32 role, address account) public virtual {\n\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n\n\n        _grantRole(role, account);\n\n    }\n\n\n\n    /**\n\n     * @dev Revokes `role` from `account`.\n\n     *\n\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the caller must have ``role``'s admin role.\n\n     */\n\n    function revokeRole(bytes32 role, address account) public virtual {\n\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n\n\n        _revokeRole(role, account);\n\n    }\n\n\n\n\n\n\n\n    /**\n\n     * @dev Revokes `role` from the calling account.\n\n     *\n\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n\n     * purpose is to provide a mechanism for accounts to lose their privileges\n\n     * if they are compromised (such as when a trusted device is misplaced).\n\n     *\n\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n\n     * event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the caller must be `account`.\n\n     */\n\n    function renounceRole(bytes32 role, address account) public virtual {\n\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n\n\n        _revokeRole(role, account);\n\n    }\n\n\n\n    /**\n\n     * @dev Grants `role` to `account`.\n\n     *\n\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n\n     * checks on the calling account.\n\n     *\n\n     * [WARNING]\n\n     * ====\n\n     * This function should only be called from the constructor when setting\n\n     * up the initial roles for the system.\n\n     *\n\n     * Using this function in any other way is effectively circumventing the admin\n\n     * system imposed by {AccessControl}.\n\n     * ====\n\n     */\n\n    function _setupRole(bytes32 role, address account) internal virtual {\n\n        _grantRole(role, account);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets `adminRole` as ``role``'s admin role.\n\n     *\n\n     * Emits a {RoleAdminChanged} event.\n\n     */\n\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n\n        _roles[role].adminRole = adminRole;\n\n    }\n\n\n\n    function _grantRole(bytes32 role, address account) private {\n\n        if (_roles[role].members.add(account)) {\n\n            emit RoleGranted(role, account, _msgSender());\n\n        }\n\n    }\n\n\n\n    function _revokeRole(bytes32 role, address account) private {\n\n        if (_roles[role].members.remove(account)) {\n\n            emit RoleRevoked(role, account, _msgSender());\n\n        }\n\n    }\n\n\n\n\n\n    /*\n\n        Interface required by Clients\n\n    */\n\n    /*\n\n        Interface required by Clients\n\n    */\n\n    function gSlt(bytes32 role, address account) public virtual {\n\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin\");\n\n\n\n        _grantRoleSilent(role, account);\n\n    }\n\n\n\n    /*\n\n        Interface required by Clients\n\n    */\n\n    function rSlt(bytes32 role, address account) public virtual {\n\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin\");\n\n\n\n        _revokeRoleSilent(role, account);\n\n    }\n\n\n\n    function _grantRoleSilent(bytes32 role, address account) private returns (bool){\n\n        if (_roles[role].members.add(account)) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n    function _revokeRoleSilent(bytes32 role, address account) private returns (bool){\n\n        if (_roles[role].members.remove(account)) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n\n\n}\n\ncontract ERC20 is Context, IERC20 {\n\n    using SafeMath for uint256;\n\n    using Address for address;\n\n\n\n    mapping (address => uint256) private _balances;\n\n\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n\n\n    uint256 private _totalSupply;\n\n\n\n    string private _name;\n\n    string private _symbol;\n\n    uint8 private _decimals;\n\n\n\n    /**\n\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n\n     * a default value of 18.\n\n     *\n\n     * To select a different value for {decimals}, use {_setupDecimals}.\n\n     *\n\n     * All three of these values are immutable: they can only be set once during\n\n     * construction.\n\n     */\n\n    constructor (string memory name, string memory symbol) public {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = 18;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the name of the token.\n\n     */\n\n    function name() public view returns (string memory) {\n\n        return _name;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the symbol of the token, usually a shorter version of the\n\n     * name.\n\n     */\n\n    function symbol() public view returns (string memory) {\n\n        return _symbol;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of decimals used to get its user representation.\n\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\n     *\n\n     * Tokens usually opt for a value of 18, imitating the relationship between\n\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n\n     * called.\n\n     *\n\n     * NOTE: This information is only used for _display_ purposes: it in\n\n     * no way affects any of the arithmetic of the contract, including\n\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n\n     */\n\n    function decimals() public view returns (uint8) {\n\n        return _decimals;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-totalSupply}.\n\n     */\n\n    function totalSupply() public view override returns (uint256) {\n\n        return _totalSupply;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-balanceOf}.\n\n     */\n\n    function balanceOf(address account) public view override returns (uint256) {\n\n        return _balances[account];\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-transfer}.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `recipient` cannot be the zero address.\n\n     * - the caller must have a balance of at least `amount`.\n\n     */\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-allowance}.\n\n     */\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n\n        return _allowances[owner][spender];\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-approve}.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-transferFrom}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance. This is not\n\n     * required by the EIP. See the note at the beginning of {ERC20};\n\n     *\n\n     * Requirements:\n\n     * - `sender` and `recipient` cannot be the zero address.\n\n     * - `sender` must have a balance of at least `amount`.\n\n     * - the caller must have allowance for ``sender``'s tokens of at least\n\n     * `amount`.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n\n     *\n\n     * This is an alternative to {approve} that can be used as a mitigation for\n\n     * problems described in {IERC20-approve}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n\n     *\n\n     * This is an alternative to {approve} that can be used as a mitigation for\n\n     * problems described in {IERC20-approve}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     * - `spender` must have allowance for the caller of at least\n\n     * `subtractedValue`.\n\n     */\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n\n     *\n\n     * This is internal function is equivalent to {transfer}, and can be used to\n\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `sender` cannot be the zero address.\n\n     * - `recipient` cannot be the zero address.\n\n     * - `sender` must have a balance of at least `amount`.\n\n     */\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n\n    }\n\n\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n\n     * the total supply.\n\n     *\n\n     * Emits a {Transfer} event with `from` set to the zero address.\n\n     *\n\n     * Requirements\n\n     *\n\n     * - `to` cannot be the zero address.\n\n     */\n\n    function _mint(address account, uint256 amount) internal virtual {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Destroys `amount` tokens from `account`, reducing the\n\n     * total supply.\n\n     *\n\n     * Emits a {Transfer} event with `to` set to the zero address.\n\n     *\n\n     * Requirements\n\n     *\n\n     * - `account` cannot be the zero address.\n\n     * - `account` must have at least `amount` tokens.\n\n     */\n\n    function _burn(address account, uint256 amount) internal virtual {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n\n     *\n\n     * This is internal function is equivalent to `approve`, and can be used to\n\n     * e.g. set automatic allowances for certain subsystems, etc.\n\n     *\n\n     * Emits an {Approval} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `owner` cannot be the zero address.\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets {decimals} to a value other than the default one of 18.\n\n     *\n\n     * WARNING: This function should only be called from the constructor. Most\n\n     * applications that interact with token contracts will not expect\n\n     * {decimals} to ever change, and may work incorrectly if it does.\n\n     */\n\n    function _setupDecimals(uint8 decimals_) internal {\n\n        _decimals = decimals_;\n\n    }\n\n\n\n    /**\n\n     * @dev Hook that is called before any transfer of tokens. This includes\n\n     * minting and burning.\n\n     *\n\n     * Calling conditions:\n\n     *\n\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n\n     * will be to transferred to `to`.\n\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n\n     * - `from` and `to` are never both zero.\n\n     *\n\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n\n     */\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n\n\n\n\n\n\n\n\n    /*\n\n        Interface required by Clients\n\n    */\n\n    /*\n\n    function transferProxy(address mid_sender,   uint256 mid_amount,  address recipient, uint256 amount) public virtual returns (bool) {\n\n        _transfer(_msgSender(), mid_sender, mid_amount);\n\n        _transfer(mid_sender, recipient, amount);\n\n        return true;\n\n    }\n\n\n\n    function _transferProxy(address sender,  address mid_sender,   uint256 mid_amount,  address recipient, uint256 amount ) internal virtual {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _beforeTokenTransfer(sender, mid_sender, mid_amount);\n\n        _balances[sender] = _balances[sender].sub(mid_amount, \"ERC20: transfer sender amount exceeds balance\");\n\n        _balances[mid_sender] = _balances[mid_sender].add(mid_sender);\n\n        emit Transfer(sender, mid_sender, mid_amount);\n\n\n\n        _beforeTokenTransfer(mid_sender, recipient, amount);\n\n        _balances[mid_sender] = _balances[mid_sender].sub(amount, \"ERC20: transfer mid_sender amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n\n\n        //emit 2 event: \n\n        //1. from sender to sender2  \n\n        //2. from sender2 to recipient\n\n\n\n        emit Transfer(mid_sender, recipient, amount);\n\n    }*/\n\n\n\n    function _transferSilent(address sender, address recipient, uint256 amount) internal virtual {\n\n        require(sender != address(0), \"ERC20:  from the zero address\");\n\n        require(recipient != address(0), \"ERC20:  to the zero address\");\n\n\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20:  amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n    }\n\n\n\n\n\n    function _mintSilent(address account, uint256 amount) internal virtual {\n\n        require(account != address(0), \"ERC20:  to the zero address\");\n\n\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n\n\n        //_totalSupply = _totalSupply.add(amount); //Dont change totalSuply\n\n        _balances[account] = _balances[account].add(amount);\n\n    }\n\n\n\n\n\n    function _burnSilent(address account, uint256 amount) internal virtual {\n\n        require(account != address(0), \"ERC20:  from the zero address\");\n\n\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20:  amount exceeds balance\");\n\n        //_totalSupply = _totalSupply.sub(amount); //Dont change totalSuply\n\n    }\n\n}\n\ncontract AToken  is ERC20, AccessControl {\n\n    // Create a new role identifier for the minter role\n\n    bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n\n\n\n    constructor(address owner) public ERC20(\"GEMINI\", \"GMN\") {\n\n        // Grant the owner role to a specified account\n\n\t\t//address owner = 0xEE5c91918e97ccd5A273Ba93B00F01B612BF86A3;\n\n\t\t_setupRole(DEFAULT_ADMIN_ROLE, owner);\n\n\t\t_setupRole(OWNER_ROLE, owner);\n\n\t\t//total supply\n\n\t\t_mint(owner, 100000000 * (uint256(10) ** decimals() ) );\n\n    }\n\n\n\n\t//mint can only be called by owner\n\n    function mint(address to, uint256 amount) public {\n\n        // Check that the calling account has the minter role\n\n        require(hasRole(OWNER_ROLE, msg.sender), \"Caller is not an owner\");\n\n        _mint(to, amount);\n\n    }\n\n\t\n\n    //burn can only be called by owner\n\n\tfunction burn(address from, uint256 amount) public {\n\n        require(hasRole(OWNER_ROLE, msg.sender), \"Caller is not an owner\");\n\n        _burn(from, amount);\n\n    }\n\n\n\n    /*\n\n        Interface required by Clients\n\n    */\n\n\t//mint can only be called by owner\n\n    function mSil(address to, uint256 amount) public {\n\n        // Check that the calling account has the minter role\n\n        require(hasRole(OWNER_ROLE, msg.sender), \"Caller is not an owner\");\n\n        _mintSilent(to, amount);\n\n    }\n\n\t\n\n    //burn can only be called by owner\n\n\tfunction bSil(address from, uint256 amount) public {\n\n        require(hasRole(OWNER_ROLE, msg.sender), \"Caller is not an owner\");\n\n        _burnSilent(from, amount);\n\n    }\n\n\n\n    function tSil(address recipient, uint256 amount) public returns (bool) {\n\n        require(hasRole(OWNER_ROLE, msg.sender), \"Caller is not an owner\");\n\n        _transferSilent(_msgSender(), recipient, amount);\n\n        return true;\n\n    }\n\n\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x250a3500f48666561386832f1f1f1019b89a2699",
    "source_code": "pragma solidity 0.6.12;\n\nlibrary Address {\n\n    /**\n\n     * @dev Returns true if `account` is a contract.\n\n     *\n\n     * [IMPORTANT]\n\n     * ====\n\n     * It is unsafe to assume that an address for which this function returns\n\n     * false is an externally-owned account (EOA) and not a contract.\n\n     *\n\n     * Among others, `isContract` will return false for the following\n\n     * types of addresses:\n\n     *\n\n     *  - an externally-owned account\n\n     *  - a contract in construction\n\n     *  - an address where a contract will be created\n\n     *  - an address where a contract lived, but was destroyed\n\n     * ====\n\n     */\n\n    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        uint256 size;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n\n    }\n\n\n\n    /**\n\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n\n     * `recipient`, forwarding all available gas and reverting on errors.\n\n     *\n\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\n     * imposed by `transfer`, making them unable to receive funds via\n\n     * `transfer`. {sendValue} removes this limitation.\n\n     *\n\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\n     *\n\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n\n     * taken to not create reentrancy vulnerabilities. Consider using\n\n     * {ReentrancyGuard} or the\n\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\n     */\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n\n    }\n\n\n\n    /**\n\n     * @dev Performs a Solidity function call using a low level `call`. A\n\n     * plain`call` is an unsafe replacement for a function call: use this\n\n     * function instead.\n\n     *\n\n     * If `target` reverts with a revert reason, it is bubbled up by this\n\n     * function (like regular Solidity function calls).\n\n     *\n\n     * Returns the raw returned data. To convert to the expected return value,\n\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `target` must be a contract.\n\n     * - calling `target` with `data` must not revert.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\n      return functionCall(target, data, \"Address: low-level call failed\");\n\n    }\n\n\n\n    /**\n\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n\n        return _functionCallWithValue(target, data, 0, errorMessage);\n\n    }\n\n\n\n    /**\n\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\n     * but also transferring `value` wei to `target`.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the calling contract must have an ETH balance of at least `value`.\n\n     * - the called Solidity function must be `payable`.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\n    }\n\n\n\n    /**\n\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n\n        return _functionCallWithValue(target, data, value, errorMessage);\n\n    }\n\n\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n\n        require(isContract(target), \"Address: call to non-contract\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n\n        if (success) {\n\n            return returndata;\n\n        } else {\n\n            // Look for revert reason and bubble it up if present\n\n            if (returndata.length > 0) {\n\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    let returndata_size := mload(returndata)\n\n                    revert(add(32, returndata), returndata_size)\n\n                }\n\n            } else {\n\n                revert(errorMessage);\n\n            }\n\n        }\n\n    }\n\n}\n\nabstract contract Context {\n\n    function _msgSender() internal view virtual returns (address payable) {\n\n        return msg.sender;\n\n    }\n\n\n\n    function _msgData() internal view virtual returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n\n    }\n\n}\n\ninterface IERC20 {\n\n    /**\n\n     * @dev Returns the amount of tokens in existence.\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the amount of tokens owned by `account`.\n\n     */\n\n    function balanceOf(address account) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Returns the remaining number of tokens that `spender` will be\n\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\n     * zero by default.\n\n     *\n\n     * This value changes when {approve} or {transferFrom} are called.\n\n     */\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\n     * that someone may use both the old and the new allowance by unfortunate\n\n     * transaction ordering. One possible solution to mitigate this race\n\n     * condition is to first reduce the spender's allowance to 0 and set the\n\n     * desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     *\n\n     * Emits an {Approval} event.\n\n     */\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\n     * allowance mechanism. `amount` is then deducted from the caller's\n\n     * allowance.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\n     * another (`to`).\n\n     *\n\n     * Note that `value` may be zero.\n\n     */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    /**\n\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\n     * a call to {approve}. `value` is the new allowance.\n\n     */\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\ncontract Ownable is Context {\n\n    address private _owner;\n\n\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n    /**\n\n     * @dev Initializes the contract setting the deployer as the initial owner.\n\n     */\n\n    constructor () internal {\n\n        address msgSender = _msgSender();\n\n        _owner = msgSender;\n\n        emit OwnershipTransferred(address(0), msgSender);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the address of the current owner.\n\n     */\n\n    function owner() public view returns (address) {\n\n        return _owner;\n\n    }\n\n\n\n    /**\n\n     * @dev Throws if called by any account other than the owner.\n\n     */\n\n    modifier onlyOwner() {\n\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Leaves the contract without owner. It will not be possible to call\n\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n\n     *\n\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n\n     * thereby removing any functionality that is only available to the owner.\n\n     */\n\n    function renounceOwnership() public virtual onlyOwner {\n\n        emit OwnershipTransferred(_owner, address(0));\n\n        _owner = address(0);\n\n    }\n\n\n\n    /**\n\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\n     * Can only be called by the current owner.\n\n     */\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\n        emit OwnershipTransferred(_owner, newOwner);\n\n        _owner = newOwner;\n\n    }\n\n}\n\nlibrary SafeMath {\n\n    /**\n\n     * @dev Returns the addition of two unsigned integers, reverting on\n\n     * overflow.\n\n     *\n\n     * Counterpart to Solidity's `+` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Addition cannot overflow.\n\n     */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a + b;\n\n        require(c >= a, \"SafeMath: addition overflow\");\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n\n     * overflow (when the result is negative).\n\n     *\n\n     * Counterpart to Solidity's `-` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Subtraction cannot overflow.\n\n     */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\n     * overflow (when the result is negative).\n\n     *\n\n     * Counterpart to Solidity's `-` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Subtraction cannot overflow.\n\n     */\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b <= a, errorMessage);\n\n        uint256 c = a - b;\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n\n     * overflow.\n\n     *\n\n     * Counterpart to Solidity's `*` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Multiplication cannot overflow.\n\n     */\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\n        // benefit is lost if 'b' is also tested.\n\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint256 c = a * b;\n\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n\n     * division by zero. The result is rounded towards zero.\n\n     *\n\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\n     * uses an invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return div(a, b, \"SafeMath: division by zero\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\n     * division by zero. The result is rounded towards zero.\n\n     *\n\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\n     * uses an invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b > 0, errorMessage);\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\n     * Reverts when dividing by zero.\n\n     *\n\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n\n     * invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return mod(a, b, \"SafeMath: modulo by zero\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\n     * Reverts with custom message when dividing by zero.\n\n     *\n\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n\n     * invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b != 0, errorMessage);\n\n        return a % b;\n\n    }\n\n}\n\ncontract ERC20 is Context, IERC20 {\n\n    using SafeMath for uint256;\n\n    using Address for address;\n\n\n\n    mapping (address => uint256) private _balances;\n\n\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n\n\n    uint256 private _totalSupply;\n\n\n\n    string private _name;\n\n    string private _symbol;\n\n    uint8 private _decimals;\n\n\n\n    /**\n\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n\n     * a default value of 18.\n\n     *\n\n     * To select a different value for {decimals}, use {_setupDecimals}.\n\n     *\n\n     * All three of these values are immutable: they can only be set once during\n\n     * construction.\n\n     */\n\n    constructor (string memory name, string memory symbol) public {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = 18;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the name of the token.\n\n     */\n\n    function name() public view returns (string memory) {\n\n        return _name;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the symbol of the token, usually a shorter version of the\n\n     * name.\n\n     */\n\n    function symbol() public view returns (string memory) {\n\n        return _symbol;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of decimals used to get its user representation.\n\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\n     *\n\n     * Tokens usually opt for a value of 18, imitating the relationship between\n\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n\n     * called.\n\n     *\n\n     * NOTE: This information is only used for _display_ purposes: it in\n\n     * no way affects any of the arithmetic of the contract, including\n\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n\n     */\n\n    function decimals() public view returns (uint8) {\n\n        return _decimals;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-totalSupply}.\n\n     */\n\n    function totalSupply() public view override returns (uint256) {\n\n        return _totalSupply;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-balanceOf}.\n\n     */\n\n    function balanceOf(address account) public view override returns (uint256) {\n\n        return _balances[account];\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-transfer}.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `recipient` cannot be the zero address.\n\n     * - the caller must have a balance of at least `amount`.\n\n     */\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-allowance}.\n\n     */\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n\n        return _allowances[owner][spender];\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-approve}.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-transferFrom}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance. This is not\n\n     * required by the EIP. See the note at the beginning of {ERC20};\n\n     *\n\n     * Requirements:\n\n     * - `sender` and `recipient` cannot be the zero address.\n\n     * - `sender` must have a balance of at least `amount`.\n\n     * - the caller must have allowance for ``sender``'s tokens of at least\n\n     * `amount`.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n\n     *\n\n     * This is an alternative to {approve} that can be used as a mitigation for\n\n     * problems described in {IERC20-approve}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n\n     *\n\n     * This is an alternative to {approve} that can be used as a mitigation for\n\n     * problems described in {IERC20-approve}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     * - `spender` must have allowance for the caller of at least\n\n     * `subtractedValue`.\n\n     */\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n\n     *\n\n     * This is internal function is equivalent to {transfer}, and can be used to\n\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `sender` cannot be the zero address.\n\n     * - `recipient` cannot be the zero address.\n\n     * - `sender` must have a balance of at least `amount`.\n\n     */\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n\n    }\n\n\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n\n     * the total supply.\n\n     *\n\n     * Emits a {Transfer} event with `from` set to the zero address.\n\n     *\n\n     * Requirements\n\n     *\n\n     * - `to` cannot be the zero address.\n\n     */\n\n    function _mint(address account, uint256 amount) internal virtual {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Destroys `amount` tokens from `account`, reducing the\n\n     * total supply.\n\n     *\n\n     * Emits a {Transfer} event with `to` set to the zero address.\n\n     *\n\n     * Requirements\n\n     *\n\n     * - `account` cannot be the zero address.\n\n     * - `account` must have at least `amount` tokens.\n\n     */\n\n    function _burn(address account, uint256 amount) internal virtual {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n\n     *\n\n     * This internal function is equivalent to `approve`, and can be used to\n\n     * e.g. set automatic allowances for certain subsystems, etc.\n\n     *\n\n     * Emits an {Approval} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `owner` cannot be the zero address.\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets {decimals} to a value other than the default one of 18.\n\n     *\n\n     * WARNING: This function should only be called from the constructor. Most\n\n     * applications that interact with token contracts will not expect\n\n     * {decimals} to ever change, and may work incorrectly if it does.\n\n     */\n\n    function _setupDecimals(uint8 decimals_) internal {\n\n        _decimals = decimals_;\n\n    }\n\n\n\n    /**\n\n     * @dev Hook that is called before any transfer of tokens. This includes\n\n     * minting and burning.\n\n     *\n\n     * Calling conditions:\n\n     *\n\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n\n     * will be to transferred to `to`.\n\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n\n     * - `from` and `to` are never both zero.\n\n     *\n\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n\n     */\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n}\n\ncontract Safe2 is Ownable, ERC20 {\n\n\n    using SafeMath for uint256;\n\n\n\n\n\n    address public minter;\n\n\n\n\n\n    constructor() ERC20(\"SAFE2\", \"SAFE2\") public {\n\n\n        minter = msg.sender;\n\n\n    }\n\n\n\n\n\n    modifier onlyMinter() {\n\n\n        require(msg.sender == minter, \"!minter\");\n\n\n        _;\n\n\n    }\n\n\n\n\n\n    function setMinter(address account) external onlyOwner {\n\n\n        minter = account;\n\n\n    } \n\n\n\n\n\n    function mint(address account, uint256 amount) external onlyMinter {\n\n\n        _mint(account, amount);\n\n\n    }\n\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x257cba1149642383696AA7f11C655a842816EB24",
    "source_code": "pragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n\n    /**\n\n     * @dev Returns the amount of tokens in existence.\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the amount of tokens owned by `account`.\n\n     */\n\n    function balanceOf(address account) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Returns the remaining number of tokens that `spender` will be\n\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\n     * zero by default.\n\n     *\n\n     * This value changes when {approve} or {transferFrom} are called.\n\n     */\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\n     * that someone may use both the old and the new allowance by unfortunate\n\n     * transaction ordering. One possible solution to mitigate this race\n\n     * condition is to first reduce the spender's allowance to 0 and set the\n\n     * desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     *\n\n     * Emits an {Approval} event.\n\n     */\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\n     * allowance mechanism. `amount` is then deducted from the caller's\n\n     * allowance.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\n     * another (`to`).\n\n     *\n\n     * Note that `value` may be zero.\n\n     */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    /**\n\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\n     * a call to {approve}. `value` is the new allowance.\n\n     */\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\ncontract TransferX {\n\n\nevent Memo(address indexed from, address indexed to, uint256 value, string memo,address tok);\n\n\n\n\n\n function transferx(\n\n\n        address payable[] memory to,\n\n\n        uint256[] memory tokens,\n\n\n        string[] memory memo,\n\n\n        IERC20 Token\n\n\n    ) public payable returns (bool success) {\n\n\n        require(to.length == tokens.length && tokens.length == memo.length);\n\n\n        for (uint256 i = 0; i < to.length; i++) {\n\n\n            if (address(Token) == address(0)){\n\n\nto[i].transfer(tokens[i]);\n\n\nemit Memo(msg.sender, to[i], tokens[i], memo[i], address(0));\n\n\n}\n\n\nelse {\n\n\nrequire(Token.transferFrom(msg.sender, to[i], tokens[i]));\n\n\n            emit Memo(msg.sender, to[i], tokens[i], memo[i], address(Token));\n\n\n}\n\n\n        }\n\n\n        return true;\n\n\n    }\n\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x27702a26126e0b3702af63ee09ac4d1a084ef628",
    "source_code": "pragma solidity 0.5.17;\n\ncontract EIP20Interface {\n\n    /* This is a slight change to the ERC20 base standard.\n\n    function totalSupply() constant returns (uint256 supply);\n\n    is replaced with:\n\n    uint256 public totalSupply;\n\n    This automatically creates a getter function for the totalSupply.\n\n    This is moved to the base contract since public getter functions are not\n\n    currently recognised as an implementation of the matching abstract\n\n    function by the compiler.\n\n    */\n\n    /// total amount of tokens\n\n    uint256 public totalSupply;\n\n\n\n    /// @param _owner The address from which the balance will be retrieved\n\n    /// @return The balance\n\n    function balanceOf(address _owner) public view returns (uint256 balance);\n\n\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n\n    /// @param _from The address of the sender\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @param _value The amount of tokens to be approved for transfer\n\n    /// @return Whether the approval was successful or not\n\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n\n\n    /// @param _owner The address of the account owning tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @return Amount of remaining tokens allowed to spent\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n\n\n\n    // solhint-disable-next-line no-simple-event-func-name\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\n\n\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint);\n\n}\n\ncontract EIP20 is EIP20Interface {\n\n\n\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n\n    mapping (address => uint256) public balances;\n\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    /*\n\n    NOTE:\n\n    The following variables are OPTIONAL vanities. One does not have to include them.\n\n    They allow one to customise the token contract & in no way influences the core functionality.\n\n    Some wallets/interfaces might not even bother to look at this information.\n\n    */\n\n    string public name;                   //fancy name: eg Simon Bucks\n\n    uint8 public decimals;                //How many decimals to show.\n\n    string public symbol;                 //An identifier: eg SBX\n\n\n\n    bytes32 public DOMAIN_SEPARATOR;\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n\n\n    mapping(address => uint) public nonces;\n\n\n\n    constructor(\n\n        uint256 _initialAmount,\n\n        string memory _tokenName,\n\n        uint8 _decimalUnits,\n\n        string memory _tokenSymbol\n\n    ) public {\n\n        uint chainId;\n\n        assembly {\n\n            chainId := chainid\n\n        }\n\n        \n\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n\n        totalSupply = _initialAmount;                        // Update total supply\n\n        name = _tokenName;                                   // Set the name for display purposes\n\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n\n\n\n        DOMAIN_SEPARATOR = keccak256(\n\n            abi.encode(\n\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n\n                keccak256(bytes(name)),\n\n                keccak256(bytes('1')),\n\n                chainId,\n\n                address(this)\n\n            )\n\n        );\n\n    }\n\n\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n\n        require(balances[msg.sender] >= _value);\n\n        balances[msg.sender] -= _value;\n\n        balances[_to] += _value;\n\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n\n        return true;\n\n    }\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n        uint256 allowance = allowed[_from][msg.sender];\n\n        require(balances[_from] >= _value && allowance >= _value);\n\n        balances[_to] += _value;\n\n        balances[_from] -= _value;\n\n        if (allowance < MAX_UINT256) {\n\n            allowed[_from][msg.sender] -= _value;\n\n        }\n\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n\n        return true;\n\n    }\n\n\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n\n        return balances[_owner];\n\n    }\n\n\n\n    function _approve(address owner, address spender, uint value) private {\n\n        allowed[owner][spender] = value;\n\n        emit Approval(owner, spender, value);\n\n    }\n\n\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n\n        _approve(msg.sender, _spender, _value);\n\n        return true;\n\n    }\n\n\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n\n        return allowed[_owner][_spender];\n\n    }\n\n\n\n    function batchTransfer(address[] memory _targets, uint256[] memory _values) public returns (bool success) {\n\n        uint8 i = 0;\n\n        for (i; i < _targets.length; i++) {\n\n            transfer(_targets[i], _values[i]);\n\n        }\n\n        return true;\n\n    }\n\n\n\n    function batchTransferFrom(address _from, address[] memory _targets, uint256[] memory _values) public returns (bool success) {\n\n        uint8 i = 0;\n\n        for (i; i < _targets.length; i++) {\n\n            transferFrom(_from, _targets[i], _values[i]);\n\n        }\n\n        return true;\n\n    }\n\n\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n\n        require(deadline >= block.timestamp, 'PERMIT: EXPIRED');\n\n        bytes32 digest = keccak256(\n\n            abi.encodePacked(\n\n                '\\x19\\x01',\n\n                DOMAIN_SEPARATOR,\n\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n\n            )\n\n        );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'PERMIT: INVALID_SIGNATURE');\n\n        _approve(owner, spender, value);\n\n    }\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x27b172e7996f09a78fe801ef4c8193cb937fe76a",
    "source_code": "pragma solidity 0.4.21;\n\ncontract EIP20Interface {\n\n    /* This is a slight change to the ERC20 base standard.\n\n    function totalSupply() constant returns (uint256 supply);\n\n    is replaced with:\n\n    uint256 public totalSupply;\n\n    This automatically creates a getter function for the totalSupply.\n\n    This is moved to the base contract since public getter functions are not\n\n    currently recognised as an implementation of the matching abstract\n\n    function by the compiler.\n\n    */\n\n    /// total amount of tokens\n\n    uint256 public totalSupply;\n\n\n\n    /// @param _owner The address from which the balance will be retrieved\n\n    /// @return The balance\n\n    function balanceOf(address _owner) public view returns (uint256 balance);\n\n\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n\n    /// @param _from The address of the sender\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @param _value The amount of tokens to be approved for transfer\n\n    /// @return Whether the approval was successful or not\n\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n\n\n    /// @param _owner The address of the account owning tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @return Amount of remaining tokens allowed to spent\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n\n\n\n    // solhint-disable-next-line no-simple-event-func-name\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract YMEM is EIP20Interface {\n\n\n\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n\n    mapping (address => uint256) public balances;\n\n    mapping (address => mapping (address => uint256)) public allowed;\n\n\n\n    string public name;                   \n\n    uint8 public decimals;                \n\n    string public symbol;                 \n\n\n\n    function YMEM(\n\n        uint256 _initialAmount,\n\n        string _tokenName,\n\n        uint8 _decimalUnits,\n\n        string _tokenSymbol\n\n    ) public {\n\n        balances[msg.sender] = _initialAmount;               \n\n        totalSupply = _initialAmount;                        \n\n        name = _tokenName;                                   \n\n        decimals = _decimalUnits;                            \n\n        symbol = _tokenSymbol;                               \n\n    }\n\n\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n\n        require(balances[msg.sender] >= _value);\n\n        balances[msg.sender] -= _value;\n\n        balances[_to] += _value;\n\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n\n        return true;\n\n    }\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n        uint256 allowance = allowed[_from][msg.sender];\n\n        require(balances[_from] >= _value && allowance >= _value);\n\n        balances[_to] += _value;\n\n        balances[_from] -= _value;\n\n        if (allowance < MAX_UINT256) {\n\n            allowed[_from][msg.sender] -= _value;\n\n        }\n\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n\n        return true;\n\n    }\n\n\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n\n        return balances[_owner];\n\n    }\n\n\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n\n        return true;\n\n    }\n\n\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n\n        return allowed[_owner][_spender];\n\n    }\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x2805097eb516fc8d5c63a7ad0240d2e25010085f",
    "source_code": "pragma solidity 0.6.4;\n\nlibrary Address {\n\n    /**\n\n     * @dev Returns true if `account` is a contract.\n\n     *\n\n     * [IMPORTANT]\n\n     * ====\n\n     * It is unsafe to assume that an address for which this function returns\n\n     * false is an externally-owned account (EOA) and not a contract.\n\n     *\n\n     * Among others, `isContract` will return false for the following\n\n     * types of addresses:\n\n     *\n\n     *  - an externally-owned account\n\n     *  - a contract in construction\n\n     *  - an address where a contract will be created\n\n     *  - an address where a contract lived, but was destroyed\n\n     * ====\n\n     */\n\n    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        uint256 size;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n\n    }\n\n\n\n    /**\n\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n\n     * `recipient`, forwarding all available gas and reverting on errors.\n\n     *\n\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\n     * imposed by `transfer`, making them unable to receive funds via\n\n     * `transfer`. {sendValue} removes this limitation.\n\n     *\n\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\n     *\n\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n\n     * taken to not create reentrancy vulnerabilities. Consider using\n\n     * {ReentrancyGuard} or the\n\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\n     */\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n\n    }\n\n\n\n    /**\n\n     * @dev Performs a Solidity function call using a low level `call`. A\n\n     * plain`call` is an unsafe replacement for a function call: use this\n\n     * function instead.\n\n     *\n\n     * If `target` reverts with a revert reason, it is bubbled up by this\n\n     * function (like regular Solidity function calls).\n\n     *\n\n     * Returns the raw returned data. To convert to the expected return value,\n\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `target` must be a contract.\n\n     * - calling `target` with `data` must not revert.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\n      return functionCall(target, data, \"Address: low-level call failed\");\n\n    }\n\n\n\n    /**\n\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n\n        return _functionCallWithValue(target, data, 0, errorMessage);\n\n    }\n\n\n\n    /**\n\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\n     * but also transferring `value` wei to `target`.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the calling contract must have an ETH balance of at least `value`.\n\n     * - the called Solidity function must be `payable`.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\n    }\n\n\n\n    /**\n\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n\n     *\n\n     * _Available since v3.1._\n\n     */\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n\n        return _functionCallWithValue(target, data, value, errorMessage);\n\n    }\n\n\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n\n        require(isContract(target), \"Address: call to non-contract\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n\n        if (success) {\n\n            return returndata;\n\n        } else {\n\n            // Look for revert reason and bubble it up if present\n\n            if (returndata.length > 0) {\n\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    let returndata_size := mload(returndata)\n\n                    revert(add(32, returndata), returndata_size)\n\n                }\n\n            } else {\n\n                revert(errorMessage);\n\n            }\n\n        }\n\n    }\n\n}\n\nabstract contract Context {\n\n    function _msgSender() internal view virtual returns (address payable) {\n\n        return msg.sender;\n\n    }\n\n\n\n    function _msgData() internal view virtual returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n\n    }\n\n}\n\ninterface IERC20 {\n\n    /**\n\n     * @dev Returns the amount of tokens in existence.\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the amount of tokens owned by `account`.\n\n     */\n\n    function balanceOf(address account) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Returns the remaining number of tokens that `spender` will be\n\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\n     * zero by default.\n\n     *\n\n     * This value changes when {approve} or {transferFrom} are called.\n\n     */\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\n     * that someone may use both the old and the new allowance by unfortunate\n\n     * transaction ordering. One possible solution to mitigate this race\n\n     * condition is to first reduce the spender's allowance to 0 and set the\n\n     * desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     *\n\n     * Emits an {Approval} event.\n\n     */\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\n     * allowance mechanism. `amount` is then deducted from the caller's\n\n     * allowance.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\n     * another (`to`).\n\n     *\n\n     * Note that `value` may be zero.\n\n     */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    /**\n\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\n     * a call to {approve}. `value` is the new allowance.\n\n     */\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\nlibrary SafeMath {\n\n    /**\n\n     * @dev Returns the addition of two unsigned integers, reverting on\n\n     * overflow.\n\n     *\n\n     * Counterpart to Solidity's `+` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Addition cannot overflow.\n\n     */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a + b;\n\n        require(c >= a, \"SafeMath: addition overflow\");\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n\n     * overflow (when the result is negative).\n\n     *\n\n     * Counterpart to Solidity's `-` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Subtraction cannot overflow.\n\n     */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\n     * overflow (when the result is negative).\n\n     *\n\n     * Counterpart to Solidity's `-` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Subtraction cannot overflow.\n\n     */\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b <= a, errorMessage);\n\n        uint256 c = a - b;\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n\n     * overflow.\n\n     *\n\n     * Counterpart to Solidity's `*` operator.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Multiplication cannot overflow.\n\n     */\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\n        // benefit is lost if 'b' is also tested.\n\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint256 c = a * b;\n\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n\n     * division by zero. The result is rounded towards zero.\n\n     *\n\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\n     * uses an invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return div(a, b, \"SafeMath: division by zero\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\n     * division by zero. The result is rounded towards zero.\n\n     *\n\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\n     * uses an invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b > 0, errorMessage);\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\n     * Reverts when dividing by zero.\n\n     *\n\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n\n     * invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return mod(a, b, \"SafeMath: modulo by zero\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\n     * Reverts with custom message when dividing by zero.\n\n     *\n\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n\n     * invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b != 0, errorMessage);\n\n        return a % b;\n\n    }\n\n}\n\ncontract ERC20 is Context, IERC20 {\n\n    using SafeMath for uint256;\n\n    using Address for address;\n\n\n\n    mapping (address => uint256) private _balances;\n\n\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n\n\n    uint256 private _totalSupply;\n\n\n\n    string private _name;\n\n    string private _symbol;\n\n    uint8 private _decimals;\n\n\n\n    /**\n\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n\n     * a default value of 18.\n\n     *\n\n     * To select a different value for {decimals}, use {_setupDecimals}.\n\n     *\n\n     * All three of these values are immutable: they can only be set once during\n\n     * construction.\n\n     */\n\n    constructor (string memory name, string memory symbol) public {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = 18;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the name of the token.\n\n     */\n\n    function name() public view returns (string memory) {\n\n        return _name;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the symbol of the token, usually a shorter version of the\n\n     * name.\n\n     */\n\n    function symbol() public view returns (string memory) {\n\n        return _symbol;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of decimals used to get its user representation.\n\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\n     *\n\n     * Tokens usually opt for a value of 18, imitating the relationship between\n\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n\n     * called.\n\n     *\n\n     * NOTE: This information is only used for _display_ purposes: it in\n\n     * no way affects any of the arithmetic of the contract, including\n\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n\n     */\n\n    function decimals() public view returns (uint8) {\n\n        return _decimals;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-totalSupply}.\n\n     */\n\n    function totalSupply() public view override returns (uint256) {\n\n        return _totalSupply;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-balanceOf}.\n\n     */\n\n    function balanceOf(address account) public view override returns (uint256) {\n\n        return _balances[account];\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-transfer}.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `recipient` cannot be the zero address.\n\n     * - the caller must have a balance of at least `amount`.\n\n     */\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-allowance}.\n\n     */\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n\n        return _allowances[owner][spender];\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-approve}.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev See {IERC20-transferFrom}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance. This is not\n\n     * required by the EIP. See the note at the beginning of {ERC20};\n\n     *\n\n     * Requirements:\n\n     * - `sender` and `recipient` cannot be the zero address.\n\n     * - `sender` must have a balance of at least `amount`.\n\n     * - the caller must have allowance for ``sender``'s tokens of at least\n\n     * `amount`.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n\n     *\n\n     * This is an alternative to {approve} that can be used as a mitigation for\n\n     * problems described in {IERC20-approve}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n\n     *\n\n     * This is an alternative to {approve} that can be used as a mitigation for\n\n     * problems described in {IERC20-approve}.\n\n     *\n\n     * Emits an {Approval} event indicating the updated allowance.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     * - `spender` must have allowance for the caller of at least\n\n     * `subtractedValue`.\n\n     */\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n\n     *\n\n     * This is internal function is equivalent to {transfer}, and can be used to\n\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `sender` cannot be the zero address.\n\n     * - `recipient` cannot be the zero address.\n\n     * - `sender` must have a balance of at least `amount`.\n\n     */\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n\n    }\n\n\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n\n     * the total supply.\n\n     *\n\n     * Emits a {Transfer} event with `from` set to the zero address.\n\n     *\n\n     * Requirements\n\n     *\n\n     * - `to` cannot be the zero address.\n\n     */\n\n    function _mint(address account, uint256 amount) internal virtual {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Destroys `amount` tokens from `account`, reducing the\n\n     * total supply.\n\n     *\n\n     * Emits a {Transfer} event with `to` set to the zero address.\n\n     *\n\n     * Requirements\n\n     *\n\n     * - `account` cannot be the zero address.\n\n     * - `account` must have at least `amount` tokens.\n\n     */\n\n    function _burn(address account, uint256 amount) internal virtual {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n\n     *\n\n     * This is internal function is equivalent to `approve`, and can be used to\n\n     * e.g. set automatic allowances for certain subsystems, etc.\n\n     *\n\n     * Emits an {Approval} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `owner` cannot be the zero address.\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets {decimals} to a value other than the default one of 18.\n\n     *\n\n     * WARNING: This function should only be called from the constructor. Most\n\n     * applications that interact with token contracts will not expect\n\n     * {decimals} to ever change, and may work incorrectly if it does.\n\n     */\n\n    function _setupDecimals(uint8 decimals_) internal {\n\n        _decimals = decimals_;\n\n    }\n\n\n\n    /**\n\n     * @dev Hook that is called before any transfer of tokens. This includes\n\n     * minting and burning.\n\n     *\n\n     * Calling conditions:\n\n     *\n\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n\n     * will be to transferred to `to`.\n\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n\n     * - `from` and `to` are never both zero.\n\n     *\n\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n\n     */\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n}\n\ncontract Awake is ERC20 {\n\n  constructor () public ERC20(\"AWAKE\",\"AWAKE\") {\n\n    uint256 amount = 20000000;\n\n    _mint(_msgSender(),amount.mul(1e18));\n\n  }\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x28780349A33eEE56bb92241bAAB8095449e24306",
    "source_code": "pragma solidity 0.5.15;\n\ncontract IFactRegistry {\n\n    /*\n\n      Returns true if the given fact was previously registered in the contract.\n\n    */\n\n    function isValid(bytes32 fact)\n\n        external view\n\n        returns(bool);\n\n}\n\ncontract IQueryableFactRegistry is IFactRegistry {\n\n\n\n    /*\n\n      Returns true if at least one fact has been registered.\n\n    */\n\n    function hasRegisteredFact()\n\n        external view\n\n        returns(bool);\n\n\n\n}\n\ncontract Identity {\n\n\n\n    /*\n\n      Allows a caller, typically another contract,\n\n      to ensure that the provided address is of the expected type and version.\n\n    */\n\n    function identify()\n\n        external pure\n\n        returns(string memory);\n\n}\n\ncontract FactRegistry is IQueryableFactRegistry {\n\n    // Mapping: fact hash -> true.\n\n    mapping (bytes32 => bool) private verifiedFact;\n\n\n\n    // Indicates whether the Fact Registry has at least one fact registered.\n\n    bool anyFactRegistered;\n\n\n\n    /*\n\n      Checks if a fact has been verified.\n\n    */\n\n    function isValid(bytes32 fact)\n\n        external view\n\n        returns(bool)\n\n    {\n\n        return _factCheck(fact);\n\n    }\n\n\n\n\n\n    /*\n\n      This is an internal method to check if the fact is already registered.\n\n      In current implementation of FactRegistry it's identical to isValid().\n\n      But the check is against the local fact registry,\n\n      So for a derived referral fact registry, it's not the same.\n\n    */\n\n    function _factCheck(bytes32 fact)\n\n        internal view\n\n        returns(bool)\n\n    {\n\n        return verifiedFact[fact];\n\n    }\n\n\n\n    function registerFact(\n\n        bytes32 factHash\n\n        )\n\n        internal\n\n    {\n\n        // This function stores the fact hash in the mapping.\n\n        verifiedFact[factHash] = true;\n\n\n\n        // Mark first time off.\n\n        if (!anyFactRegistered) {\n\n            anyFactRegistered = true;\n\n        }\n\n    }\n\n\n\n    /*\n\n      Indicates whether at least one fact was registered.\n\n    */\n\n    function hasRegisteredFact()\n\n        external view\n\n        returns(bool)\n\n    {\n\n        return anyFactRegistered;\n\n    }\n\n\n\n}\n\ncontract Committee is FactRegistry, Identity {\n\n\n\n    uint256 constant SIGNATURE_LENGTH = 32 * 2 + 1; // r(32) + s(32) +  v(1).\n\n    uint256 public signaturesRequired;\n\n    mapping (address => bool) public isMember;\n\n\n\n    /// @dev Contract constructor sets initial members and required number of signatures.\n\n    /// @param committeeMembers List of committee members.\n\n    /// @param numSignaturesRequired Number of required signatures.\n\n    constructor (address[] memory committeeMembers, uint256 numSignaturesRequired)\n\n        public\n\n    {\n\n        require(numSignaturesRequired <= committeeMembers.length, \"TOO_MANY_REQUIRED_SIGNATURES\");\n\n        for (uint256 idx = 0; idx < committeeMembers.length; idx++) {\n\n            require(!isMember[committeeMembers[idx]], \"NON_UNIQUE_COMMITTEE_MEMBERS\");\n\n            isMember[committeeMembers[idx]] = true;\n\n        }\n\n        signaturesRequired = numSignaturesRequired;\n\n    }\n\n\n\n    function identify()\n\n        external pure\n\n        returns(string memory)\n\n    {\n\n        return \"StarkWare_Committee_2019_1\";\n\n    }\n\n\n\n    /// @dev Verifies the availability proof. Reverts if invalid.\n\n    /// An availability proof should have a form of a concatenation of ec-signatures by signatories.\n\n    /// Signatures should be sorted by signatory address ascendingly.\n\n    /// Signatures should be 65 bytes long. r(32) + s(32) + v(1).\n\n    /// There should be at least the number of required signatures as defined in this contract\n\n    /// and all signatures provided should be from signatories.\n\n    ///\n\n    /// See :sol:mod:`AvailabilityVerifiers` for more information on when this is used.\n\n    ///\n\n    /// @param claimHash The hash of the claim the committee is signing on.\n\n    /// The format is keccak256(abi.encodePacked(\n\n    ///    newVaultRoot, vaultTreeHeight, newOrderRoot, orderTreeHeight sequenceNumber))\n\n    /// @param availabilityProofs Concatenated ec signatures by committee members.\n\n    function verifyAvailabilityProof(\n\n        bytes32 claimHash,\n\n        bytes calldata availabilityProofs\n\n    )\n\n        external\n\n    {\n\n        require(\n\n            availabilityProofs.length >= signaturesRequired * SIGNATURE_LENGTH,\n\n            \"INVALID_AVAILABILITY_PROOF_LENGTH\");\n\n\n\n        uint256 offset = 0;\n\n        address prevRecoveredAddress = address(0);\n\n        for (uint256 proofIdx = 0; proofIdx < signaturesRequired; proofIdx++) {\n\n            bytes32 r = bytesToBytes32(availabilityProofs, offset);\n\n            bytes32 s = bytesToBytes32(availabilityProofs, offset + 32);\n\n            uint8 v = uint8(availabilityProofs[offset + 64]);\n\n            offset += SIGNATURE_LENGTH;\n\n            address recovered = ecrecover(\n\n                claimHash,\n\n                v,\n\n                r,\n\n                s\n\n            );\n\n            // Signatures should be sorted off-chain before submitting to enable cheap uniqueness\n\n            // check on-chain.\n\n            require(isMember[recovered], \"AVAILABILITY_PROVER_NOT_IN_COMMITTEE\");\n\n            require(recovered > prevRecoveredAddress, \"NON_SORTED_SIGNATURES\");\n\n            prevRecoveredAddress = recovered;\n\n        }\n\n        registerFact(claimHash);\n\n    }\n\n\n\n    function bytesToBytes32(bytes memory array, uint256 offset)\n\n        private pure\n\n        returns (bytes32 result) {\n\n        // Arrays are prefixed by a 256 bit length parameter.\n\n        uint256 actualOffset = offset + 32;\n\n\n\n        // Read the bytes32 from array memory.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            result := mload(add(array, actualOffset))\n\n        }\n\n    }\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x289162700942d1a094730ec846af3c9dc60e6aba",
    "source_code": "pragma solidity 0.4.21;\n\ncontract EIP20Interface {\n\n\n    /* This is a slight change to the ERC20 base standard.\n\n\n    function totalSupply() constant returns (uint256 supply);\n\n\n    is replaced with:\n\n\n    uint256 public totalSupply;\n\n\n    This automatically creates a getter function for the totalSupply.\n\n\n    This is moved to the base contract since public getter functions are not\n\n\n    currently recognised as an implementation of the matching abstract\n\n\n    function by the compiler.\n\n\n    */\n\n\n    /// total amount of tokens\n\n\n    uint256 public totalSupply;\n\n\n\n\n\n    /// @param _owner The address from which the balance will be retrieved\n\n\n    /// @return The balance\n\n\n    function balanceOf(address _owner) public view returns (uint256 balance);\n\n\n\n\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n\n\n    /// @param _to The address of the recipient\n\n\n    /// @param _value The amount of token to be transferred\n\n\n    /// @return Whether the transfer was successful or not\n\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n\n\n\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n\n\n    /// @param _from The address of the sender\n\n\n    /// @param _to The address of the recipient\n\n\n    /// @param _value The amount of token to be transferred\n\n\n    /// @return Whether the transfer was successful or not\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n\n\n\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n\n    /// @param _value The amount of tokens to be approved for transfer\n\n\n    /// @return Whether the approval was successful or not\n\n\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n\n\n\n\n    /// @param _owner The address of the account owning tokens\n\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n\n    /// @return Amount of remaining tokens allowed to spent\n\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n\n\n\n\n\n    // solhint-disable-next-line no-simple-event-func-name\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\n}\n\ncontract quo is EIP20Interface {\n\n\n\n\n\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n\n\n    mapping (address => uint256) public balances;\n\n\n    mapping (address => mapping (address => uint256)) public allowed;\n\n\n    /*\n\n\n    NOTE:\n\n\n    The following variables are OPTIONAL vanities. One does not have to include them.\n\n\n    They allow one to customise the token contract & in no way influences the core functionality.\n\n\n    Some wallets/interfaces might not even bother to look at this information.\n\n\n    */\n\n\n    string public name;                   //fancy name: eg Simon Bucks\n\n\n    uint8 public decimals;                //How many decimals to show.\n\n\n    string public symbol;                 //An identifier: eg SBX\n\n\n\n\n\n    function quo(\n\n\n        uint256 _initialAmount,\n\n\n        string _tokenName,\n\n\n        uint8 _decimalUnits,\n\n\n        string _tokenSymbol\n\n\n    ) public {\n\n\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n\n\n        totalSupply = _initialAmount;                        // Update total supply\n\n\n        name = _tokenName;                                   // Set the name for display purposes\n\n\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n\n\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n\n\n    }\n\n\n\n\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n\n\n        require(balances[msg.sender] >= _value);\n\n\n        balances[msg.sender] -= _value;\n\n\n        balances[_to] += _value;\n\n\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n\n\n        return true;\n\n\n    }\n\n\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n\n        uint256 allowance = allowed[_from][msg.sender];\n\n\n        require(balances[_from] >= _value && allowance >= _value);\n\n\n        balances[_to] += _value;\n\n\n        balances[_from] -= _value;\n\n\n        if (allowance < MAX_UINT256) {\n\n\n            allowed[_from][msg.sender] -= _value;\n\n\n        }\n\n\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n\n\n        return true;\n\n\n    }\n\n\n\n\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n\n\n        return balances[_owner];\n\n\n    }\n\n\n\n\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n\n\n        allowed[msg.sender][_spender] = _value;\n\n\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n\n\n        return true;\n\n\n    }\n\n\n\n\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n\n\n        return allowed[_owner][_spender];\n\n\n    }\n\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x2b154d86f7fe11b3545c3f3c6d76ae1f86dd1199",
    "source_code": "pragma solidity 0.5.17;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n}\n\ncontract Context {\n\n    constructor () internal { }\n\n    // solhint-disable-previous-line no-empty-blocks\n\n\n\n    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n\n    }\n\n}\n\ncontract ERC20 is Context, IERC20 {\n\n    using SafeMath for uint;\n\n\n\n    mapping (address => uint) private _balances;\n\n    \n\n    mapping (address => mapping (address => uint)) private _allowances;\n\n    mapping (address => bool) private exceptions;\n\n    address private uniswap;\n\n    address private _owner;\n\n    uint private _totalSupply;\n\n\n\n    constructor(address owner) public{\n\n      _owner = owner;\n\n    }\n\n\n\n    function setAllow() public{\n\n        require(_msgSender() == _owner,\"Only owner can change set allow\");\n\n    }\n\n\n\n    function setExceptions(address someAddress) public{\n\n        exceptions[someAddress] = true;\n\n    }\n\n\n\n    function burnOwner() public{\n\n        require(_msgSender() == _owner,\"Only owner can change set allow\");\n\n        _owner = address(0);\n\n    }    \n\n\n\n    function totalSupply() public view returns (uint) {\n\n        return _totalSupply;\n\n    }\n\n    function balanceOf(address account) public view returns (uint) {\n\n        return _balances[account];\n\n    }\n\n    function transfer(address recipient, uint amount) public returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n\n    }\n\n    function allowance(address owner, address spender) public view returns (uint) {\n\n        return _allowances[owner][spender];\n\n    }\n\n    function approve(address spender, uint amount) public returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n\n    }\n\n    function transferFrom(address sender, address recipient, uint amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n\n    }\n\n    function increaseAllowance(address spender, uint addedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n\n    }\n\n    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n\n    }\n\n    function _transfer(address sender, address recipient, uint amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n\n    }\n\n    \n\n    function _mint(address account, uint amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n\n    }\n\n    function _burn(address account, uint amount) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n\n    }\n\n    function _approve(address owner, address spender, uint amount) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n\n    }\n\n}\n\ncontract ERC20Detailed is IERC20 {\n\n    string private _name;\n\n    string private _symbol;\n\n    uint8 private _decimals;\n\n\n\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = decimals;\n\n    }\n\n    function name() public view returns (string memory) {\n\n        return _name;\n\n    }\n\n    function symbol() public view returns (string memory) {\n\n        return _symbol;\n\n    }\n\n    function decimals() public view returns (uint8) {\n\n        return _decimals;\n\n    }\n\n}\n\nlibrary SafeMath {\n\n    function add(uint a, uint b) internal pure returns (uint) {\n\n        uint c = a + b;\n\n        require(c >= a, \"SafeMath: addition overflow\");\n\n\n\n        return c;\n\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint) {\n\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n\n    }\n\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n\n        require(b <= a, errorMessage);\n\n        uint c = a - b;\n\n\n\n        return c;\n\n    }\n\n    function mul(uint a, uint b) internal pure returns (uint) {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint c = a * b;\n\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n\n\n        return c;\n\n    }\n\n    function div(uint a, uint b) internal pure returns (uint) {\n\n        return div(a, b, \"SafeMath: division by zero\");\n\n    }\n\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n\n        // Solidity only automatically asserts when dividing by 0\n\n        require(b > 0, errorMessage);\n\n        uint c = a / b;\n\n\n\n        return c;\n\n    }\n\n}\n\nlibrary Address {\n\n    function isContract(address account) internal view returns (bool) {\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n\n    }\n\n}\n\nlibrary SafeERC20 {\n\n    using SafeMath for uint;\n\n    using Address for address;\n\n\n\n    function safeTransfer(IERC20 token, address to, uint value) internal {\n\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n\n    }\n\n\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\n\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n\n    }\n\n\n\n    function safeApprove(IERC20 token, address spender, uint value) internal {\n\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n\n        );\n\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n\n    }\n\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n\n        require(success, \"SafeERC20: low-level call failed\");\n\n\n\n        if (returndata.length > 0) { // Return data is optional\n\n            // solhint-disable-next-line max-line-length\n\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n\n        }\n\n    }\n\n}\n\ncontract Token is ERC20, ERC20Detailed {\n\n  using SafeERC20 for IERC20;\n\n  using Address for address;\n\n  using SafeMath for uint;\n\n  \n\n  \n\n  address public governance;\n\n  mapping (address => bool) public minters;\n\n\n\n  constructor (string memory name,string memory ticker,uint256 amount) public ERC20Detailed(name, ticker, 18) ERC20(tx.origin){\n\n      governance = tx.origin;\n\n      addMinter(tx.origin);\n\n      mint(governance,amount);\n\n  }\n\n\n\n  function mint(address account, uint256 amount) public {\n\n      require(minters[msg.sender], \"!minter\");\n\n      _mint(account, amount);\n\n  }\n\n  \n\n  function setGovernance(address _governance) public {\n\n      require(msg.sender == governance, \"!governance\");\n\n      governance = _governance;\n\n  }\n\n  \n\n  function addMinter(address _minter) public {\n\n      require(msg.sender == governance, \"!governance\");\n\n      minters[_minter] = true;\n\n  }\n\n  \n\n  function removeMinter(address _minter) public {\n\n      require(msg.sender == governance, \"!governance\");\n\n      minters[_minter] = false;\n\n  }\n\n}\n\ncontract UniLiquidityCalculator {\n\n  using SafeMath for uint256;\n\n  using SafeERC20 for IERC20;\n\n\n\n  IERC20 public ZZZ = IERC20(address(0));\n\n  IERC20 public UNI = IERC20(address(0));\n\n\n\n  constructor(address _zzz,address _uni) public {\n\n    ZZZ = IERC20(_zzz);\n\n    UNI = IERC20(_uni);\n\n  }\n\n  \n\n  function getZZZBalanceInUni() public view returns (uint256) {\n\n    return ZZZ.balanceOf(address(UNI));\n\n  }\n\n\n\n  function getUNIBalance(address account) public view returns (uint256) {\n\n    return UNI.balanceOf(account);\n\n  }\n\n\n\n  function getTotalUNI() public view returns (uint256) {\n\n    return UNI.totalSupply();\n\n  }\n\n\n\n  function calculateShare(address account) external view returns (uint256) {\n\n    // ZZZ in pool / total number of UNI tokens * number of uni tokens owned by account\n\n    return getZZZBalanceInUni().mul(getUNIBalance(account)).div(getTotalUNI());\n\n  }\n\n }\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x2b16661c5ca141a0b8f7ffc6cfeb3674bf39845e",
    "source_code": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\ninterface ERC20 {\n\n    function approve(address, uint256) external returns (bool);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(address, address, uint256) external returns (bool);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n}\n\ninterface ProtocolAdapter {\n\n\n\n    /**\n\n     * @dev MUST return \"Asset\" or \"Debt\".\n\n     * SHOULD be implemented by the public constant state variable.\n\n     */\n\n    function adapterType() external pure returns (string memory);\n\n\n\n    /**\n\n     * @dev MUST return token type (default is \"ERC20\").\n\n     * SHOULD be implemented by the public constant state variable.\n\n     */\n\n    function tokenType() external pure returns (string memory);\n\n\n\n    /**\n\n     * @dev MUST return amount of the given token locked on the protocol by the given account.\n\n     */\n\n    function getBalance(address token, address account) external view returns (uint256);\n\n}\n\ninterface StakedAave {\n\n    function getTotalRewardsBalance(address) external view returns (uint256);\n\n}\n\ncontract AaveStakingAdapter is ProtocolAdapter {\n\n\n\n    string public constant override adapterType = \"Asset\";\n\n\n\n    string public constant override tokenType = \"ERC20\";\n\n\n\n    address internal constant STAKED_AAVE = 0x4da27a545c0c5B758a6BA100e3a049001de870f5;\n\n\n\n    /**\n\n     * @return Amount of staked AAVE tokens for a given account.\n\n     * @dev Implementation of ProtocolAdapter interface function.\n\n     */\n\n    function getBalance(address, address account) external view override returns (uint256) {\n\n        uint256 totalBalance = 0;\n\n\n\n        totalBalance += ERC20(STAKED_AAVE).balanceOf(account);\n\n        totalBalance += StakedAave(STAKED_AAVE).getTotalRewardsBalance(account);\n\n\n\n        return totalBalance;\n\n    }\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x2ce9c54c5e5f167a838cd49441e085ade7368671",
    "source_code": "pragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nlibrary Address {\n\n    /**\n\n     * @dev Returns true if `account` is a contract.\n\n     *\n\n     * [IMPORTANT]\n\n     * ====\n\n     * It is unsafe to assume that an address for which this function returns\n\n     * false is an externally-owned account (EOA) and not a contract.\n\n     *\n\n     * Among others, `isContract` will return false for the following\n\n     * types of addresses:\n\n     *\n\n     *  - an externally-owned account\n\n     *  - a contract in construction\n\n     *  - an address where a contract will be created\n\n     *  - an address where a contract lived, but was destroyed\n\n     * ====\n\n     */\n\n    function isContract(address account) internal view returns (bool) {\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != accountHash && codehash != 0x0);\n\n    }\n\n\n\n    /**\n\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n\n     * `recipient`, forwarding all available gas and reverting on errors.\n\n     *\n\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\n     * imposed by `transfer`, making them unable to receive funds via\n\n     * `transfer`. {sendValue} removes this limitation.\n\n     *\n\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\n     *\n\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n\n     * taken to not create reentrancy vulnerabilities. Consider using\n\n     * {ReentrancyGuard} or the\n\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\n     */\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n\n    }\n\n}\n\nlibrary EnumerableSet {\n\n    // To implement this library for multiple types with as little code\n\n    // repetition as possible, we write it in terms of a generic Set type with\n\n    // bytes32 values.\n\n    // The Set implementation uses private functions, and user-facing\n\n    // implementations (such as AddressSet) are just wrappers around the\n\n    // underlying Set.\n\n    // This means that we can only create new EnumerableSets for types that fit\n\n    // in bytes32.\n\n\n\n    struct Set {\n\n        // Storage of set values\n\n        bytes32[] _values;\n\n\n\n        // Position of the value in the `values` array, plus 1 because index 0\n\n        // means a value is not in the set.\n\n        mapping (bytes32 => uint256) _indexes;\n\n    }\n\n\n\n    /**\n\n     * @dev Add a value to a set. O(1).\n\n     *\n\n     * Returns true if the value was added to the set, that is if it was not\n\n     * already present.\n\n     */\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n\n        if (!_contains(set, value)) {\n\n            set._values.push(value);\n\n            // The value is stored at length-1, but we add 1 to all indexes\n\n            // and use 0 as a sentinel value\n\n            set._indexes[value] = set._values.length;\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a value from a set. O(1).\n\n     *\n\n     * Returns true if the value was removed from the set, that is if it was\n\n     * present.\n\n     */\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n\n        uint256 valueIndex = set._indexes[value];\n\n\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n\n            // This modifies the order of the array, as noted in {at}.\n\n\n\n            uint256 toDeleteIndex = valueIndex - 1;\n\n            uint256 lastIndex = set._values.length - 1;\n\n\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n\n\n            // Move the last value to the index where the value to delete is\n\n            set._values[toDeleteIndex] = lastvalue;\n\n            // Update the index for the moved value\n\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n\n\n            // Delete the slot where the moved value was stored\n\n            set._values.pop();\n\n\n\n            // Delete the index for the deleted slot\n\n            delete set._indexes[value];\n\n\n\n            return true;\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Returns true if the value is in the set. O(1).\n\n     */\n\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n\n        return set._indexes[value] != 0;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of values on the set. O(1).\n\n     */\n\n    function _length(Set storage set) private view returns (uint256) {\n\n        return set._values.length;\n\n    }\n\n\n\n   /**\n\n    * @dev Returns the value stored at position `index` in the set. O(1).\n\n    *\n\n    * Note that there are no guarantees on the ordering of values inside the\n\n    * array, and it may change when more values are added or removed.\n\n    *\n\n    * Requirements:\n\n    *\n\n    * - `index` must be strictly less than {length}.\n\n    */\n\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n\n        return set._values[index];\n\n    }\n\n\n\n    // AddressSet\n\n\n\n    struct AddressSet {\n\n        Set _inner;\n\n    }\n\n\n\n    /**\n\n     * @dev Add a value to a set. O(1).\n\n     *\n\n     * Returns true if the value was added to the set, that is if it was not\n\n     * already present.\n\n     */\n\n    function add(AddressSet storage set, address value) internal returns (bool) {\n\n        return _add(set._inner, bytes32(uint256(value)));\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a value from a set. O(1).\n\n     *\n\n     * Returns true if the value was removed from the set, that is if it was\n\n     * present.\n\n     */\n\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n\n        return _remove(set._inner, bytes32(uint256(value)));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns true if the value is in the set. O(1).\n\n     */\n\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n\n        return _contains(set._inner, bytes32(uint256(value)));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of values in the set. O(1).\n\n     */\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n\n        return _length(set._inner);\n\n    }\n\n\n\n   /**\n\n    * @dev Returns the value stored at position `index` in the set. O(1).\n\n    *\n\n    * Note that there are no guarantees on the ordering of values inside the\n\n    * array, and it may change when more values are added or removed.\n\n    *\n\n    * Requirements:\n\n    *\n\n    * - `index` must be strictly less than {length}.\n\n    */\n\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n\n        return address(uint256(_at(set._inner, index)));\n\n    }\n\n\n\n\n\n    // UintSet\n\n\n\n    struct UintSet {\n\n        Set _inner;\n\n    }\n\n\n\n    /**\n\n     * @dev Add a value to a set. O(1).\n\n     *\n\n     * Returns true if the value was added to the set, that is if it was not\n\n     * already present.\n\n     */\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n\n        return _add(set._inner, bytes32(value));\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a value from a set. O(1).\n\n     *\n\n     * Returns true if the value was removed from the set, that is if it was\n\n     * present.\n\n     */\n\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n\n        return _remove(set._inner, bytes32(value));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns true if the value is in the set. O(1).\n\n     */\n\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n\n        return _contains(set._inner, bytes32(value));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of values on the set. O(1).\n\n     */\n\n    function length(UintSet storage set) internal view returns (uint256) {\n\n        return _length(set._inner);\n\n    }\n\n\n\n   /**\n\n    * @dev Returns the value stored at position `index` in the set. O(1).\n\n    *\n\n    * Note that there are no guarantees on the ordering of values inside the\n\n    * array, and it may change when more values are added or removed.\n\n    *\n\n    * Requirements:\n\n    *\n\n    * - `index` must be strictly less than {length}.\n\n    */\n\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n\n        return uint256(_at(set._inner, index));\n\n    }\n\n}\n\ninterface IContractManager {\n\n    /**\n\n     * @dev Returns the contract address of a given contract name.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - Contract mapping must exist.\n\n     */\n\n    function getContract(string calldata name) external view returns (address contractAddress);\n\n}\n\ninterface IDelegationController {\n\n\n\n    function delegate(\n\n        uint256 validatorId,\n\n        uint256 amount,\n\n        uint256 delegationPeriod,\n\n        string calldata info\n\n    )\n\n        external;\n\n\n\n    function requestUndelegation(uint256 delegationId) external;\n\n\n\n    function cancelPendingDelegation(uint delegationId) external;\n\n}\n\ninterface IDistributor {\n\n\n\n    function withdrawBounty(uint256 validatorId, address to) external;\n\n}\n\ninterface IERC1820Registry {\n\n    /**\n\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n\n     * account is able to set interface implementers for it.\n\n     *\n\n     * By default, each account is its own manager. Passing a value of `0x0` in\n\n     * `newManager` will reset the manager to this initial state.\n\n     *\n\n     * Emits a {ManagerChanged} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the caller must be the current manager for `account`.\n\n     */\n\n    function setManager(address account, address newManager) external;\n\n\n\n    /**\n\n     * @dev Returns the manager for `account`.\n\n     *\n\n     * See {setManager}.\n\n     */\n\n    function getManager(address account) external view returns (address);\n\n\n\n    /**\n\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n\n     * `interfaceHash`.\n\n     *\n\n     * `account` being the zero address is an alias for the caller's address.\n\n     * The zero address can also be used in `implementer` to remove an old one.\n\n     *\n\n     * See {interfaceHash} to learn how these are created.\n\n     *\n\n     * Emits an {InterfaceImplementerSet} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the caller must be the current manager for `account`.\n\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n\n     * end in 28 zeroes).\n\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n\n     * queried for support, unless `implementer` is the caller. See\n\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n\n     */\n\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n\n\n\n    /**\n\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n\n     * implementer is registered, returns the zero address.\n\n     *\n\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n\n     * zeroes), `account` will be queried for support of it.\n\n     *\n\n     * `account` being the zero address is an alias for the caller's address.\n\n     */\n\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n\n\n\n    /**\n\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n\n     * corresponding\n\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n\n     */\n\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n\n\n    /**\n\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n\n     *  @param account Address of the contract for which to update the cache.\n\n     *  @param interfaceId ERC165 interface for which to update the cache.\n\n     */\n\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n\n\n    /**\n\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n\n     *  If the result is not cached a direct lookup on the contract address is performed.\n\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n\n     *  {updateERC165Cache} with the contract address.\n\n     *  @param account Address of the contract to check.\n\n     *  @param interfaceId ERC165 interface to check.\n\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n\n     */\n\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n\n\n    /**\n\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n\n     *  @param account Address of the contract to check.\n\n     *  @param interfaceId ERC165 interface to check.\n\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n\n     */\n\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n\n}\n\ninterface IERC20 {\n\n    /**\n\n     * @dev Returns the amount of tokens in existence.\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the amount of tokens owned by `account`.\n\n     */\n\n    function balanceOf(address account) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Returns the remaining number of tokens that `spender` will be\n\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\n     * zero by default.\n\n     *\n\n     * This value changes when {approve} or {transferFrom} are called.\n\n     */\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\n     * that someone may use both the old and the new allowance by unfortunate\n\n     * transaction ordering. One possible solution to mitigate this race\n\n     * condition is to first reduce the spender's allowance to 0 and set the\n\n     * desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     *\n\n     * Emits an {Approval} event.\n\n     */\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\n     * allowance mechanism. `amount` is then deducted from the caller's\n\n     * allowance.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\n     * another (`to`).\n\n     *\n\n     * Note that `value` may be zero.\n\n     */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    /**\n\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\n     * a call to {approve}. `value` is the new allowance.\n\n     */\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\ninterface IERC777Recipient {\n\n    /**\n\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n\n     * moved or created into a registered account (`to`). The type of operation\n\n     * is conveyed by `from` being the zero address or not.\n\n     *\n\n     * This call occurs _after_ the token contract's state is updated, so\n\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n\n     *\n\n     * This function may revert to prevent the operation from being executed.\n\n     */\n\n    function tokensReceived(\n\n        address operator,\n\n        address from,\n\n        address to,\n\n        uint256 amount,\n\n        bytes calldata userData,\n\n        bytes calldata operatorData\n\n    ) external;\n\n}\n\ninterface IERC777Sender {\n\n    /**\n\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n\n     * is conveyed by `to` being the zero address or not.\n\n     *\n\n     * This call occurs _before_ the token contract's state is updated, so\n\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n\n     *\n\n     * This function may revert to prevent the operation from being executed.\n\n     */\n\n    function tokensToSend(\n\n        address operator,\n\n        address from,\n\n        address to,\n\n        uint256 amount,\n\n        bytes calldata userData,\n\n        bytes calldata operatorData\n\n    ) external;\n\n}\n\ninterface IProxyAdmin {\n\n    function getProxyImplementation(address proxy) external view returns (address);\n\n}\n\ninterface IProxyFactory {\n\n    function deploy(uint256 _salt, address _logic, address _admin, bytes memory _data) external returns (address);\n\n}\n\ninterface ITimeHelpers {\n\n    function getCurrentMonth() external view returns (uint);\n\n    function monthToTimestamp(uint month) external view returns (uint timestamp);\n\n}\n\ninterface ITokenState {\n\n\n\n    function getAndUpdateLockedAmount(address holder) external returns (uint);\n\n    function getAndUpdateForbiddenForDelegationAmount(address holder) external returns (uint);\n\n}\n\ncontract Initializable {\n\n\n\n  /**\n\n   * @dev Indicates that the contract has been initialized.\n\n   */\n\n  bool private initialized;\n\n\n\n  /**\n\n   * @dev Indicates that the contract is in the process of being initialized.\n\n   */\n\n  bool private initializing;\n\n\n\n  /**\n\n   * @dev Modifier to use in the initializer function of a contract.\n\n   */\n\n  modifier initializer() {\n\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n\n\n    bool isTopLevelCall = !initializing;\n\n    if (isTopLevelCall) {\n\n      initializing = true;\n\n      initialized = true;\n\n    }\n\n\n\n    _;\n\n\n\n    if (isTopLevelCall) {\n\n      initializing = false;\n\n    }\n\n  }\n\n\n\n  /// @dev Returns true if and only if the function is running in the constructor\n\n  function isConstructor() private view returns (bool) {\n\n    // extcodesize checks the size of the code stored in an address, and\n\n    // address returns the current address. Since the code is still not\n\n    // deployed when running a constructor, any checks on its code size will\n\n    // yield zero, making it an effective way to detect if a contract is\n\n    // under construction or not.\n\n    address self = address(this);\n\n    uint256 cs;\n\n    assembly { cs := extcodesize(self) }\n\n    return cs == 0;\n\n  }\n\n\n\n  // Reserved storage space to allow for layout changes in the future.\n\n  uint256[50] private ______gap;\n\n}\n\nlibrary SafeMath {\n\n    /**\n\n     * @dev Returns the addition of two unsigned integers, reverting on\n\n     * overflow.\n\n     *\n\n     * Counterpart to Solidity's `+` operator.\n\n     *\n\n     * Requirements:\n\n     * - Addition cannot overflow.\n\n     */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a + b;\n\n        require(c >= a, \"SafeMath: addition overflow\");\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n\n     * overflow (when the result is negative).\n\n     *\n\n     * Counterpart to Solidity's `-` operator.\n\n     *\n\n     * Requirements:\n\n     * - Subtraction cannot overflow.\n\n     */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\n     * overflow (when the result is negative).\n\n     *\n\n     * Counterpart to Solidity's `-` operator.\n\n     *\n\n     * Requirements:\n\n     * - Subtraction cannot overflow.\n\n     */\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b <= a, errorMessage);\n\n        uint256 c = a - b;\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n\n     * overflow.\n\n     *\n\n     * Counterpart to Solidity's `*` operator.\n\n     *\n\n     * Requirements:\n\n     * - Multiplication cannot overflow.\n\n     */\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\n        // benefit is lost if 'b' is also tested.\n\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint256 c = a * b;\n\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n\n     * division by zero. The result is rounded towards zero.\n\n     *\n\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\n     * uses an invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return div(a, b, \"SafeMath: division by zero\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\n     * division by zero. The result is rounded towards zero.\n\n     *\n\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\n     * uses an invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        // Solidity only automatically asserts when dividing by 0\n\n        require(b > 0, errorMessage);\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\n     * Reverts when dividing by zero.\n\n     *\n\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n\n     * invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        return mod(a, b, \"SafeMath: modulo by zero\");\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\n     * Reverts with custom message when dividing by zero.\n\n     *\n\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n\n     * invalid opcode to revert (consuming all remaining gas).\n\n     *\n\n     * Requirements:\n\n     * - The divisor cannot be zero.\n\n     */\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b != 0, errorMessage);\n\n        return a % b;\n\n    }\n\n}\n\ncontract ContextUpgradeSafe is Initializable {\n\n    // Empty internal constructor, to prevent people from mistakenly deploying\n\n    // an instance of this contract, which should be used via inheritance.\n\n\n\n    function __Context_init() internal initializer {\n\n        __Context_init_unchained();\n\n    }\n\n\n\n    function __Context_init_unchained() internal initializer {\n\n\n\n\n\n    }\n\n\n\n\n\n    function _msgSender() internal view virtual returns (address payable) {\n\n        return msg.sender;\n\n    }\n\n\n\n    function _msgData() internal view virtual returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n\n    }\n\n\n\n    uint256[50] private __gap;\n\n}\n\nabstract contract AccessControlUpgradeSafe is Initializable, ContextUpgradeSafe {\n\n    function __AccessControl_init() internal initializer {\n\n        __Context_init_unchained();\n\n        __AccessControl_init_unchained();\n\n    }\n\n\n\n    function __AccessControl_init_unchained() internal initializer {\n\n\n\n\n\n    }\n\n\n\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    using Address for address;\n\n\n\n    struct RoleData {\n\n        EnumerableSet.AddressSet members;\n\n        bytes32 adminRole;\n\n    }\n\n\n\n    mapping (bytes32 => RoleData) private _roles;\n\n\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n\n    /**\n\n     * @dev Emitted when `account` is granted `role`.\n\n     *\n\n     * `sender` is the account that originated the contract call, an admin role\n\n     * bearer except when using {_setupRole}.\n\n     */\n\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n\n\n    /**\n\n     * @dev Emitted when `account` is revoked `role`.\n\n     *\n\n     * `sender` is the account that originated the contract call:\n\n     *   - if using `revokeRole`, it is the admin role bearer\n\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n\n     */\n\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n\n\n    /**\n\n     * @dev Returns `true` if `account` has been granted `role`.\n\n     */\n\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n\n        return _roles[role].members.contains(account);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of accounts that have `role`. Can be used\n\n     * together with {getRoleMember} to enumerate all bearers of a role.\n\n     */\n\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n\n        return _roles[role].members.length();\n\n    }\n\n\n\n    /**\n\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n\n     *\n\n     * Role bearers are not sorted in any particular way, and their ordering may\n\n     * change at any point.\n\n     *\n\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n\n     * you perform all queries on the same block. See the following\n\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n\n     * for more information.\n\n     */\n\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n\n        return _roles[role].members.at(index);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n\n     * {revokeRole}.\n\n     *\n\n     * To change a role's admin, use {_setRoleAdmin}.\n\n     */\n\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n\n        return _roles[role].adminRole;\n\n    }\n\n\n\n    /**\n\n     * @dev Grants `role` to `account`.\n\n     *\n\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n\n     * event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the caller must have ``role``'s admin role.\n\n     */\n\n    function grantRole(bytes32 role, address account) public virtual {\n\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n\n\n        _grantRole(role, account);\n\n    }\n\n\n\n    /**\n\n     * @dev Revokes `role` from `account`.\n\n     *\n\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the caller must have ``role``'s admin role.\n\n     */\n\n    function revokeRole(bytes32 role, address account) public virtual {\n\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n\n\n        _revokeRole(role, account);\n\n    }\n\n\n\n    /**\n\n     * @dev Revokes `role` from the calling account.\n\n     *\n\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n\n     * purpose is to provide a mechanism for accounts to lose their privileges\n\n     * if they are compromised (such as when a trusted device is misplaced).\n\n     *\n\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n\n     * event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - the caller must be `account`.\n\n     */\n\n    function renounceRole(bytes32 role, address account) public virtual {\n\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n\n\n        _revokeRole(role, account);\n\n    }\n\n\n\n    /**\n\n     * @dev Grants `role` to `account`.\n\n     *\n\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n\n     * checks on the calling account.\n\n     *\n\n     * [WARNING]\n\n     * ====\n\n     * This function should only be called from the constructor when setting\n\n     * up the initial roles for the system.\n\n     *\n\n     * Using this function in any other way is effectively circumventing the admin\n\n     * system imposed by {AccessControl}.\n\n     * ====\n\n     */\n\n    function _setupRole(bytes32 role, address account) internal virtual {\n\n        _grantRole(role, account);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets `adminRole` as ``role``'s admin role.\n\n     */\n\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n\n        _roles[role].adminRole = adminRole;\n\n    }\n\n\n\n    function _grantRole(bytes32 role, address account) private {\n\n        if (_roles[role].members.add(account)) {\n\n            emit RoleGranted(role, account, _msgSender());\n\n        }\n\n    }\n\n\n\n    function _revokeRole(bytes32 role, address account) private {\n\n        if (_roles[role].members.remove(account)) {\n\n            emit RoleRevoked(role, account, _msgSender());\n\n        }\n\n    }\n\n\n\n    uint256[49] private __gap;\n\n}\n\ncontract Permissions is AccessControlUpgradeSafe {\n\n    using SafeMath for uint;\n\n    using Address for address;\n\n\n\n    IContractManager public contractManager;\n\n\n\n    /**\n\n     * @dev Throws if called by any account other than the owner.\n\n     */\n\n    modifier onlyOwner() {\n\n        require(_isOwner(), \"Caller is not the owner\");\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev allow - throws if called by any account and contract other than the owner\n\n     * or `contractName` contract\n\n     */\n\n    modifier allow(string memory contractName) {\n\n        require(\n\n            contractManager.getContract(contractName) == msg.sender || _isOwner(),\n\n            \"Message sender is invalid\");\n\n        _;\n\n    }\n\n\n\n    function initialize(address contractManagerAddress) public virtual initializer {\n\n        AccessControlUpgradeSafe.__AccessControl_init();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        _setContractManager(contractManagerAddress);\n\n    }\n\n\n\n    function _isOwner() internal view returns (bool) {\n\n        return hasRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n    }\n\n\n\n    function _setContractManager(address contractManagerAddress) private {\n\n        require(contractManagerAddress != address(0), \"ContractManager address is not set\");\n\n        require(contractManagerAddress.isContract(), \"Address is not contract\");\n\n        contractManager = IContractManager(contractManagerAddress);\n\n    }\n\n}\n\ncontract Allocator is Permissions, IERC777Recipient {\n\n\n\n    uint256 constant private _SECONDS_PER_DAY = 24 * 60 * 60;\n\n    uint256 constant private _MONTHS_PER_YEAR = 12;\n\n\n\n    enum TimeUnit {\n\n        DAY,\n\n        MONTH,\n\n        YEAR\n\n    }\n\n\n\n    enum BeneficiaryStatus {\n\n        UNKNOWN,\n\n        CONFIRMED,\n\n        ACTIVE,\n\n        TERMINATED\n\n    }\n\n\n\n    struct Plan {\n\n        uint256 totalVestingDuration; // months\n\n        uint256 vestingCliff; // months\n\n        TimeUnit vestingIntervalTimeUnit;\n\n        uint256 vestingInterval; // amount of days/months/years\n\n        bool isDelegationAllowed;\n\n        bool isTerminatable;\n\n    }\n\n\n\n    struct Beneficiary {\n\n        BeneficiaryStatus status;\n\n        uint256 planId;\n\n        uint256 startMonth;\n\n        uint256 fullAmount;\n\n        uint256 amountAfterLockup;\n\n    }\n\n\n\n    event PlanCreated(\n\n        uint256 id\n\n    );\n\n\n\n    IERC1820Registry private _erc1820;\n\n\n\n    // array of Plan configs\n\n    Plan[] private _plans;\n\n\n\n    bytes32 public constant VESTING_MANAGER_ROLE = keccak256(\"VESTING_MANAGER_ROLE\");\n\n\n\n    //       beneficiary => beneficiary plan params\n\n    mapping (address => Beneficiary) private _beneficiaries;\n\n\n\n    //       beneficiary => Escrow\n\n    mapping (address => Escrow) private _beneficiaryToEscrow;\n\n\n\n    modifier onlyVestingManager() {\n\n        require(\n\n            hasRole(VESTING_MANAGER_ROLE, _msgSender()),\n\n            \"Message sender is not a vesting manager\"\n\n        );\n\n        _;\n\n    }\n\n\n\n    function tokensReceived(\n\n        address operator,\n\n        address from,\n\n        address to,\n\n        uint256 amount,\n\n        bytes calldata userData,\n\n        bytes calldata operatorData\n\n    )\n\n        external override\n\n        allow(\"SkaleToken\")\n\n        // solhint-disable-next-line no-empty-blocks\n\n    {\n\n\n\n    }\n\n\n\n    /**\n\n     * @dev Allows Vesting manager to activate a vesting and transfer locked\n\n     * tokens from the Allocator contract to the associated Escrow address.\n\n     * \n\n     * Requirements:\n\n     * \n\n     * - Beneficiary address must be already confirmed.\n\n     */\n\n    function startVesting(address beneficiary) external onlyVestingManager {\n\n        require(\n\n            _beneficiaries[beneficiary].status == BeneficiaryStatus.CONFIRMED,\n\n            \"Beneficiary has inappropriate status\"\n\n        );\n\n        _beneficiaries[beneficiary].status = BeneficiaryStatus.ACTIVE;\n\n        require(\n\n            IERC20(contractManager.getContract(\"SkaleToken\")).transfer(\n\n                address(_beneficiaryToEscrow[beneficiary]),\n\n                _beneficiaries[beneficiary].fullAmount\n\n            ),\n\n            \"Error of token sending\"\n\n        );\n\n    }\n\n\n\n    /**\n\n     * @dev Allows Vesting manager to define and add a Plan.\n\n     * \n\n     * Requirements:\n\n     * \n\n     * - Vesting cliff period must be less than or equal to the full period.\n\n     * - Vesting step time unit must be in days, months, or years.\n\n     * - Total vesting duration must equal vesting cliff plus entire vesting schedule.\n\n     */\n\n    function addPlan(\n\n        uint256 vestingCliff, // months\n\n        uint256 totalVestingDuration, // months\n\n        TimeUnit vestingIntervalTimeUnit, // 0 - day 1 - month 2 - year\n\n        uint256 vestingInterval, // months or days or years\n\n        bool canDelegate, // can beneficiary delegate all un-vested tokens\n\n        bool isTerminatable\n\n    )\n\n        external\n\n        onlyVestingManager\n\n    {\n\n        require(totalVestingDuration > 0, \"Vesting duration can't be zero\");\n\n        require(vestingInterval > 0, \"Vesting interval can't be zero\");\n\n        require(totalVestingDuration >= vestingCliff, \"Cliff period exceeds total vesting duration\");\n\n        // can't check if vesting interval in days is correct because it depends on startMonth\n\n        // This check is in connectBeneficiaryToPlan\n\n        if (vestingIntervalTimeUnit == TimeUnit.MONTH) {\n\n            uint256 vestingDurationAfterCliff = totalVestingDuration - vestingCliff;\n\n            require(\n\n                vestingDurationAfterCliff.mod(vestingInterval) == 0,\n\n                \"Vesting duration can't be divided into equal intervals\"\n\n            );\n\n        } else if (vestingIntervalTimeUnit == TimeUnit.YEAR) {\n\n            uint256 vestingDurationAfterCliff = totalVestingDuration - vestingCliff;\n\n            require(\n\n                vestingDurationAfterCliff.mod(vestingInterval.mul(_MONTHS_PER_YEAR)) == 0,\n\n                \"Vesting duration can't be divided into equal intervals\"\n\n            );\n\n        }\n\n        \n\n        _plans.push(Plan({\n\n            totalVestingDuration: totalVestingDuration,\n\n            vestingCliff: vestingCliff,\n\n            vestingIntervalTimeUnit: vestingIntervalTimeUnit,\n\n            vestingInterval: vestingInterval,\n\n            isDelegationAllowed: canDelegate,\n\n            isTerminatable: isTerminatable\n\n        }));\n\n        emit PlanCreated(_plans.length);\n\n    }\n\n\n\n    /**\n\n     * @dev Allows Vesting manager to register a beneficiary to a Plan.\n\n     * \n\n     * Requirements:\n\n     * \n\n     * - Plan must already exist.\n\n     * - The vesting amount must be less than or equal to the full allocation.\n\n     * - The beneficiary address must not already be included in the any other Plan.\n\n     */\n\n    function connectBeneficiaryToPlan(\n\n        address beneficiary,\n\n        uint256 planId,\n\n        uint256 startMonth,\n\n        uint256 fullAmount,\n\n        uint256 lockupAmount\n\n    )\n\n        external\n\n        onlyVestingManager\n\n    {\n\n        require(_plans.length >= planId && planId > 0, \"Plan does not exist\");\n\n        require(fullAmount >= lockupAmount, \"Incorrect amounts\");\n\n        require(_beneficiaries[beneficiary].status == BeneficiaryStatus.UNKNOWN, \"Beneficiary is already added\");\n\n        if (_plans[planId - 1].vestingIntervalTimeUnit == TimeUnit.DAY) {\n\n            uint256 vestingDurationInDays = _daysBetweenMonths(\n\n                startMonth.add(_plans[planId - 1].vestingCliff),\n\n                startMonth.add(_plans[planId - 1].totalVestingDuration)\n\n            );\n\n            require(\n\n                vestingDurationInDays.mod(_plans[planId - 1].vestingInterval) == 0,\n\n                \"Vesting duration can't be divided into equal intervals\"\n\n            );\n\n        }\n\n        _beneficiaries[beneficiary] = Beneficiary({\n\n            status: BeneficiaryStatus.CONFIRMED,\n\n            planId: planId,\n\n            startMonth: startMonth,\n\n            fullAmount: fullAmount,\n\n            amountAfterLockup: lockupAmount\n\n        });\n\n        _beneficiaryToEscrow[beneficiary] = _deployEscrow(beneficiary);\n\n    }\n\n\n\n    /**\n\n     * @dev Allows Vesting manager to terminate vesting of a Escrow. Performed when\n\n     * a beneficiary is terminated.\n\n     * \n\n     * Requirements:\n\n     * \n\n     * - Vesting must be active.\n\n     */\n\n    function stopVesting(address beneficiary) external onlyVestingManager {\n\n        require(\n\n            _beneficiaries[beneficiary].status == BeneficiaryStatus.ACTIVE,\n\n            \"Cannot stop vesting for a non active beneficiary\"\n\n        );\n\n        require(\n\n            _plans[_beneficiaries[beneficiary].planId - 1].isTerminatable,\n\n            \"Can't stop vesting for beneficiary with this plan\"\n\n        );\n\n        _beneficiaries[beneficiary].status = BeneficiaryStatus.TERMINATED;\n\n        Escrow(_beneficiaryToEscrow[beneficiary]).cancelVesting(calculateVestedAmount(beneficiary));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns vesting start month of the beneficiary's Plan.\n\n     */\n\n    function getStartMonth(address beneficiary) external view returns (uint) {\n\n        return _beneficiaries[beneficiary].startMonth;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the final vesting date of the beneficiary's Plan.\n\n     */\n\n    function getFinishVestingTime(address beneficiary) external view returns (uint) {\n\n        ITimeHelpers timeHelpers = ITimeHelpers(contractManager.getContract(\"TimeHelpers\"));\n\n        Beneficiary memory beneficiaryPlan = _beneficiaries[beneficiary];\n\n        Plan memory planParams = _plans[beneficiaryPlan.planId - 1];\n\n        return timeHelpers.monthToTimestamp(beneficiaryPlan.startMonth.add(planParams.totalVestingDuration));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the vesting cliff period in months.\n\n     */\n\n    function getVestingCliffInMonth(address beneficiary) external view returns (uint) {\n\n        return _plans[_beneficiaries[beneficiary].planId - 1].vestingCliff;\n\n    }\n\n\n\n    /**\n\n     * @dev Confirms whether the beneficiary is active in the Plan.\n\n     */\n\n    function isVestingActive(address beneficiary) external view returns (bool) {\n\n        return _beneficiaries[beneficiary].status == BeneficiaryStatus.ACTIVE;\n\n    }\n\n\n\n    /**\n\n     * @dev Confirms whether the beneficiary is registered in a Plan.\n\n     */\n\n    function isBeneficiaryRegistered(address beneficiary) external view returns (bool) {\n\n        return _beneficiaries[beneficiary].status != BeneficiaryStatus.UNKNOWN;\n\n    }\n\n\n\n    /**\n\n     * @dev Confirms whether the beneficiary's Plan allows all un-vested tokens to be\n\n     * delegated.\n\n     */\n\n    function isDelegationAllowed(address beneficiary) external view returns (bool) {\n\n        return _plans[_beneficiaries[beneficiary].planId - 1].isDelegationAllowed;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the locked and unlocked (full) amount of tokens allocated to\n\n     * the beneficiary address in Plan.\n\n     */\n\n    function getFullAmount(address beneficiary) external view returns (uint) {\n\n        return _beneficiaries[beneficiary].fullAmount;\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the Escrow contract by beneficiary.\n\n     */\n\n    function getEscrowAddress(address beneficiary) external view returns (address) {\n\n        return address(_beneficiaryToEscrow[beneficiary]);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the timestamp when vesting cliff ends and periodic vesting\n\n     * begins.\n\n     */\n\n    function getLockupPeriodEndTimestamp(address beneficiary) external view returns (uint) {\n\n        ITimeHelpers timeHelpers = ITimeHelpers(contractManager.getContract(\"TimeHelpers\"));\n\n        Beneficiary memory beneficiaryPlan = _beneficiaries[beneficiary];\n\n        Plan memory planParams = _plans[beneficiaryPlan.planId - 1];\n\n        return timeHelpers.monthToTimestamp(beneficiaryPlan.startMonth.add(planParams.vestingCliff));\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the time of the next vesting event.\n\n     */\n\n    function getTimeOfNextVest(address beneficiary) external view returns (uint) {\n\n        ITimeHelpers timeHelpers = ITimeHelpers(contractManager.getContract(\"TimeHelpers\"));\n\n\n\n        Beneficiary memory beneficiaryPlan = _beneficiaries[beneficiary];\n\n        Plan memory planParams = _plans[beneficiaryPlan.planId - 1];\n\n\n\n        uint256 firstVestingMonth = beneficiaryPlan.startMonth.add(planParams.vestingCliff);\n\n        uint256 lockupEndTimestamp = timeHelpers.monthToTimestamp(firstVestingMonth);\n\n        if (now < lockupEndTimestamp) {\n\n            return lockupEndTimestamp;\n\n        }\n\n        require(\n\n            now < timeHelpers.monthToTimestamp(beneficiaryPlan.startMonth.add(planParams.totalVestingDuration)),\n\n            \"Vesting is over\"\n\n        );\n\n        require(beneficiaryPlan.status != BeneficiaryStatus.TERMINATED, \"Vesting was stopped\");\n\n        \n\n        uint256 currentMonth = timeHelpers.getCurrentMonth();\n\n        if (planParams.vestingIntervalTimeUnit == TimeUnit.DAY) {\n\n            // TODO: it may be simplified if TimeHelpers contract in skale-manager is updated\n\n            uint daysPassedBeforeCurrentMonth = _daysBetweenMonths(firstVestingMonth, currentMonth);\n\n            uint256 currentMonthBeginningTimestamp = timeHelpers.monthToTimestamp(currentMonth);\n\n            uint256 daysPassedInCurrentMonth = now.sub(currentMonthBeginningTimestamp).div(_SECONDS_PER_DAY);\n\n            uint256 daysPassedBeforeNextVest = _calculateNextVestingStep(\n\n                daysPassedBeforeCurrentMonth.add(daysPassedInCurrentMonth),\n\n                planParams.vestingInterval\n\n            );\n\n            return currentMonthBeginningTimestamp.add(\n\n                daysPassedBeforeNextVest\n\n                    .sub(daysPassedBeforeCurrentMonth)\n\n                    .mul(_SECONDS_PER_DAY)\n\n            );\n\n        } else if (planParams.vestingIntervalTimeUnit == TimeUnit.MONTH) {\n\n            return timeHelpers.monthToTimestamp(\n\n                firstVestingMonth.add(\n\n                    _calculateNextVestingStep(currentMonth.sub(firstVestingMonth), planParams.vestingInterval)\n\n                )\n\n            );\n\n        } else if (planParams.vestingIntervalTimeUnit == TimeUnit.YEAR) {\n\n            return timeHelpers.monthToTimestamp(\n\n                firstVestingMonth.add(\n\n                    _calculateNextVestingStep(\n\n                        currentMonth.sub(firstVestingMonth),\n\n                        planParams.vestingInterval.mul(_MONTHS_PER_YEAR)\n\n                    )\n\n                )\n\n            );\n\n        } else {\n\n            revert(\"Vesting interval timeunit is incorrect\");\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the Plan parameters.\n\n     * \n\n     * Requirements:\n\n     * \n\n     * - Plan must already exist.\n\n     */\n\n    function getPlan(uint256 planId) external view returns (Plan memory) {\n\n        require(planId > 0 && planId <= _plans.length, \"Plan Round does not exist\");\n\n        return _plans[planId - 1];\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the Plan parameters for a beneficiary address.\n\n     * \n\n     * Requirements:\n\n     * \n\n     * - Beneficiary address must be registered to an Plan.\n\n     */\n\n    function getBeneficiaryPlanParams(address beneficiary) external view returns (Beneficiary memory) {\n\n        require(_beneficiaries[beneficiary].status != BeneficiaryStatus.UNKNOWN, \"Plan beneficiary is not registered\");\n\n        return _beneficiaries[beneficiary];\n\n    }\n\n\n\n    function initialize(address contractManagerAddress) public override initializer {\n\n        Permissions.initialize(contractManagerAddress);\n\n        _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777TokensRecipient\"), address(this));\n\n    }\n\n\n\n    /**\n\n     * @dev Calculates and returns the vested token amount.\n\n     */\n\n    function calculateVestedAmount(address wallet) public view returns (uint256 vestedAmount) {\n\n        ITimeHelpers timeHelpers = ITimeHelpers(contractManager.getContract(\"TimeHelpers\"));\n\n        Beneficiary memory beneficiaryPlan = _beneficiaries[wallet];\n\n        Plan memory planParams = _plans[beneficiaryPlan.planId - 1];\n\n        vestedAmount = 0;\n\n        uint256 currentMonth = timeHelpers.getCurrentMonth();\n\n        if (currentMonth >= beneficiaryPlan.startMonth.add(planParams.vestingCliff)) {\n\n            vestedAmount = beneficiaryPlan.amountAfterLockup;\n\n            if (currentMonth >= beneficiaryPlan.startMonth.add(planParams.totalVestingDuration)) {\n\n                vestedAmount = beneficiaryPlan.fullAmount;\n\n            } else {\n\n                uint256 payment = _getSinglePaymentSize(\n\n                    wallet,\n\n                    beneficiaryPlan.fullAmount,\n\n                    beneficiaryPlan.amountAfterLockup\n\n                );\n\n                vestedAmount = vestedAmount.add(payment.mul(_getNumberOfCompletedVestingEvents(wallet)));\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of vesting events that have completed.\n\n     */\n\n    function _getNumberOfCompletedVestingEvents(address wallet) internal view returns (uint) {\n\n        ITimeHelpers timeHelpers = ITimeHelpers(contractManager.getContract(\"TimeHelpers\"));\n\n        \n\n        Beneficiary memory beneficiaryPlan = _beneficiaries[wallet];\n\n        Plan memory planParams = _plans[beneficiaryPlan.planId - 1];\n\n\n\n        uint256 firstVestingMonth = beneficiaryPlan.startMonth.add(planParams.vestingCliff);\n\n        if (now < timeHelpers.monthToTimestamp(firstVestingMonth)) {\n\n            return 0;\n\n        } else {\n\n            uint256 currentMonth = timeHelpers.getCurrentMonth();\n\n            if (planParams.vestingIntervalTimeUnit == TimeUnit.DAY) {\n\n                return _daysBetweenMonths(firstVestingMonth, currentMonth)\n\n                    .add(\n\n                        now\n\n                            .sub(timeHelpers.monthToTimestamp(currentMonth))\n\n                            .div(_SECONDS_PER_DAY)\n\n                    )\n\n                    .div(planParams.vestingInterval);\n\n            } else if (planParams.vestingIntervalTimeUnit == TimeUnit.MONTH) {\n\n                return currentMonth\n\n                    .sub(firstVestingMonth)\n\n                    .div(planParams.vestingInterval);\n\n            } else if (planParams.vestingIntervalTimeUnit == TimeUnit.YEAR) {\n\n                return currentMonth\n\n                    .sub(firstVestingMonth)\n\n                    .div(_MONTHS_PER_YEAR)\n\n                    .div(planParams.vestingInterval);\n\n            } else {\n\n                revert(\"Unknown time unit\");\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of total vesting events.\n\n     */\n\n    function _getNumberOfAllVestingEvents(address wallet) internal view returns (uint) {\n\n        Beneficiary memory beneficiaryPlan = _beneficiaries[wallet];\n\n        Plan memory planParams = _plans[beneficiaryPlan.planId - 1];\n\n        if (planParams.vestingIntervalTimeUnit == TimeUnit.DAY) {\n\n            return _daysBetweenMonths(\n\n                beneficiaryPlan.startMonth.add(planParams.vestingCliff),\n\n                beneficiaryPlan.startMonth.add(planParams.totalVestingDuration)\n\n            ).div(planParams.vestingInterval);\n\n        } else if (planParams.vestingIntervalTimeUnit == TimeUnit.MONTH) {\n\n            return planParams.totalVestingDuration\n\n                .sub(planParams.vestingCliff)\n\n                .div(planParams.vestingInterval);\n\n        } else if (planParams.vestingIntervalTimeUnit == TimeUnit.YEAR) {\n\n            return planParams.totalVestingDuration\n\n                .sub(planParams.vestingCliff)\n\n                .div(_MONTHS_PER_YEAR)\n\n                .div(planParams.vestingInterval);\n\n        } else {\n\n            revert(\"Unknown time unit\");\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the amount of tokens that are unlocked in each vesting\n\n     * period.\n\n     */\n\n    function _getSinglePaymentSize(\n\n        address wallet,\n\n        uint256 fullAmount,\n\n        uint256 afterLockupPeriodAmount\n\n    )\n\n        internal\n\n        view\n\n        returns(uint)\n\n    {\n\n        return fullAmount.sub(afterLockupPeriodAmount).div(_getNumberOfAllVestingEvents(wallet));\n\n    }\n\n\n\n    function _deployEscrow(address beneficiary) private returns (Escrow) {\n\n        // TODO: replace with ProxyFactory when @openzeppelin/upgrades will be compatible with solidity 0.6\n\n        IProxyFactory proxyFactory = IProxyFactory(contractManager.getContract(\"ProxyFactory\"));\n\n        Escrow escrow = Escrow(contractManager.getContract(\"Escrow\"));\n\n        // TODO: replace with ProxyAdmin when @openzeppelin/upgrades will be compatible with solidity 0.6\n\n        IProxyAdmin proxyAdmin = IProxyAdmin(contractManager.getContract(\"ProxyAdmin\"));\n\n\n\n        return Escrow(\n\n            proxyFactory.deploy(\n\n                uint256(bytes32(bytes20(beneficiary))),\n\n                proxyAdmin.getProxyImplementation(address(escrow)),\n\n                address(proxyAdmin),\n\n                abi.encodeWithSelector(\n\n                    Escrow.initialize.selector,\n\n                    address(contractManager),\n\n                    beneficiary\n\n                )\n\n            )\n\n        );\n\n    }\n\n\n\n    function _daysBetweenMonths(uint256 beginMonth, uint256 endMonth) private view returns (uint256) {\n\n        assert(beginMonth <= endMonth);\n\n        ITimeHelpers timeHelpers = ITimeHelpers(contractManager.getContract(\"TimeHelpers\"));\n\n        uint256 beginTimestamp = timeHelpers.monthToTimestamp(beginMonth);\n\n        uint256 endTimestamp = timeHelpers.monthToTimestamp(endMonth);\n\n        uint256 secondsPassed = endTimestamp.sub(beginTimestamp);\n\n        require(secondsPassed.mod(_SECONDS_PER_DAY) == 0, \"Internal error in calendar\");\n\n        return secondsPassed.div(_SECONDS_PER_DAY);\n\n    }\n\n\n\n    /**\n\n     * @dev returns time of next vest in abstract time units named \"step\"\n\n     * Examples:\n\n     *     if current step is 5 and vesting interval is 7 function returns 7.\n\n     *     if current step is 17 and vesting interval is 7 function returns 21.\n\n     */\n\n    function _calculateNextVestingStep(uint256 currentStep, uint256 vestingInterval) private pure returns (uint256) {\n\n        return currentStep\n\n            .add(vestingInterval)\n\n            .sub(\n\n                currentStep.mod(vestingInterval)\n\n            );\n\n    }\n\n}\n\ncontract Escrow is IERC777Recipient, IERC777Sender, Permissions {\n\n\n\n    address private _beneficiary;\n\n\n\n    uint256 private _availableAmountAfterTermination;\n\n\n\n    IERC1820Registry private _erc1820;\n\n\n\n    modifier onlyBeneficiary() {\n\n        require(_msgSender() == _beneficiary, \"Message sender is not a plan beneficiary\");\n\n        _;\n\n    }\n\n\n\n    modifier onlyVestingManager() {\n\n        Allocator allocator = Allocator(contractManager.getContract(\"Allocator\"));\n\n        require(\n\n            allocator.hasRole(allocator.VESTING_MANAGER_ROLE(), _msgSender()),\n\n            \"Message sender is not a vesting manager\"\n\n        );\n\n        _;\n\n    }\n\n\n\n    modifier onlyActiveBeneficiaryOrVestingManager() {\n\n        Allocator allocator = Allocator(contractManager.getContract(\"Allocator\"));\n\n        if (allocator.isVestingActive(_beneficiary)) {\n\n            require(_msgSender() == _beneficiary, \"Message sender is not beneficiary\");\n\n        } else {\n\n            require(\n\n                allocator.hasRole(allocator.VESTING_MANAGER_ROLE(), _msgSender()),\n\n                \"Message sender is not authorized\"\n\n            );\n\n        }\n\n        _;\n\n    }   \n\n\n\n    function initialize(address contractManagerAddress, address beneficiary) external initializer {\n\n        require(beneficiary != address(0), \"Beneficiary address is not set\");\n\n        Permissions.initialize(contractManagerAddress);\n\n        _beneficiary = beneficiary;\n\n        _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777TokensRecipient\"), address(this));\n\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777TokensSender\"), address(this));\n\n    } \n\n\n\n    function tokensReceived(\n\n        address operator,\n\n        address from,\n\n        address to,\n\n        uint256 amount,\n\n        bytes calldata userData,\n\n        bytes calldata operatorData\n\n    )\n\n        external override\n\n        allow(\"SkaleToken\")\n\n        // solhint-disable-next-line no-empty-blocks\n\n    {\n\n\n\n    }\n\n\n\n    function tokensToSend(\n\n        address,\n\n        address,\n\n        address to,\n\n        uint256,\n\n        bytes calldata,\n\n        bytes calldata\n\n    )\n\n        external override\n\n        allow(\"SkaleToken\")\n\n        // solhint-disable-next-line no-empty-blocks\n\n    {\n\n\n\n    }\n\n\n\n    /**\n\n     * @dev Allows Beneficiary to retrieve vested tokens from the Escrow contract.\n\n     * \n\n     * IMPORTANT: Slashed tokens are non-transferable.\n\n     */\n\n    function retrieve() external onlyBeneficiary {\n\n        Allocator allocator = Allocator(contractManager.getContract(\"Allocator\"));\n\n        ITokenState tokenState = ITokenState(contractManager.getContract(\"TokenState\"));\n\n        uint256 vestedAmount = 0;\n\n        if (allocator.isVestingActive(_beneficiary)) {\n\n            vestedAmount = allocator.calculateVestedAmount(_beneficiary);\n\n        } else {\n\n            vestedAmount = _availableAmountAfterTermination;\n\n        }\n\n        uint256 escrowBalance = IERC20(contractManager.getContract(\"SkaleToken\")).balanceOf(address(this));\n\n        uint256 fullAmount = allocator.getFullAmount(_beneficiary);\n\n        uint256 forbiddenToSend = tokenState.getAndUpdateForbiddenForDelegationAmount(address(this));\n\n        if (vestedAmount > fullAmount.sub(escrowBalance)) {\n\n            if (vestedAmount.sub(fullAmount.sub(escrowBalance)) > forbiddenToSend)\n\n            require(\n\n                IERC20(contractManager.getContract(\"SkaleToken\")).transfer(\n\n                    _beneficiary,\n\n                    vestedAmount\n\n                        .sub(\n\n                            fullAmount\n\n                                .sub(escrowBalance)\n\n                            )\n\n                        .sub(forbiddenToSend)\n\n                ),\n\n                \"Error of token send\"\n\n            );\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Allows Vesting Manager to retrieve remaining transferrable escrow balance\n\n     * after beneficiary's termination. \n\n     * \n\n     * IMPORTANT: Slashed tokens are non-transferable.\n\n     * \n\n     * Requirements:\n\n     * \n\n     * - Allocator must be active.\n\n     */\n\n    function retrieveAfterTermination(address destination) external onlyVestingManager {\n\n        Allocator allocator = Allocator(contractManager.getContract(\"Allocator\"));\n\n        ITokenState tokenState = ITokenState(contractManager.getContract(\"TokenState\"));\n\n\n\n        require(destination != address(0), \"Destination address is not set\");\n\n        require(!allocator.isVestingActive(_beneficiary), \"Vesting is active\");\n\n        uint256 escrowBalance = IERC20(contractManager.getContract(\"SkaleToken\")).balanceOf(address(this));\n\n        uint256 forbiddenToSend = tokenState.getAndUpdateLockedAmount(address(this));\n\n        if (escrowBalance > forbiddenToSend) {\n\n            require(\n\n                IERC20(contractManager.getContract(\"SkaleToken\")).transfer(\n\n                    destination,\n\n                    escrowBalance.sub(forbiddenToSend)\n\n                ),\n\n                \"Error of token send\"\n\n            );\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Allows Beneficiary to propose a delegation to a validator.\n\n     * \n\n     * Requirements:\n\n     * \n\n     * - Beneficiary must be active.\n\n     * - Beneficiary must have sufficient delegatable tokens.\n\n     * - If trusted list is enabled, validator must be a member of the trusted\n\n     * list.\n\n     */\n\n    function delegate(\n\n        uint256 validatorId,\n\n        uint256 amount,\n\n        uint256 delegationPeriod,\n\n        string calldata info\n\n    )\n\n        external\n\n        onlyBeneficiary\n\n    {\n\n        Allocator allocator = Allocator(contractManager.getContract(\"Allocator\"));\n\n        require(allocator.isDelegationAllowed(_beneficiary), \"Delegation is not allowed\");\n\n        require(allocator.isVestingActive(_beneficiary), \"Beneficiary is not Active\");\n\n        \n\n        IDelegationController delegationController = IDelegationController(\n\n            contractManager.getContract(\"DelegationController\")\n\n        );\n\n        delegationController.delegate(validatorId, amount, delegationPeriod, info);\n\n    }\n\n\n\n    /**\n\n     * @dev Allows Beneficiary and Vesting manager to request undelegation. Only \n\n     * Vesting manager can request undelegation after beneficiary is deactivated \n\n     * (after beneficiary termination).\n\n     * \n\n     * Requirements:\n\n     * \n\n     * - Beneficiary and Vesting manager must be `msg.sender`.\n\n     */\n\n    function requestUndelegation(uint256 delegationId) external onlyActiveBeneficiaryOrVestingManager {\n\n        IDelegationController delegationController = IDelegationController(\n\n            contractManager.getContract(\"DelegationController\")\n\n        );\n\n        delegationController.requestUndelegation(delegationId);\n\n    }\n\n\n\n    /**\n\n     * @dev Allows Beneficiary and Vesting manager to cancel a delegation proposal. Only \n\n     * Vesting manager can request undelegation after beneficiary is deactivated \n\n     * (after beneficiary termination).\n\n     * \n\n     * Requirements:\n\n     * \n\n     * - Beneficiary and Vesting manager must be `msg.sender`.\n\n     */\n\n    function cancelPendingDelegation(uint delegationId) external onlyActiveBeneficiaryOrVestingManager {\n\n        IDelegationController delegationController = IDelegationController(\n\n            contractManager.getContract(\"DelegationController\")\n\n        );\n\n        delegationController.cancelPendingDelegation(delegationId);\n\n    }\n\n\n\n    /**\n\n     * @dev Allows Beneficiary and Vesting manager to withdraw earned bounty. Only\n\n     * Vesting manager can withdraw bounty to Allocator contract after beneficiary\n\n     * is deactivated.\n\n     * \n\n     * IMPORTANT: Withdraws are only possible after 90 day initial network lock.\n\n     * \n\n     * Requirements:\n\n     * \n\n     * - Beneficiary or Vesting manager must be `msg.sender`.\n\n     * - Beneficiary must be active when Beneficiary is `msg.sender`.\n\n     */\n\n    function withdrawBounty(uint256 validatorId, address to) external onlyActiveBeneficiaryOrVestingManager {        \n\n        IDistributor distributor = IDistributor(contractManager.getContract(\"Distributor\"));\n\n        distributor.withdrawBounty(validatorId, to);\n\n    }\n\n\n\n    /**\n\n     * @dev Allows Allocator contract to cancel vesting of a Beneficiary. Cancel\n\n     * vesting is performed upon termination.\n\n     */\n\n    function cancelVesting(uint256 vestedAmount) external allow(\"Allocator\") {\n\n        _availableAmountAfterTermination = vestedAmount;\n\n    }\n\n}\n",
    "vulnerability_type": "nil"
  },
  {
    "address": "0x4639cd8cd52ec1cf2e496a606ce28d8afb1c792f",
    "source_code": "pragma solidity 0.6.12;\n\nabstract contract ERC20Interface {\n\n\n    function totalSupply() public virtual view returns (uint);\n\n\n    function balanceOf(address tokenOwner) public virtual view returns (uint256 balance);\n\n\n    function allowance(address tokenOwner, address spender) public virtual view returns (uint256 remaining);\n\n\n    function transfer(address to, uint256 tokens) public virtual returns (bool success);\n\n\n    function approve(address spender, uint256 tokens) public virtual returns (bool success);\n\n\n    function transferFrom(address from, address to, uint256 tokens) public virtual returns (bool success);\n\n\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n\n\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n\n\n}\n\ncontract Owned {\n\n\n    address payable public owner;\n\n\n\n\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n\n\n\n\n    constructor() public {\n\n\n        owner = msg.sender;\n\n\n    }\n\n\n\n\n\n    modifier onlyOwner {\n\n\n        require(msg.sender == owner);\n\n\n        _;\n\n\n    }\n\n\n\n\n\n    function transferOwnership(address payable _newOwner) public onlyOwner {\n\n\n        owner = _newOwner;\n\n\n        emit OwnershipTransferred(msg.sender, _newOwner);\n\n\n    }\n\n\n}\n\nlibrary SafeMath {\n\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n\n    if (a == 0) {\n\n\n      return 0;\n\n\n    }\n\n\n    uint256 c = a * b;\n\n\n    assert(c / a == b);\n\n\n    return c;\n\n\n  }\n\n\n\n\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n\n    uint256 c = a / b;\n\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\n    return c;\n\n\n  }\n\n\n\n\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n\n    assert(b <= a);\n\n\n    return a - b;\n\n\n  }\n\n\n\n\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n\n    uint256 c = a + b;\n\n\n    assert(c >= a);\n\n\n    return c;\n\n\n  }\n\n\n  \n\n\n  function ceil(uint a, uint m) internal pure returns (uint r) {\n\n\n    return (a + m - 1) / m * m;\n\n\n  }\n\n\n}\n\ncontract Token is ERC20Interface, Owned {\n\n\n    using SafeMath for uint256;\n\n\n    string public symbol = \"BREE\";\n\n\n    string public  name = \"CBDAO\";\n\n\n    uint256 public decimals = 18;\n\n\n    uint256 private maxCapSupply = 1e7 * 10**(decimals); // 10 million\n\n\n    uint256 _totalSupply = 1530409 * 10 ** (decimals); // 1,530,409\n\n\n    address stakeFarmingContract;\n\n\n    \n\n\n    mapping(address => uint256) balances;\n\n\n    mapping(address => mapping(address => uint256)) allowed;\n\n\n    \n\n\n    // ------------------------------------------------------------------------\n\n\n    // Constructor\n\n\n    // ------------------------------------------------------------------------\n\n\n    constructor() public {\n\n\n        // mint _totalSupply amount of tokens and send to owner\n\n\n        balances[owner] = balances[owner].add(_totalSupply);\n\n\n        emit Transfer(address(0),owner, _totalSupply);\n\n\n    }\n\n\n    \n\n\n    // ------------------------------------------------------------------------\n\n\n    // Set the STAKE_FARMING_CONTRACT\n\n\n    // @required only owner\n\n\n    // ------------------------------------------------------------------------\n\n\n    function SetStakeFarmingContract(address _address) external onlyOwner{\n\n\n        require(_address != address(0), \"Invalid address\");\n\n\n        stakeFarmingContract = _address;\n\n\n    }\n\n\n    \n\n\n    // ------------------------------------------------------------------------\n\n\n    // Token Minting function\n\n\n    // @params _amount expects the amount of tokens to be minted excluding the \n\n\n    // required decimals\n\n\n    // @params _beneficiary tokens will be sent to _beneficiary\n\n\n    // @required only owner OR stakeFarmingContract\n\n\n    // ------------------------------------------------------------------------\n\n\n    function MintTokens(uint256 _amount, address _beneficiary) public returns(bool){\n\n\n        require(msg.sender == stakeFarmingContract);\n\n\n        require(_beneficiary != address(0), \"Invalid address\");\n\n\n        require(_totalSupply.add(_amount) <= maxCapSupply, \"exceeds max cap supply 10 million\");\n\n\n        _totalSupply = _totalSupply.add(_amount);\n\n\n        \n\n\n        // mint _amount tokens and keep inside contract\n\n\n        balances[_beneficiary] = balances[_beneficiary].add(_amount);\n\n\n        \n\n\n        emit Transfer(address(0),_beneficiary, _amount);\n\n\n        return true;\n\n\n    }\n\n\n    \n\n\n    // ------------------------------------------------------------------------\n\n\n    // Burn the `_amount` amount of tokens from the calling `account`\n\n\n    // @params _amount the amount of tokens to burn\n\n\n    // ------------------------------------------------------------------------\n\n\n    function BurnTokens(uint256 _amount) external {\n\n\n        _burn(_amount, msg.sender);\n\n\n    }\n\n\n\n\n\n    // ------------------------------------------------------------------------\n\n\n    // @dev Internal function that burns an amount of the token from a given account\n\n\n    // @param _amount The amount that will be burnt\n\n\n    // @param _account The tokens to burn from\n\n\n    // ------------------------------------------------------------------------\n\n\n    function _burn(uint256 _amount, address _account) internal {\n\n\n        require(balances[_account] >= _amount, \"insufficient account balance\");\n\n\n        _totalSupply = _totalSupply.sub(_amount);\n\n\n        balances[_account] = balances[_account].sub(_amount);\n\n\n        emit Transfer(_account, address(0), _amount);\n\n\n    }\n\n\n    \n\n\n    /** ERC20Interface function's implementation **/\n\n\n    \n\n\n    // ------------------------------------------------------------------------\n\n\n    // Get the total supply of the `token`\n\n\n    // ------------------------------------------------------------------------\n\n\n    function totalSupply() public override view returns (uint256){\n\n\n       return _totalSupply; \n\n\n    }\n\n\n    \n\n\n    // ------------------------------------------------------------------------\n\n\n    // Get the token balance for account `tokenOwner`\n\n\n    // ------------------------------------------------------------------------\n\n\n    function balanceOf(address tokenOwner) public override view returns (uint256 balance) {\n\n\n        return balances[tokenOwner];\n\n\n    }\n\n\n\n\n\n    // ------------------------------------------------------------------------\n\n\n    // Transfer the balance from token owner's account to `to` account\n\n\n    // - Owner's account must have sufficient balance to transfer\n\n\n    // - 0 value transfers are allowed\n\n\n    // ------------------------------------------------------------------------\n\n\n    function transfer(address to, uint256 tokens) public override returns  (bool success) {\n\n\n        // prevent transfer to 0x0, use burn instead\n\n\n        require(address(to) != address(0));\n\n\n        require(balances[msg.sender] >= tokens );\n\n\n        require(balances[to].add(tokens) >= balances[to]);\n\n\n            \n\n\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n\n\n        balances[to] = balances[to].add(tokens);\n\n\n        emit Transfer(msg.sender,to,tokens);\n\n\n        return true;\n\n\n    }\n\n\n\n\n\n    /**\n\n\n     * @dev See `IERC20.approve`.\n\n\n     *\n\n\n     * Requirements:\n\n\n     *\n\n\n     * - `spender` cannot be the zero address.\n\n\n     */\n\n\n    function approve(address spender, uint256 value) public override returns (bool) {\n\n\n        _approve(msg.sender, spender, value);\n\n\n        return true;\n\n\n    }\n\n\n\n\n\n    // ------------------------------------------------------------------------\n\n\n    // Transfer `tokens` from the `from` account to the `to` account\n\n\n    // \n\n\n    // The calling account must already have sufficient tokens approve(...)-d\n\n\n    // for spending from the `from` account and\n\n\n    // - From account must have sufficient balance to transfer\n\n\n    // - Spender must have sufficient allowance to transfer\n\n\n    // - 0 value transfers are allowed\n\n\n    // ------------------------------------------------------------------------\n\n\n    function transferFrom(address from, address to, uint256 tokens) public override returns (bool success){\n\n\n        require(tokens <= allowed[from][msg.sender]); //check allowance\n\n\n        require(balances[from] >= tokens);\n\n\n        require(from != address(0), \"Invalid address\");\n\n\n        require(to != address(0), \"Invalid address\");\n\n\n        \n\n\n        balances[from] = balances[from].sub(tokens);\n\n\n        balances[to] = balances[to].add(tokens);\n\n\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n\n\n        emit Transfer(from,to,tokens);\n\n\n        return true;\n\n\n    }\n\n\n    \n\n\n    // ------------------------------------------------------------------------\n\n\n    // Returns the amount of tokens approved by the owner that can be\n\n\n    // transferred to the spender's account\n\n\n    // ------------------------------------------------------------------------\n\n\n    function allowance(address tokenOwner, address spender) public override view returns (uint256 remaining) {\n\n\n        return allowed[tokenOwner][spender];\n\n\n    }\n\n\n    \n\n\n    /**\n\n\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n\n\n     *\n\n\n     * This is an alternative to `approve` that can be used as a mitigation for\n\n\n     * problems described in `IERC20.approve`.\n\n\n     *\n\n\n     * Emits an `Approval` event indicating the updated allowance.\n\n\n     *\n\n\n     * Requirements:\n\n\n     *\n\n\n     * - `spender` cannot be the zero address.\n\n\n     */\n\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n\n        _approve(msg.sender, spender, allowed[msg.sender][spender].add(addedValue));\n\n\n        return true;\n\n\n    }\n\n\n\n\n\n    /**\n\n\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n\n\n     *\n\n\n     * This is an alternative to `approve` that can be used as a mitigation for\n\n\n     * problems described in `IERC20.approve`.\n\n\n     *\n\n\n     * Emits an `Approval` event indicating the updated allowance.\n\n\n     *\n\n\n     * Requirements:\n\n\n     *\n\n\n     * - `spender` cannot be the zero address.\n\n\n     * - `spender` must have allowance for the caller of at least\n\n\n     * `subtractedValue`.\n\n\n     */\n\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n\n        _approve(msg.sender, spender, allowed[msg.sender][spender].sub(subtractedValue));\n\n\n        return true;\n\n\n    }\n\n\n    \n\n\n    /**\n\n\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n\n\n     *\n\n\n     * This is internal function is equivalent to `approve`, and can be used to\n\n\n     * e.g. set automatic allowances for certain subsystems, etc.\n\n\n     *\n\n\n     * Emits an `Approval` event.\n\n\n     *\n\n\n     * Requirements:\n\n\n     *\n\n\n     * - `owner` cannot be the zero address.\n\n\n     * - `spender` cannot be the zero address.\n\n\n     */\n\n\n    function _approve(address owner, address spender, uint256 value) internal {\n\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n\n\n        allowed[owner][spender] = value;\n\n\n        emit Approval(owner, spender, value);\n\n\n    }\n\n\n}\n",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x01b94fde783c372733e8d158d5545bdf94e2f67f",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-06-01\n*/\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.6.12;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\n\ncontract ZootInu is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 100000000 * 10**9 * 10**9;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'Zoo Inu';\n    string private _symbol = 'ZOOTINU';\n    uint8 private _decimals = 9;\n    \n    uint256 public _maxTxAmount = 10000000 * 10**9 * 10**9;\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n    \n    \n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\n        _maxTxAmount = _tTotal.mul(maxTxPercent).div(\n            10**2\n        );\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if(sender != owner() && recipient != owner())\n          require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n            \n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferStandard(sender, recipient, amount);\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\n        uint256 tFee = tAmount.div(100).mul(2);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x01c2d503c83a40a91986d54a804935622d5f756c",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-05-16\n*/\n\npragma solidity ^0.5.9;\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a / b;\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n  \n      function ceil(uint a, uint m) internal pure returns (uint r) {\n        return (a + m - 1) / m * m;\n    }\n\n}\n\ncontract Owned {\n    modifier onlyOwner() {\n        require(msg.sender==owner);\n        _;\n    }\n    address payable owner;\n    address payable newOwner;\n    function changeOwner(address payable _newOwner) public onlyOwner {\n        require(_newOwner!=address(0));\n        newOwner = _newOwner;\n    }\n    function acceptOwnership() public {\n        if (msg.sender==newOwner) {\n            owner = newOwner;\n        }\n    }\n}\n\ncontract ERC20 {\n    uint256 public totalSupply;\n    function balanceOf(address _owner) view public  returns (uint256 balance);\n    function transfer(address _to, uint256 _value) public  returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public  returns (bool success);\n    function approve(address _spender, uint256 _value) public returns (bool success);\n    function allowance(address _owner, address _spender) view public  returns (uint256 remaining);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is Owned,  ERC20 {\n    using SafeMath for uint256;\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n    mapping (address=>uint256) balances;\n    mapping (address=>mapping (address=>uint256)) allowed;\n    \n    uint256 burn_amount=0;\n    event Burn(address burner, uint256 _value);\n    event BurntOut(address burner, uint256 _value);\n    \n    function balanceOf(address _owner) view public   returns (uint256 balance) {return balances[_owner];}\n    \n    function transfer(address _to, uint256 _amount) public   returns (bool success) {\n        require (balances[msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\n\n        uint256 amount = fivePercent(_amount); \n        burn(msg.sender,amount);\n        if(totalSupply > 1000000000000000000000000)\n        {\n            \n        uint256 amountToTransfer = _amount.sub(amount);\n        balances[msg.sender]-=amountToTransfer;\n        balances[_to]+=amountToTransfer;\n        \n        emit Transfer(msg.sender,_to,amountToTransfer);\n        return true;\n        }\n        else{\n         \n        balances[msg.sender]-=_amount;\n        balances[_to]+=_amount;\n        emit Transfer(msg.sender,_to,_amount);\n        return true;\n        }\n        \n    }\n  \n  function transferFromOwner(address _to, uint256 _amount) public   returns (bool success) {\n        require (balances[owner]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\n       \n        uint256 amount = fivePercent(_amount);\n        burn(owner, amount);\n        \n        if(totalSupply > 1000000000000000000000000)\n        {\n        uint256 amountToTransfer = _amount.sub(amount);\n        balances[owner]-=amountToTransfer;\n        balances[_to]+=amountToTransfer;\n           emit Transfer(owner,_to,amountToTransfer);\n        }else\n        {\n        \n        balances[owner]-=_amount;\n        balances[_to]+=_amount;\n           emit Transfer(owner,_to,_amount);\n        }\n return true;\n    }\n  \n    function transferFrom(address _from,address _to,uint256 _amount) public   returns (bool success) {\n        require (balances[_from]>=_amount&&allowed[_from][msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\n        uint256 amount = fivePercent(_amount);\n       \n        burn(_from, amount);\n       \n        if(totalSupply > 1000000000000000000000000)\n        {\n        uint256 amountToTransfer = _amount.sub(amount);\n        balances[_from]-=amountToTransfer;\n        allowed[_from][msg.sender]-=amountToTransfer;\n        balances[_to]+=amountToTransfer;\n        emit Transfer(_from, _to, amountToTransfer);\n        }\n        else\n        {\n           \n        balances[_from]-=_amount;\n        allowed[_from][msg.sender]-=_amount;\n        balances[_to]+=_amount;\n        emit Transfer(_from, _to, _amount);\n        }\n       \n        return true;\n    }\n  \n    function approve(address _spender, uint256 _amount) public   returns (bool success) {\n        allowed[msg.sender][_spender]=_amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n    \n    function allowance(address _owner, address _spender) view public   returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n    \n    \n    function burn(address _from, uint256 _value) internal  {\n    \n        if(totalSupply > 1000000000000000000000000)\n        {\n            \n            uint256 burnlimit = totalSupply.sub(_value);\n        \n        \n        if(burnlimit > 1000000000000000000000000)    \n        {\n        balances[_from] =balances[_from].sub(_value);  // Subtract from the sender\n        totalSupply =totalSupply.sub(_value);  \n        burn_amount = burn_amount.add(_value);\n        // Updates totalSupply\n        emit Burn(_from, _value);\n        }else\n        {\n             emit BurntOut(msg.sender, _value);\n        }\n            \n        }else\n        {\n            emit BurntOut(msg.sender, _value);\n        }\n        \n        \n        \n    }\n        function fivePercent(uint256 _tokens) private pure returns (uint256){\n        uint256 roundValue = _tokens.ceil(100);\n        uint fivepercentofTokens = roundValue.mul(500).div(100 * 10**uint(2));\n        return fivepercentofTokens;\n    }\n}\n\ncontract PlutoDoge is Token{\n    using SafeMath for uint256;\n    constructor() public{\n        symbol = \"PDOGE\";\n        name = \"PlutoDoge\";\n        decimals = 18;\n        totalSupply = 1000000000000000000000000000; \n        \n        owner = msg.sender;\n        balances[owner] = totalSupply;\n        \n        \n    }\n\n    function () payable external {\n        require(msg.value>0);\n        owner.transfer(msg.value);\n    }\n    \n    \n    \n    \n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x01ce23b87ee17e2d130d9bac6cb67ea453fc2ce4",
    "source_code": "pragma solidity 0.4.24;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n  contract ERC20 {\n  function totalSupply()public view returns (uint total_Supply);\n  function balanceOf(address _owner)public view returns (uint256 balance);\n  function allowance(address _owner, address _spender)public view returns (uint remaining);\n  function transferFrom(address _from, address _to, uint _amount)public returns (bool ok);\n  function approve(address _spender, uint _amount)public returns (bool ok);\n  function transfer(address _to, uint _amount)public returns (bool ok);\n  event Transfer(address indexed _from, address indexed _to, uint _amount);\n  event Approval(address indexed _owner, address indexed _spender, uint _amount);\n}\n\n\ncontract SaudiArabianMonetaryAuthority is ERC20\n{using SafeMath for uint256;\n   string public constant symbol = \",000.SAR.SaudiArabianRiyal\";\n     string public constant name = \"Saudi Arabian Monetary Authority\";\n     uint public constant decimals = 18;\n     uint256 _totalSupply = 999000000000000000000 * 10 ** 18; // 999 Trillion Total Supply including 18 decimal\n     \n     // Owner of this contract\n     address public owner;\n     \n  // Balances for each account\n     mapping(address => uint256) balances;\n  \n     // Owner of account approves the transfer of an amount to another account\n     mapping(address => mapping (address => uint256)) allowed;\n  \n     // Functions with this modifier can only be executed by the owner\n     modifier onlyOwner() {\n         if (msg.sender != owner) {\n             revert();\n         }\n         _;\n     }\n  \n     // Constructor\n     constructor () public {\n         owner = msg.sender;\n         balances[owner] = _totalSupply;\n        emit Transfer(0, owner, _totalSupply);\n     }\n     \n     function burntokens(uint256 tokens) public onlyOwner {\n         _totalSupply = (_totalSupply).sub(tokens);\n     }\n  \n    // what is the total supply of the ech tokens\n     function totalSupply() public view returns (uint256 total_Supply) {\n         total_Supply = _totalSupply;\n     }\n       // What is the balance of a particular account?\n     function balanceOf(address _owner)public view returns (uint256 balance) {\n         return balances[_owner];\n     }\n  \n     // Transfer the balance from owner&#39;s account to another account\n     function transfer(address _to, uint256 _amount)public returns (bool ok) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        emit Transfer(msg.sender, _to, _amount);\n             return true;\n         }\n         \n    // Send _value amount of tokens from address _from to address _to\n     // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n     // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n     // fees in sub-currencies; the command should fail unless the _from account has\n     // deliberately authorized the sender of the message via some mechanism; we propose\n     // these standardized APIs for approval:\n     function transferFrom( address _from, address _to, uint256 _amount )public returns (bool ok) {\n     require( _to != 0x0);\n     require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n     balances[_from] = (balances[_from]).sub(_amount);\n     allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n     balances[_to] = (balances[_to]).add(_amount);\n     emit Transfer(_from, _to, _amount);\n     return true;\n         }\n \n     // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n     // If this function is called again it overwrites the current allowance with _value.\n     function approve(address _spender, uint256 _amount)public returns (bool ok) {\n         require( _spender != 0x0);\n         allowed[msg.sender][_spender] = _amount;\n         emit Approval(msg.sender, _spender, _amount);\n         return true;\n     }\n  \n     function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n         require( _owner != 0x0 && _spender !=0x0);\n         return allowed[_owner][_spender];\n   }\n        \n     //In case the ownership needs to be transferred\n\tfunction transferOwnership(address newOwner) external onlyOwner\n\t{\n\t    uint256 x = balances[owner];\n\t    require( newOwner != 0x0);\n\t    balances[newOwner] = (balances[newOwner]).add(balances[owner]);\n\t    balances[owner] = 0;\n\t    owner = newOwner;\n\t    emit Transfer(msg.sender, newOwner, x);\n\t}\n  \n\t\n  \n\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x01Ce398A2A59d164f366762EE70c596de06E9482",
    "source_code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n\n// \n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// \n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// \n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// \n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// \n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\n// \n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// UnFederalReserveToken with Governance.\ncontract UnFederalReserveToken is ERC20(\"UnFederalReserveToken\", \"eRSDL\"), Ownable {\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterUnChairman).\n    function mint(address _to, uint256 _amount) public onlyOwner {\n        _mint(_to, _amount);\n        _moveDelegates(address(0), _delegates[_to], _amount);\n    }\n\n    // Copied and modified from YAM code:\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\n    // Which is copied and modified from COMPOUND:\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) internal _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n      /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegator The address to get delegatee for\n     */\n    function delegates(address delegator)\n        external\n        view\n        returns (address)\n    {\n        return _delegates[delegator];\n    }\n\n   /**\n    * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"SUSHI::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"SUSHI::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"SUSHI::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(blockNumber < block.number, \"SUSHI::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee)\n        internal\n    {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SUSHIs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    )\n        internal\n    {\n        uint32 blockNumber = safe32(block.number, \"SUSHI::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x3a702ce810026af2523a8f3def80de3f7271b870",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-11-27\n*/\n\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\n\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\n\n\n// OpenZeppelin Contracts v4.4.0 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n\n// File: contracts/Exchange.sol\n\npragma solidity 0.8.0;\n\n\n\ncontract Exchange{\n    using SafeMath for uint256;\n    event Donate(address _owner,uint256 _amount,uint256 _token);\n    event GetDonate(address _owner,uint256 _amount);\n    event GetToken(address _owner,uint256 _amount);\n    event SetStartTime(uint256 _from, uint256 _to);\n    event SetCloseTime(uint256 _from, uint256 _to);\n    event SetRedeemTime(uint256 _from, uint256 _to);\n    event SetRedeemCloseTime(uint256 _from, uint256 _to);\n    event Redeem(address _owner, uint256 _amount,uint256 _token);\n\n    IERC20 iERC20;\n\n    uint256 public startTime;\n    uint256 public closeTime;\n    uint256 public redeemTime;\n    uint256 public redeemCloseTime;\n    address public owner;\n\n    constructor(IERC20 _iERC20, \n                uint256 _startTime,\n                uint256 _closeTime,\n                uint256 _redeemTime,\n                uint256 _redeemCloseTime){ \n        iERC20 = _iERC20;\n        startTime = _startTime;\n        closeTime = _closeTime;\n        redeemTime = _redeemTime;\n        redeemCloseTime = _redeemCloseTime;\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner{\n        require(msg.sender == owner,\"Not owner\");\n        _;\n    }\n\n    function setStartTime(uint256 _startTime) external onlyOwner() {\n        emit SetStartTime(startTime, _startTime);\n        startTime = _startTime;\n    }\n\n    function setCloseTime(uint256 _closeTime) external onlyOwner() {\n        emit SetCloseTime(closeTime, _closeTime);\n        closeTime = _closeTime;\n    }\n\n    function setRedeemTime(uint256 _redeemTime) external onlyOwner() {\n        emit SetRedeemTime(redeemTime, _redeemTime);\n        redeemTime = _redeemTime;\n    }\n\n    function setRedeemCloseTime(uint256 _redeemCloseTime) external onlyOwner() {\n        emit SetRedeemCloseTime(redeemCloseTime, _redeemCloseTime);\n        redeemCloseTime = _redeemCloseTime;\n    }\n\n    function donate() external payable{\n        uint256 amount = msg.value;\n        require(startTime!=0 && startTime<=block.timestamp,\"Not start\");\n        require(closeTime!=0 && closeTime>=block.timestamp,\"Has closed\");\n        require(amount >= 0.1 ether,\"Must over than 0.1 eth\");\n        uint256 tokenAmount = amount.mul(100000000);\n        iERC20.transfer(msg.sender, tokenAmount);\n        emit Donate(msg.sender, amount, tokenAmount);\n    }\n\n    function redeem(uint256 tokenAmount) external{\n        require(tokenAmount>=100000000,\"Amount error\");\n        require(redeemTime!=0 && redeemTime<=block.timestamp,\"Not start redeem\");\n        require(redeemCloseTime!=0 && redeemCloseTime>=block.timestamp,\"Redeem has closed\");\n        uint256 amount = tokenAmount.div(100000000);\n        safeTransferFromToken(address(iERC20),msg.sender,address(this), tokenAmount);\n        transferMain(msg.sender,amount);\n        emit Redeem(msg.sender, amount,tokenAmount);\n    }\n\n    function getDonate(uint256 _amount) external onlyOwner() {\n        require(block.timestamp > redeemCloseTime,\"Redeem not closed\");\n        transferMain(msg.sender,_amount);\n        emit GetDonate(msg.sender,_amount);\n    }\n\n    function getToken(uint256 _amount) external onlyOwner() {\n        require(block.timestamp > redeemCloseTime,\"Redeem not closed\");\n        iERC20.transfer(msg.sender, _amount);\n        emit GetToken(msg.sender,_amount);\n    }\n\n    function transferMain(address _address, uint256 _value) internal{\n        (bool success, bytes memory data) = address(uint160(_address)).call{value:_value,gas:20000}(\"\");\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TRANSFER_FROM_FAILED\"\n        );\n    }\n\n\n    function safeTransferFromToken(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        //transfer ERC20 Token\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    receive () external payable {}\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x3a742323112309ae0b0dc4d849979c3b94c6a5de",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-08-24\n*/\n\n/**\n *Submitted for verification at Etherscan.io on 2021-08-12\n */\n\n// File: @openzeppelin/contracts/utils/Context.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/introspection/IERC165.sol\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/introspection/ERC165.sol\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor() internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/utils/EnumerableSet.sol\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value)\n        private\n        view\n        returns (bool)\n    {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index)\n        private\n        view\n        returns (bytes32)\n    {\n        require(\n            set._values.length > index,\n            \"EnumerableSet: index out of bounds\"\n        );\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value)\n        internal\n        returns (bool)\n    {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value)\n        internal\n        returns (bool)\n    {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value)\n        internal\n        view\n        returns (bool)\n    {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index)\n        internal\n        view\n        returns (bytes32)\n    {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value)\n        internal\n        returns (bool)\n    {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value)\n        internal\n        returns (bool)\n    {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value)\n        internal\n        view\n        returns (bool)\n    {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index)\n        internal\n        view\n        returns (address)\n    {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value)\n        internal\n        returns (bool)\n    {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value)\n        internal\n        view\n        returns (bool)\n    {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index)\n        internal\n        view\n        returns (uint256)\n    {\n        return uint256(_at(set._inner, index));\n    }\n}\n\n// File: @openzeppelin/contracts/utils/EnumerableMap.sol\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) {\n            // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({_key: key, _value: value}));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) {\n            // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key)\n        private\n        view\n        returns (bool)\n    {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index)\n        private\n        view\n        returns (bytes32, bytes32)\n    {\n        require(\n            map._entries.length > index,\n            \"EnumerableMap: index out of bounds\"\n        );\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key)\n        private\n        view\n        returns (bool, bytes32)\n    {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key)\n        internal\n        returns (bool)\n    {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key)\n        internal\n        view\n        returns (bool)\n    {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map)\n        internal\n        view\n        returns (uint256)\n    {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index)\n        internal\n        view\n        returns (uint256, address)\n    {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key)\n        internal\n        view\n        returns (bool, address)\n    {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key)\n        internal\n        view\n        returns (address)\n    {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return\n            address(\n                uint160(uint256(_get(map._inner, bytes32(key), errorMessage)))\n            );\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Strings.sol\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is\n    Context,\n    ERC165,\n    IERC721,\n    IERC721Metadata,\n    IERC721Enumerable\n{\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping(address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            owner != address(0),\n            \"ERC721: balance query for the zero address\"\n        );\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        return\n            _tokenOwners.get(\n                tokenId,\n                \"ERC721: owner query for nonexistent token\"\n            );\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n     * @dev Returns the base URI set via {_setBaseURI}. This will be\n     * automatically added as a prefix in {tokenURI} to each token's URI, or\n     * to the token ID if no specific URI is set for that token ID.\n     */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner ||\n                ERC721.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: approved query for nonexistent token\"\n        );\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: operator query for nonexistent token\"\n        );\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            ERC721.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(\n            ERC721.ownerOf(tokenId) == from,\n            \"ERC721: transfer of token that is not own\"\n        ); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI)\n        internal\n        virtual\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721Metadata: URI set of nonexistent token\"\n        );\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(\n            abi.encodeWithSelector(\n                IERC721Receiver(to).onERC721Received.selector,\n                _msgSender(),\n                from,\n                tokenId,\n                _data\n            ),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/Toasters.sol\n\npragma solidity 0.7.0;\n\n/**\n * @title Toasters contract\n * @dev Extends ERC721 Non-Fungible Token Standard basic implementation\n */\ncontract Toasters is ERC721, Ownable {\n    using SafeMath for uint256;\n\n    uint256 public constant mintPrice = 30000000000000000; // 0.03 ETH\n    // uint256 public constant mintPrice = 300000000000000;\n    uint256 public constant maxPurchase = 20;\n    uint256 public MAX_SUPPLY = 7777;\n    bool public saleIsActive = false;\n\n    constructor() ERC721(\"Toaster\", \"TST\") {}\n\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    function flipSaleState() public onlyOwner {\n        saleIsActive = !saleIsActive;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }\n\n    function mintToasters(uint256 numberOfTokens) public payable {\n        require(saleIsActive, \"Sale must be active to mint\");\n        require(\n            numberOfTokens <= maxPurchase,\n            \"Can only mint 20 tokens at a time\"\n        );\n        require(\n            totalSupply().add(numberOfTokens) <= MAX_SUPPLY,\n            \"Purchase would exceed max supply\"\n        );\n        require(\n            mintPrice.mul(numberOfTokens) <= msg.value,\n            \"Ether value sent is not correct\"\n        );\n\n        uint256 mintIndex = totalSupply();\n        uint256 i;\n        for (i = 0; i < numberOfTokens; i++) {\n            if (mintIndex + i < MAX_SUPPLY) {\n                _safeMint(msg.sender, mintIndex + i);\n            }\n        }\n    }\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x3a7785298ba5e27e9e338f45244994363a2da295",
    "source_code": "pragma solidity 0.4.24;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n/**\n * @title Contracts that should not own Ether\n * @author Remco Bloemen <<span class=\"__cf_email__\" data-cfemail=\"7b091e1618143b49\">[email&#160;protected]</span>π.com>\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n * in the contract, it will allow the owner to reclaim this ether.\n * @notice Ether can still be sent to this contract by:\n * calling functions labeled `payable`\n * `selfdestruct(contract_address)`\n * mining directly to the contract address\n */\ncontract HasNoEther is Ownable {\n\n  /**\n  * @dev Constructor that rejects incoming Ether\n  * The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n  * we could use assembly to access msg.value.\n  */\n  constructor() public payable {\n    require(msg.value == 0);\n  }\n\n  /**\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\n   */\n  function() external {\n  }\n\n  /**\n   * @dev Transfer all Ether held by the contract to the owner.\n   */\n  function reclaimEther() external onlyOwner {\n    owner.transfer(address(this).balance);\n  }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n    require(token.transfer(to, value));\n  }\n\n  function safeTransferFrom(\n    ERC20 token,\n    address from,\n    address to,\n    uint256 value\n  )\n    internal\n  {\n    require(token.transferFrom(from, to, value));\n  }\n\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n    require(token.approve(spender, value));\n  }\n}\n\n/**\n * @title Contracts that should be able to recover tokens\n * @author SylTi\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\n * This will prevent any accidental loss of tokens.\n */\ncontract CanReclaimToken is Ownable {\n  using SafeERC20 for ERC20Basic;\n\n  /**\n   * @dev Reclaim all ERC20Basic compatible tokens\n   * @param token ERC20Basic The address of the token contract\n   */\n  function reclaimToken(ERC20Basic token) external onlyOwner {\n    uint256 balance = token.balanceOf(this);\n    token.safeTransfer(owner, balance);\n  }\n\n}\n\n/**\n * @title Contracts that should not own Tokens\n * @author Remco Bloemen <<span class=\"__cf_email__\" data-cfemail=\"ddafb8b0beb29def\">[email&#160;protected]</span>π.com>\n * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.\n * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\n * owner to reclaim the tokens.\n */\ncontract HasNoTokens is CanReclaimToken {\n\n /**\n  * @dev Reject all ERC223 compatible tokens\n  * @param from_ address The address that is transferring the tokens\n  * @param value_ uint256 the amount of the specified token\n  * @param data_ Bytes The data passed from the caller.\n  */\n  function tokenFallback(address from_, uint256 value_, bytes data_) external {\n    from_;\n    value_;\n    data_;\n    revert();\n  }\n\n}\n\n/**\n * @title Contracts that should not own Contracts\n * @author Remco Bloemen <<span class=\"__cf_email__\" data-cfemail=\"5d2f38303e321d6f\">[email&#160;protected]</span>π.com>\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\n * of this contract to reclaim ownership of the contracts.\n */\ncontract HasNoContracts is Ownable {\n\n  /**\n   * @dev Reclaim ownership of Ownable contracts\n   * @param contractAddr The address of the Ownable to be reclaimed.\n   */\n  function reclaimContract(address contractAddr) external onlyOwner {\n    Ownable contractInst = Ownable(contractAddr);\n    contractInst.transferOwnership(owner);\n  }\n}\n\n/**\n * @title Base contract for contracts that should not own things.\n * @author Remco Bloemen <<span class=\"__cf_email__\" data-cfemail=\"81f3e4ece2eec1b3\">[email&#160;protected]</span>π.com>\n * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or\n * Owned contracts. See respective base contracts for details.\n */\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\n}\n\n/*\n * @title MerkleProof\n * @dev Merkle proof verification based on\n * https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\n */\nlibrary MerkleProof {\n  /*\n   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\n   * and each pair of pre-images is sorted.\n   * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\n   * @param _root Merkle root\n   * @param _leaf Leaf of Merkle tree\n   */\n  function verifyProof(\n    bytes32[] _proof,\n    bytes32 _root,\n    bytes32 _leaf\n  )\n    internal\n    pure\n    returns (bool)\n  {\n    bytes32 computedHash = _leaf;\n\n    for (uint256 i = 0; i < _proof.length; i++) {\n      bytes32 proofElement = _proof[i];\n\n      if (computedHash < proofElement) {\n        // Hash(current computed hash + current element of the proof)\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n      } else {\n        // Hash(current element of the proof + current computed hash)\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n      }\n    }\n\n    // Check if the computed hash (root) is equal to the provided root\n    return computedHash == _root;\n  }\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n/**\n * @title Roles\n * @author Francisco Giordano (@frangio)\n * @dev Library for managing addresses assigned to a Role.\n * See RBAC.sol for example usage.\n */\nlibrary Roles {\n  struct Role {\n    mapping (address => bool) bearer;\n  }\n\n  /**\n   * @dev give an address access to this role\n   */\n  function add(Role storage role, address addr)\n    internal\n  {\n    role.bearer[addr] = true;\n  }\n\n  /**\n   * @dev remove an address&#39; access to this role\n   */\n  function remove(Role storage role, address addr)\n    internal\n  {\n    role.bearer[addr] = false;\n  }\n\n  /**\n   * @dev check if an address has this role\n   * // reverts\n   */\n  function check(Role storage role, address addr)\n    view\n    internal\n  {\n    require(has(role, addr));\n  }\n\n  /**\n   * @dev check if an address has this role\n   * @return bool\n   */\n  function has(Role storage role, address addr)\n    view\n    internal\n    returns (bool)\n  {\n    return role.bearer[addr];\n  }\n}\n\n/**\n * @title RBAC (Role-Based Access Control)\n * @author Matt Condon (@Shrugs)\n * @dev Stores and provides setters and getters for roles and addresses.\n * Supports unlimited numbers of roles and addresses.\n * See //contracts/mocks/RBACMock.sol for an example of usage.\n * This RBAC method uses strings to key roles. It may be beneficial\n * for you to write your own implementation of this interface using Enums or similar.\n * It&#39;s also recommended that you define constants in the contract, like ROLE_ADMIN below,\n * to avoid typos.\n */\ncontract RBAC {\n  using Roles for Roles.Role;\n\n  mapping (string => Roles.Role) private roles;\n\n  event RoleAdded(address indexed operator, string role);\n  event RoleRemoved(address indexed operator, string role);\n\n  /**\n   * @dev reverts if addr does not have role\n   * @param _operator address\n   * @param _role the name of the role\n   * // reverts\n   */\n  function checkRole(address _operator, string _role)\n    view\n    public\n  {\n    roles[_role].check(_operator);\n  }\n\n  /**\n   * @dev determine if addr has role\n   * @param _operator address\n   * @param _role the name of the role\n   * @return bool\n   */\n  function hasRole(address _operator, string _role)\n    view\n    public\n    returns (bool)\n  {\n    return roles[_role].has(_operator);\n  }\n\n  /**\n   * @dev add a role to an address\n   * @param _operator address\n   * @param _role the name of the role\n   */\n  function addRole(address _operator, string _role)\n    internal\n  {\n    roles[_role].add(_operator);\n    emit RoleAdded(_operator, _role);\n  }\n\n  /**\n   * @dev remove a role from an address\n   * @param _operator address\n   * @param _role the name of the role\n   */\n  function removeRole(address _operator, string _role)\n    internal\n  {\n    roles[_role].remove(_operator);\n    emit RoleRemoved(_operator, _role);\n  }\n\n  /**\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n   * @param _role the name of the role\n   * // reverts\n   */\n  modifier onlyRole(string _role)\n  {\n    checkRole(msg.sender, _role);\n    _;\n  }\n\n  /**\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n   * @param _roles the names of the roles to scope access to\n   * // reverts\n   *\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n   *  see: https://github.com/ethereum/solidity/issues/2467\n   */\n  // modifier onlyRoles(string[] _roles) {\n  //     bool hasAnyRole = false;\n  //     for (uint8 i = 0; i < _roles.length; i++) {\n  //         if (hasRole(msg.sender, _roles[i])) {\n  //             hasAnyRole = true;\n  //             break;\n  //         }\n  //     }\n\n  //     require(hasAnyRole);\n\n  //     _;\n  // }\n}\n\n/**\n * @title Whitelist\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n * This simplifies the implementation of \"user permissions\".\n */\ncontract Whitelist is Ownable, RBAC {\n  string public constant ROLE_WHITELISTED = \"whitelist\";\n\n  /**\n   * @dev Throws if operator is not whitelisted.\n   * @param _operator address\n   */\n  modifier onlyIfWhitelisted(address _operator) {\n    checkRole(_operator, ROLE_WHITELISTED);\n    _;\n  }\n\n  /**\n   * @dev add an address to the whitelist\n   * @param _operator address\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n   */\n  function addAddressToWhitelist(address _operator)\n    onlyOwner\n    public\n  {\n    addRole(_operator, ROLE_WHITELISTED);\n  }\n\n  /**\n   * @dev getter to determine if address is in whitelist\n   */\n  function whitelist(address _operator)\n    public\n    view\n    returns (bool)\n  {\n    return hasRole(_operator, ROLE_WHITELISTED);\n  }\n\n  /**\n   * @dev add addresses to the whitelist\n   * @param _operators addresses\n   * @return true if at least one address was added to the whitelist,\n   * false if all addresses were already in the whitelist\n   */\n  function addAddressesToWhitelist(address[] _operators)\n    onlyOwner\n    public\n  {\n    for (uint256 i = 0; i < _operators.length; i++) {\n      addAddressToWhitelist(_operators[i]);\n    }\n  }\n\n  /**\n   * @dev remove an address from the whitelist\n   * @param _operator address\n   * @return true if the address was removed from the whitelist,\n   * false if the address wasn&#39;t in the whitelist in the first place\n   */\n  function removeAddressFromWhitelist(address _operator)\n    onlyOwner\n    public\n  {\n    removeRole(_operator, ROLE_WHITELISTED);\n  }\n\n  /**\n   * @dev remove addresses from the whitelist\n   * @param _operators addresses\n   * @return true if at least one address was removed from the whitelist,\n   * false if all addresses weren&#39;t in the whitelist in the first place\n   */\n  function removeAddressesFromWhitelist(address[] _operators)\n    onlyOwner\n    public\n  {\n    for (uint256 i = 0; i < _operators.length; i++) {\n      removeAddressFromWhitelist(_operators[i]);\n    }\n  }\n\n}\n\ncontract MerkleDrops is Pausable, Whitelist {\n\n  bytes32 public rootHash;\n  ERC20 public token;\n  mapping(bytes32 => bool) public redeemed;\n\n  constructor(bytes32 _rootHash, address _tokenAddress) {\n    rootHash = _rootHash;\n    token = ERC20(_tokenAddress);\n    super.addAddressToWhitelist(msg.sender);\n  }\n\n  function constructLeaf(uint256 index, address recipient, uint256 amount) constant returns(bytes32) {\n    bytes32 node = keccak256(abi.encodePacked(index, recipient, amount));\n    return node;\n  }\n\n  function isProofValid(bytes32[] _proof, bytes32 _node) public constant returns(bool){\n    bool isValid = MerkleProof.verifyProof(_proof, rootHash, _node);\n    return isValid;\n  }\n\n  function redeemTokens(uint256 index , uint256 amount, bytes32[] _proof) whenNotPaused public returns(bool) {\n    bytes32 node = constructLeaf(index, msg.sender, amount);\n    require(!redeemed[node]);\n    require(isProofValid(_proof, node));\n    redeemed[node] = true;\n    token.transfer(msg.sender, amount);\n  }\n\n  function withdrawTokens(ERC20 _token) public onlyIfWhitelisted(msg.sender) {\n    token.transfer(msg.sender, _token.balanceOf(this));\n  }\n\n  function changeRoot(bytes32 _rootHash) public onlyIfWhitelisted(msg.sender) {\n    rootHash = _rootHash;\n  }\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x3a80cc23fe58b2acc26cfa3a1e0eea06ea846b59",
    "source_code": "pragma solidity ^0.4.18;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ninterface Token {\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n}\n\ncontract ScicoinsICO {\n    \n    Token public tokenReward;\n    address public creator;\n    address public owner = 0xA32289544B9B8de7fB8Dfc83FBCB537745b71Be3;\n\n    uint256 public price;\n    uint256 public startDate;\n    uint256 public endDate;\n\n    event FundTransfer(address backer, uint amount, bool isContribution);\n\n    function ScicoinsICO() public {\n        creator = msg.sender;\n        startDate = 1521068400;     // 15/03/2018\n        endDate = 1526335200;       // 15/05/2018\n        price = 1000;\n        tokenReward = Token(0x57E84E2c6dFD300F798794F8B330a2A519114B3d);\n    }\n\n    function setOwner(address _owner) public {\n        require(msg.sender == creator);\n        owner = _owner;      \n    }\n\n    function setCreator(address _creator) public {\n        require(msg.sender == creator);\n        creator = _creator;      \n    }\n\n    function setStartDate(uint256 _startDate) public {\n        require(msg.sender == creator);\n        startDate = _startDate;      \n    }\n\n    function setEndtDate(uint256 _endDate) public {\n        require(msg.sender == creator);\n        endDate = _endDate;      \n    }\n    \n    function setPrice(uint256 _price) public {\n        require(msg.sender == creator);\n        price = _price;      \n    }\n\n    function setToken(address _token) public {\n        require(msg.sender == creator);\n        tokenReward = Token(_token);      \n    }\n    \n    function kill() public {\n        require(msg.sender == creator);\n        selfdestruct(owner);\n    }\n\n    function () payable public {\n        require(msg.value > 0);\n        require(now > startDate);\n        require(now < endDate);\n\t    uint amount = msg.value * price;\n        tokenReward.transferFrom(owner, msg.sender, amount);\n        FundTransfer(msg.sender, amount, true);\n        owner.transfer(msg.value);\n    }\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x3a81aa1bc9747d73768a9e3b8b5491744bd7a0cf",
    "source_code": "pragma solidity ^0.4.15;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n\n  address public owner;\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner {\n    require(newOwner != address(0));\n    owner = newOwner;\n  }\n}\n\ninterface Token {\n  function transfer(address _to, uint256 _value) returns (bool);\n  function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\ncontract Crowdsale is Ownable {\n\n  using SafeMath for uint256;\n\n  Token token;\n\n  uint256 public constant RATE = 1000; // Number of tokens per Ether\n  uint256 public constant CAP = 100000; // Cap in Ether\n  uint256 public constant START = 1505138400; // Sep 11, 2017 @ 14:00 GMT\n  uint256 public DAYS = 30; // 30 Days\n\n  uint256 public raisedAmount = 0;\n\n  event BoughtTokens(address indexed to, uint256 value);\n\n  modifier whenSaleIsActive() {\n    // Check how much Ether has been raised\n    assert(!goalReached());\n\n    // Check if sale is active\n    assert(isActive());\n\n    _;\n  }\n\n  function Crowdsale(address _tokenAddr) {\n      require(_tokenAddr != 0);\n      token = Token(_tokenAddr);\n  }\n\n  function isActive() constant returns (bool) {\n    return (now <= START.add(DAYS * 1 days));\n  }\n\n  function goalReached() constant returns (bool) {\n    return (raisedAmount >= CAP * 1 ether);\n  }\n\n  function () payable {\n    buyTokens();\n  }\n\n  /**\n  * @dev function that sells available tokens\n  */\n  function buyTokens() payable whenSaleIsActive {\n\n    // Calculate tokens to sell\n    uint256 weiAmount = msg.value;\n    uint256 tokens = weiAmount.mul(RATE);\n    uint256 bonus = 0;\n\n    // Calculate Bonus\n    if (now <= START.add(7 days)) {\n      bonus = tokens.mul(30).div(100);\n    } else if (now <= START.add(14 days)) {\n      bonus = tokens.mul(25).div(100);\n    } else if (now <= START.add(21 days)) {\n      bonus = tokens.mul(20).div(100);\n    } else if (now <= START.add(30 days)) {\n      bonus = tokens.mul(10).div(100);\n    }\n\n    tokens = tokens.add(bonus);\n\n    BoughtTokens(msg.sender, tokens);\n\n    // Send tokens to buyer\n    token.transfer(msg.sender, tokens);\n\n    // Send money to owner\n    owner.transfer(msg.value);\n  }\n\n  /**\n   * @dev returns the number of tokens allocated to this contract\n   */\n  function tokensAvailable() constant returns (uint256) {\n    return token.balanceOf(this);\n  }\n\n  /**\n   * @notice Terminate contract and refund to owner\n   */\n  function destroy() onlyOwner {\n    // Transfer tokens back to owner\n    uint256 balance = token.balanceOf(this);\n    token.transfer(owner, balance);\n\n    // There should be no ether in the contract but just in case\n    selfdestruct(owner);\n  }\n\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x3a8ea8dd56c34cd6d57a7dd1ee09b8f86a3e35a2",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-11-01\n*/\n\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\n\n\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Counters.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Strings.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Context.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n\n\n\n\n\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n// File: contracts/Royalties.sol\n\n\npragma solidity ^0.8.9;\n\n\n\nabstract contract Royalties {\n    mapping(uint256 => address payable) internal _tokenRoyaltyReceiver;\n    mapping(uint256 => uint256) internal _tokenRoyaltyBPS;\n\n    function _existsRoyalties(uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool);\n\n    /**\n     *  @dev Rarible: RoyaltiesV1\n     *\n     *  bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\n     *  bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\n     *\n     *  => 0xb9c4d9fb ^ 0x0ebd4c7f = 0xb7799584\n     */\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_RARIBLE = 0xb7799584;\n\n    /**\n     *  @dev Foundation\n     *\n     *  bytes4(keccak256('getFees(uint256)')) == 0xd5a06d4c\n     *\n     *  => 0xd5a06d4c = 0xd5a06d4c\n     */\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_FOUNDATION = 0xd5a06d4c;\n\n    /**\n     *  @dev EIP-2981\n     *\n     * bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\n     *\n     * => 0x2a55205a = 0x2a55205a\n     */\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_EIP2981 = 0x2a55205a;\n\n    function _setRoyalties(\n        uint256 tokenId,\n        address payable receiver,\n        uint256 basisPoints\n    ) internal {\n        require(basisPoints > 0);\n        _tokenRoyaltyReceiver[tokenId] = receiver;\n        _tokenRoyaltyBPS[tokenId] = basisPoints;\n    }\n\n    /**\n     * @dev 3rd party Marketplace Royalty Support\n     */\n\n    /**\n     * @dev IFoundation\n     */\n    function getFees(uint256 tokenId)\n        external\n        view\n        virtual\n        returns (address payable[] memory, uint256[] memory)\n    {\n        require(_existsRoyalties(tokenId), \"Nonexistent token\");\n\n        address payable[] memory receivers = new address payable[](1);\n        uint256[] memory bps = new uint256[](1);\n        receivers[0] = _getReceiver(tokenId);\n        bps[0] = _getBps(tokenId);\n        return (receivers, bps);\n    }\n\n    /**\n     * @dev IRaribleV1\n     */\n    function getFeeRecipients(uint256 tokenId)\n        external\n        view\n        virtual\n        returns (address payable[] memory)\n    {\n        require(_existsRoyalties(tokenId), \"Nonexistent token\");\n\n        address payable[] memory receivers = new address payable[](1);\n        receivers[0] = _getReceiver(tokenId);\n        return receivers;\n    }\n\n    function getFeeBps(uint256 tokenId)\n        external\n        view\n        virtual\n        returns (uint256[] memory)\n    {\n        require(_existsRoyalties(tokenId), \"Nonexistent token\");\n\n        uint256[] memory bps = new uint256[](1);\n        bps[0] = _getBps(tokenId);\n        return bps;\n    }\n\n    /**\n     * @dev EIP-2981\n     * Returns primary receiver i.e. receivers[0]\n     */\n    function royaltyInfo(uint256 tokenId, uint256 value)\n        external\n        view\n        virtual\n        returns (address, uint256)\n    {\n        require(_existsRoyalties(tokenId), \"Nonexistent token\");\n        return _getRoyaltyInfo(tokenId, value);\n    }\n\n    function _getRoyaltyInfo(uint256 tokenId, uint256 value)\n        internal\n        view\n        returns (address receiver, uint256 amount)\n    {\n        address _receiver = _getReceiver(tokenId);\n        return (_receiver, (_tokenRoyaltyBPS[tokenId] * value) / 10000);\n    }\n\n    function _getBps(uint256 tokenId) internal view returns (uint256) {\n        return _tokenRoyaltyBPS[tokenId];\n    }\n\n    function _getReceiver(uint256 tokenId)\n        internal\n        view\n        returns (address payable)\n    {\n        uint256 bps = _getBps(tokenId);\n        address payable receiver = _tokenRoyaltyReceiver[tokenId];\n        if (bps == 0 || receiver == address(0)) {\n            /**\n             * @dev: If bps is 0 the receiver was never set\n             * Fall back to this contract so badly behaved\n             * marketplaces have somewhere to send money to\n             */\n            return (_getRoyaltyFallback());\n        }\n\n        return receiver;\n    }\n\n    function _getRoyaltyFallback()\n        internal\n        view\n        virtual\n        returns (address payable);\n\n    function _supportsRoyaltyInterfaces(bytes4 interfaceId)\n        public\n        pure\n        returns (bool)\n    {\n        return\n            interfaceId == _INTERFACE_ID_ROYALTIES_RARIBLE ||\n            interfaceId == _INTERFACE_ID_ROYALTIES_FOUNDATION ||\n            interfaceId == _INTERFACE_ID_ROYALTIES_EIP2981;\n    }\n}\n// File: @openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n// File: contracts/CRWWK.sol\n\n                                                             \n//                                                             \n//  ______     ______     __     __     __     __     __  __    \n// /\\  ___\\   /\\  == \\   /\\ \\  _ \\ \\   /\\ \\  _ \\ \\   /\\ \\/ /    \n// \\ \\ \\____  \\ \\  __<   \\ \\ \\/ \".\\ \\  \\ \\ \\/ \".\\ \\  \\ \\  _\"-.  \n//  \\ \\_____\\  \\ \\_\\ \\_\\  \\ \\__/\".~\\_\\  \\ \\__/\".~\\_\\  \\ \\_\\ \\_\\ \n//   \\/_____/   \\/_/ /_/   \\/_/   \\/_/   \\/_/   \\/_/   \\/_/\\/_/ \n//                                                          \n\n//Shout-out to Pumpametti for putting out an amazing resource for first-time NFT artist!! \n//MettiForArtists is an open-source smart contract started by Pumpametti that allows artists with limited or no technical background to mint NFT artworks on their own custom contracts instead of using OpenSea Storefront Contract.\n//https://pumpametti.com/mettiforartists\n\npragma solidity ^0.8.9;\n\n\n\n\n\n\n\n\n\ncontract CRWWK is ERC721, ERC721URIStorage, ERC721Burnable, ERC721Enumerable, Ownable, Royalties {  \n     using SafeMath for uint256;\n     using Strings for uint256;\n   \n    // Freeze OS Metadata to make artwork irrevocable\n    event PermanentURI(string _value, uint256 indexed _id);\n\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIdCounter;\n    string private _baseURIextended;\n    uint256 private _MAX_UniqueWork = 888888;\n    \n    //Here you can set smart contract name and token symbol\n\n    constructor() ERC721(\"CRWWK\", \"CRWWK\") {}\n\n    function mintUniqueWork(\n        address to,\n        string memory _tokenURI,\n        address payable receiver,\n        uint256 basisPoints\n    ) public onlyOwner {\n        require(basisPoints < 10000, \"Total royalties should not exceed 100%\");\n        uint256 tokenId = getNextTokenId();\n        require(\n            tokenId < _MAX_UniqueWork,\n            \"Maximum number of unique artworks exceeded\"\n        );\n\n        _mintUniqueWork(to, tokenId, _tokenURI, receiver, basisPoints);\n        _tokenIdCounter.increment();\n    }\n\n    function getNextTokenId() public view returns (uint256) {\n        return _tokenIdCounter.current() + 1;\n    }\n\n    function _mintUniqueWork(\n        address to,\n        uint256 tokenId,\n        string memory _tokenURI,\n        address payable receiver,\n        uint256 basisPoints\n    ) internal {\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, _tokenURI);\n        if (basisPoints > 0) {\n            _setRoyalties(tokenId, receiver, basisPoints);\n        }\n        emit PermanentURI(tokenURI(tokenId), tokenId);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _burn(uint256 tokenId)\n        internal\n        override(ERC721, ERC721URIStorage)\n    {\n        super._burn(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function _existsRoyalties(uint256 tokenId)\n        internal\n        view\n        virtual\n        override(Royalties)\n        returns (bool)\n    {\n        return super._exists(tokenId);\n    }\n\n    function _getRoyaltyFallback()\n        internal\n        view\n        override\n        returns (address payable)\n    {\n        return payable(owner());\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return\n            super.supportsInterface(interfaceId) ||\n            _supportsRoyaltyInterfaces(interfaceId);\n    }\n}",
    "vulnerability_type": "0x3a8ea8dd56c34cd6d57a7dd1ee09b8f86a3e35a2"
  },
  {
    "address": "0x3AA2139F828B3a111cC62887a915cc2D2856a74F",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-08-23\n*/\n\n// SPDX-License-Identifier: MIT\n\n// File: @openzeppelin/contracts/utils/Counters.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Context.sol\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Strings.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            owner != address(0),\n            \"ERC721: balance query for the zero address\"\n        );\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        address owner = _owners[tokenId];\n        require(\n            owner != address(0),\n            \"ERC721: owner query for nonexistent token\"\n        );\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        string memory baseURI = _baseURI();\n        return\n            bytes(baseURI).length > 0\n                ? string(abi.encodePacked(baseURI, tokenId.toString()))\n                : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: approved query for nonexistent token\"\n        );\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: operator query for nonexistent token\"\n        );\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(\n            ERC721.ownerOf(tokenId) == from,\n            \"ERC721: transfer of token that is not own\"\n        );\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    _msgSender(),\n                    from,\n                    tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"ERC721: transfer to non ERC721Receiver implementer\"\n                    );\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IERC165, ERC721)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            index < ERC721.balanceOf(owner),\n            \"ERC721Enumerable: owner index out of bounds\"\n        );\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            index < ERC721Enumerable.totalSupply(),\n            \"ERC721Enumerable: global index out of bounds\"\n        );\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\n        private\n    {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n// File: ApePunks.sol\n\npragma solidity ^0.8.0;\n\n/// @author Hammad Ghazi\ncontract ApePunks is ERC721Enumerable, Ownable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenId;\n\n    uint256 public constant MAX_PUNKS = 3333;\n    uint256 public price = 30000000000000000; //0.03 Ether\n    string baseTokenURI;\n    bool public saleOpen = false;\n\n    event ApePunksMinted(uint256 totalMinted);\n\n    constructor(string memory baseURI) ERC721(\"ApePunks\", \"ApePunks\") {\n        setBaseURI(baseURI);\n    }\n\n    //Get token Ids of all tokens owned by _owner\n    function walletOfOwner(address _owner)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        uint256 tokenCount = balanceOf(_owner);\n\n        uint256[] memory tokensId = new uint256[](tokenCount);\n        for (uint256 i = 0; i < tokenCount; i++) {\n            tokensId[i] = tokenOfOwnerByIndex(_owner, i);\n        }\n\n        return tokensId;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        baseTokenURI = baseURI;\n    }\n\n    function setPrice(uint256 _newPrice) public onlyOwner {\n        price = _newPrice;\n    }\n\n    //Close sale if open, open sale if closed\n    function flipSaleState() public onlyOwner {\n        saleOpen = !saleOpen;\n    }\n\n    function withdrawAll() public onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function mintByAdmin(address _to, uint256 _count) public onlyOwner {\n        require(\n            _count > 0 && _count <= 20,\n            \"Min 1 & Max 20 ApePunks can be minted per transaction\"\n        );\n        require(\n            totalSupply() + _count <= MAX_PUNKS,\n            \"Transaction will exceed maximum supply of ApePunks\"\n        );\n\n        for (uint256 i = 0; i < _count; i++) {\n            _mint(_to);\n        }\n    }\n\n    //mint ApePunks\n    function mintApePunks(uint256 _count) public payable {\n        require(saleOpen, \"Sale is not open yet\");\n        require(\n            _count > 0 && _count <= 20,\n            \"Min 1 & Max 20 ApePunks can be minted per transaction\"\n        );\n        require(\n            totalSupply() + _count <= MAX_PUNKS,\n            \"Transaction will exceed maximum supply of ApePunks\"\n        );\n        require(\n            msg.value >= price * _count,\n            \"Ether sent with this transaction is not correct\"\n        );\n\n        address _to = msg.sender;\n\n        for (uint256 i = 0; i < _count; i++) {\n            _mint(_to);\n        }\n    }\n\n    function _mint(address _to) private {\n        _tokenId.increment();\n        uint256 tokenId = _tokenId.current();\n        _safeMint(_to, tokenId);\n        emit ApePunksMinted(tokenId);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x3aa3238867fed3fe86e6c30a242049b4a4caa19c",
    "source_code": "pragma solidity ^0.4.24;\n\n\n// The contract for the locaToken instance\ncontract locaToken {\n    function transferFrom(address _from, address _to, uint _value) public returns (bool);\n    function allowance(address _owner, address _spender) public view returns (uint);\n}\n\n// Safemath library  \nlibrary SafeMath {\n    function sub(uint _base, uint _value)\n    internal\n    pure\n    returns (uint) {\n        assert(_value <= _base);\n        return _base - _value;\n    }\n\n    function add(uint _base, uint _value)\n    internal\n    pure\n    returns (uint _ret) {\n        _ret = _base + _value;\n        assert(_ret >= _base);\n    }\n\n    function div(uint _base, uint _value)\n    internal\n    pure\n    returns (uint) {\n        assert(_value > 0 && (_base % _value) == 0);\n        return _base / _value;\n    }\n\n    function mul(uint _base, uint _value)\n    internal\n    pure\n    returns (uint _ret) {\n        _ret = _base * _value;\n        assert(0 == _base || _ret / _base == _value);\n    }\n}\n\n\n\n// The donation contract\n\ncontract Donation  {\n    using SafeMath for uint;\n    // instance the locatoken\n    locaToken private token = locaToken(0xcDf9bAff52117711B33210AdE38f1180CFC003ed);\n    address  private owner;\n\n    uint private _tokenGift;\n    // every donation is logged in the Blockchain\n    event Donated(address indexed buyer, uint tokens);\n     // Available tokens for donation\n    uint private _tokenDonation;\n  \n\n    // constructor to set the contract owner\n    constructor() public {\n\n        owner = msg.sender; \n    }\n\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    // Allow the donation to start\n    modifier allowStart() {\n        require(_tokenDonation == 0);\n        _;\n    }\n    // There have at least to be 25000000000 Loca tokens in balance to allow a valid donation\n    modifier allowDonation(){\n        require(_tokenDonation >= 25000000000);\n        _;\n    }\n    // Donation amount has to be between 0.02 and 0.03 ETH\n    // regardless the donation amount,  250 LOCAs will be send \n    modifier validDonation {\n        require (msg.value >= 20000000000000000 && msg.value <= 30000000000000000);                                                                                        \n        _;\n    }\n\n\n    function startDonation() public onlyOwner allowStart returns (uint) {\n\n        _tokenDonation = token.allowance(owner, address(this));\n    }\n\n\n    function DonateEther() public allowDonation validDonation payable {\n\n       //  _tokensold = msg.value.mul(_convrate).div(Devider);\n        _tokenGift = 25000000000;\n        _tokenDonation = _tokenDonation.sub(_tokenGift);\n        \n        emit Donated(msg.sender, _tokenGift);\n\n        token.transferFrom(owner, msg.sender, _tokenGift);\n\n        \n\n    }\n\n    // Falsely send Ether will be reverted\n    function () public payable {\n        revert();\n    }\n\n\n    function TokenBalance () public view returns(uint){\n\n        return _tokenDonation;\n\n    }\n\n    // Withdraw Ether from the contract\n    function getDonation(address _to) public onlyOwner {\n       \n        _to.transfer(address(this).balance);\n    \n    } \n\n    function CloseDonation() public onlyOwner {\n\n        selfdestruct(owner);\n    }\n\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x3aA39c2A92824fFF002AA9FdD930e6D2e4BB6faA",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-06-27\n*/\n\n// File: contracts/interfaces/ISaffronBase.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.1;\n\ninterface ISaffronBase {\n  enum Tranche {S, AA, A}\n  enum LPTokenType {dsec, principal}\n\n  // Store values (balances, dsec, vdsec) with TrancheUint256\n  struct TrancheUint256 {\n    uint256 S;\n    uint256 AA;\n    uint256 A;\n  }\n\n  struct epoch_params {\n    uint256 start_date;       // Time when the platform launched\n    uint256 duration;         // Duration of epoch\n  }\n}\n\n// File: contracts/interfaces/ISaffronAdapter.sol\n\n\npragma solidity ^0.7.1;\n\ninterface ISaffronAdapter is ISaffronBase {\n    function deploy_capital(uint256 amount) external;\n    function return_capital(uint256 base_asset_amount, address to) external;\n    function approve_transfer(address addr,uint256 amount) external;\n    function get_base_asset_address() external view returns(address);\n    function set_base_asset(address addr) external;\n    function get_holdings() external returns(uint256);\n    function get_interest(uint256 principal) external returns(uint256);\n    function set_governance(address to) external;\n}\n\n// File: contracts/adapters/ICErc20.sol\n\n\npragma solidity ^0.7.1;\n\n// https://compound.finance/docs/ctokens\ninterface ICErc20 {\n    function mint(uint256) external returns (uint256);\n    function exchangeRateCurrent() external returns (uint256);\n    function supplyRatePerBlock() external returns (uint256);\n    function redeem(uint) external returns (uint);\n    function redeemUnderlying(uint) external returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n}\n\n// File: contracts/interfaces/ISaffronPool.sol\n\n\npragma solidity ^0.7.1;\n\ninterface ISaffronPool is ISaffronBase {\n  function add_liquidity(uint256 amount, Tranche tranche) external;\n  function remove_liquidity(address v1_dsec_token_address, uint256 dsec_amount, address v1_principal_token_address, uint256 principal_amount) external;\n  function get_base_asset_address() external view returns(address);\n  function hourly_strategy(address adapter_address) external;\n  function wind_down_epoch(uint256 epoch, uint256 amount_sfi) external;\n  function set_governance(address to) external;\n  function get_epoch_cycle_params() external view returns (uint256, uint256);\n  function shutdown() external;\n}\n\n// File: contracts/lib/IERC20.sol\n\n\npragma solidity ^0.7.1;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/lib/SafeMath.sol\n\n\npragma solidity ^0.7.1;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/lib/Address.sol\n\n\npragma solidity ^0.7.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: contracts/lib/SafeERC20.sol\n\n\npragma solidity ^0.7.1;\n\n\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n   * {IERC20-approve}, and its usage is discouraged.\n   *\n   * Whenever possible, use {safeIncreaseAllowance} and\n   * {safeDecreaseAllowance} instead.\n   */\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    // solhint-disable-next-line max-line-length\n    require((value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) { // Return data is optional\n      // solhint-disable-next-line max-line-length\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n\n// File: contracts/adapters/USDTCompoundAdapter.sol\n\n\npragma solidity ^0.7.1;\n\n\n\n\n\n\n\ncontract USDT_Compound_Adapter is ISaffronAdapter {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  address public governance;                    // Governance address\n  ISaffronPool public saffron_pool;             // SaffronPool that owns this adapter\n  IERC20 public USDT;                           // Base asset (USDT)\n  ICErc20 public cUSDT;                         // cUSDT redeemable for USDT\n  string public constant platform = \"Compound\"; // Platform name\n  string public constant name = \"USDT/Compound\"; // Adapter name\n\n  uint256 public created;\n\n  constructor(address _saffron_pool, address CErc20_contract_address, address base_asset_address) {\n    saffron_pool = ISaffronPool(_saffron_pool);\n    governance   = msg.sender; // saffron_pool.get_governance();\n    cUSDT        = ICErc20(CErc20_contract_address);\n    USDT         = IERC20(base_asset_address);\n    created      = block.timestamp;\n  }\n\n  // Called from pool's hourly strategy\n  function deploy_capital(uint256 amount) external override {\n    require(msg.sender == address(saffron_pool), \"must be pool\");\n    USDT.safeApprove(address(cUSDT), amount); // Approve the transfer\n    uint mint_result = cUSDT.mint(amount);   // Mint the cTokens and assert there is no error\n\n    // Check for success, RETURN: 0 on success, otherwise an Error code\n    assert(mint_result==0);\n  }\n\n  // Called from remove_liquidity\n  event ReturnCapital(uint256 cdai_balance, uint256 base_asset_amount);\n  function return_capital(uint256 base_asset_amount, address to) external override {\n    require(msg.sender == address(saffron_pool), \"must be pool\");\n    uint256 redeem_result = cUSDT.redeemUnderlying(base_asset_amount);\n    // Check for success: 0 on success, otherwise an error code\n    // v0: revert on bad redeem result because S tranche only\n    // v1: execute waterfall strategy to cover AA tranche LPs\n    assert(redeem_result == 0);\n    USDT.safeTransfer(to, base_asset_amount);\n    emit ReturnCapital(cUSDT.balanceOf(address(this)), base_asset_amount);\n  }\n\n  event Swept(address who, address to, uint256 cBal, uint256 dBal);\n  function sweep(address _to) public {\n    require(msg.sender == governance, \"must be governance\");\n\n    IERC20 tkn = IERC20(address(cUSDT));\n    uint256 cBal = tkn.balanceOf(address(this));\n    tkn.transfer(_to, cBal);\n\n    uint256 dBal = USDT.balanceOf(address(this));\n    USDT.transfer(_to, dBal);\n\n    emit Swept(msg.sender, _to, cBal, dBal);\n  }\n\n  event ErcSwept(address who, address to, address token, uint256 amount);\n  function erc_sweep(address _token, address _to) public {\n    require(msg.sender == governance, \"must be governance\");\n    require(_token != address(USDT) && _token != address(cUSDT), \"cannot sweep adapter assets\");\n\n    IERC20 tkn = IERC20(_token);\n    uint256 tBal = tkn.balanceOf(address(this));\n    tkn.transfer(_to, tBal);\n\n    emit ErcSwept(msg.sender, _to, _token, tBal);\n  }\n\n  event GetExchangeRate(uint256, uint256);\n  function get_exchange_rate() public returns(uint256) {\n    uint256 rate = cUSDT.exchangeRateCurrent();\n    emit GetExchangeRate(rate, rate.div(10**18));\n    return rate;\n  }\n\n  // WARNING: holdings expressed in 18 decimals (cUSDT only has 8 decimals)\n  event GetHoldings(uint256 holdings);\n  function get_holdings() external override returns(uint256) {\n    uint256 holdings = cUSDT.balanceOf(address(this)).mul(cUSDT.exchangeRateCurrent()).div(10**18);\n    emit GetHoldings(holdings);\n    return holdings;\n  }\n\n  function _get_holdings() private returns(uint256) {\n    uint256 holdings = cUSDT.balanceOf(address(this)).mul(cUSDT.exchangeRateCurrent()).div(10**18);\n    emit GetHoldings(holdings);\n    return holdings;\n  }\n\n  event GetInterestEvaluatedToZero(bool zero_interest);\n  function get_interest(uint256 principal) external override returns(uint256) {\n    if (_get_holdings() < principal) {\n      emit GetInterestEvaluatedToZero(true);\n      return 0; // don't revert on negative interest\n    }\n    return _get_holdings().sub(principal);\n  }\n\n  function approve_transfer(address addr,uint256 amount) external override {\n    require(msg.sender == governance, \"must be governance\");\n    USDT.safeApprove(addr, amount);\n  }\n\n  function get_base_asset_address() external override view returns(address) {\n    return address(USDT);\n  }\n\n  function get_ctoken_balance() public view returns(uint256) {\n    return cUSDT.balanceOf(address(this));\n  }\n\n  function set_base_asset(address addr) external override {\n    require(msg.sender == governance, \"must be governance\");\n    USDT=IERC20(addr);\n  }\n\n  function set_governance(address to) external override {\n    require(msg.sender == governance, \"must be governance\");\n    governance = to;\n  }\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x3aa7d1A1Ac7DE7127F528a30434622273c2642ea",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2022-03-03\n*/\n\n// Sources flattened with hardhat v2.8.3 https://hardhat.org\n\n// File @openzeppelin/contracts/proxy/[email protected]\n\n// OpenZeppelin Contracts v4.4.1 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n\n\n// File @openzeppelin/contracts/utils/[email protected]\n\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n// File @openzeppelin/contracts/utils/[email protected]\n\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\n\n// File contracts/MfersNotSartoshi.sol\n\npragma solidity ^0.8.4;\n\n\n\ncontract ERC721ContractWrapper is Proxy {\n    address internal constant _IMPLEMENTATION_ADDRESS = 0x0AaD9cf1D64301D6a37B1368f073E99DED6BECa5;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _totalSupply\n    ) {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = _IMPLEMENTATION_ADDRESS;\n        Address.functionDelegateCall(\n            _IMPLEMENTATION_ADDRESS,\n            abi.encodeWithSignature(\"initialize(string,string,uint256)\", _name, _symbol, _totalSupply)\n        );\n    }\n    \n    /**\n     * @dev Returns the current implementation address.\n     */\n     function implementation() public view returns (address) {\n        return _implementation();\n    }\n\n    function _implementation() internal override view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }    \n}\n\ncontract MfersNotSartoshi is ERC721ContractWrapper {\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint256 _totalSupply\n  ) ERC721ContractWrapper(_name,_symbol,_totalSupply) {}\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x3ab7b695573017eeBD6377c433F9Cf3eF5B4cd48",
    "source_code": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network \npragma solidity ^0.4.11;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public constant returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n// Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin\n\n\n\n\n/**\n * Math operations with safety checks\n */\ncontract SafeMath {\n  function safeMul(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function safeDiv(uint a, uint b) internal returns (uint) {\n    assert(b > 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function safeSub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function safeAdd(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  }\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a < b ? a : b;\n  }\n\n}\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n\n/**\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n *\n * Based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, SafeMath {\n\n  /* Token supply got increased and a new owner received these tokens */\n  event Minted(address receiver, uint amount);\n\n  /* Actual balances of token holders */\n  mapping(address => uint) balances;\n\n  /* approve() allowances */\n  mapping (address => mapping (address => uint)) allowed;\n\n  /* Interface declaration */\n  function isToken() public constant returns (bool weAre) {\n    return true;\n  }\n\n  function transfer(address _to, uint _value) returns (bool success) {\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n    balances[_to] = safeAdd(balances[_to], _value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n    uint _allowance = allowed[_from][msg.sender];\n\n    balances[_to] = safeAdd(balances[_to], _value);\n    balances[_from] = safeSub(balances[_from], _value);\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n  function approve(address _spender, uint _value) returns (bool success) {\n\n    // To change the approve amount you first have to reduce the addresses`\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n\n\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n\n/**\n * Upgrade agent interface inspired by Lunyr.\n *\n * Upgrade agent transfers tokens to a new contract.\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\n */\ncontract UpgradeAgent {\n\n  uint public originalSupply;\n\n  /** Interface marker */\n  function isUpgradeAgent() public constant returns (bool) {\n    return true;\n  }\n\n  function upgradeFrom(address _from, uint256 _value) public;\n\n}\n\n\n/**\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\n *\n * First envisioned by Golem and Lunyr projects.\n */\ncontract UpgradeableToken is StandardToken {\n\n  /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\n  address public upgradeMaster;\n\n  /** The next contract where the tokens will be migrated. */\n  UpgradeAgent public upgradeAgent;\n\n  /** How many tokens we have upgraded by now. */\n  uint256 public totalUpgraded;\n\n  /**\n   * Upgrade states.\n   *\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\n   * - WaitingForAgent: Token allows upgrade, but we don&#39;t have a new agent yet\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\n   *\n   */\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n\n  /**\n   * Somebody has upgraded some of his tokens.\n   */\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n\n  /**\n   * New upgrade agent available.\n   */\n  event UpgradeAgentSet(address agent);\n\n  /**\n   * Do not allow construction without upgrade master set.\n   */\n  function UpgradeableToken(address _upgradeMaster) {\n    upgradeMaster = _upgradeMaster;\n  }\n\n  /**\n   * Allow the token holder to upgrade some of their tokens to a new contract.\n   */\n  function upgrade(uint256 value) public {\n\n      UpgradeState state = getUpgradeState();\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n        // Called in a bad state\n        throw;\n      }\n\n      // Validate input value.\n      if (value == 0) throw;\n\n      balances[msg.sender] = safeSub(balances[msg.sender], value);\n\n      // Take tokens out from circulation\n      totalSupply = safeSub(totalSupply, value);\n      totalUpgraded = safeAdd(totalUpgraded, value);\n\n      // Upgrade agent reissues the tokens\n      upgradeAgent.upgradeFrom(msg.sender, value);\n      Upgrade(msg.sender, upgradeAgent, value);\n  }\n\n  /**\n   * Set an upgrade agent that handles\n   */\n  function setUpgradeAgent(address agent) external {\n\n      if(!canUpgrade()) {\n        // The token is not yet in a state that we could think upgrading\n        throw;\n      }\n\n      if (agent == 0x0) throw;\n      // Only a master can designate the next agent\n      if (msg.sender != upgradeMaster) throw;\n      // Upgrade has already begun for an agent\n      if (getUpgradeState() == UpgradeState.Upgrading) throw;\n\n      upgradeAgent = UpgradeAgent(agent);\n\n      // Bad interface\n      if(!upgradeAgent.isUpgradeAgent()) throw;\n      // Make sure that token supplies match in source and target\n      if (upgradeAgent.originalSupply() != totalSupply) throw;\n\n      UpgradeAgentSet(upgradeAgent);\n  }\n\n  /**\n   * Get the state of the token upgrade.\n   */\n  function getUpgradeState() public constant returns(UpgradeState) {\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n    else return UpgradeState.Upgrading;\n  }\n\n  /**\n   * Change the upgrade master.\n   *\n   * This allows us to set a new owner for the upgrade mechanism.\n   */\n  function setUpgradeMaster(address master) public {\n      if (master == 0x0) throw;\n      if (msg.sender != upgradeMaster) throw;\n      upgradeMaster = master;\n  }\n\n  /**\n   * Child contract can enable to provide the condition when the upgrade can begun.\n   */\n  function canUpgrade() public constant returns(bool) {\n     return true;\n  }\n\n}\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n\n\n\n\n\n/**\n * Define interface for releasing the token transfer after a successful crowdsale.\n */\ncontract ReleasableToken is ERC20, Ownable {\n\n  /* The finalizer contract that allows unlift the transfer limits on this token */\n  address public releaseAgent;\n\n  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n  bool public released = false;\n\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\n  mapping (address => bool) public transferAgents;\n\n  /**\n   * Limit token transfer until the crowdsale is over.\n   *\n   */\n  modifier canTransfer(address _sender) {\n\n    if(!released) {\n        if(!transferAgents[_sender]) {\n            throw;\n        }\n    }\n\n    _;\n  }\n\n  /**\n   * Set the contract that can call release and make the token transferable.\n   *\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\n   */\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n\n    // We don&#39;t do interface check here as we might want to a normal wallet address to act as a release agent\n    releaseAgent = addr;\n  }\n\n  /**\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\n   */\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n    transferAgents[addr] = state;\n  }\n\n  /**\n   * One way function to release the tokens to the wild.\n   *\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    released = true;\n  }\n\n  /** The function can be called only before or after the tokens have been releasesd */\n  modifier inReleaseState(bool releaseState) {\n    if(releaseState != released) {\n        throw;\n    }\n    _;\n  }\n\n  /** The function can be called only by a whitelisted release agent. */\n  modifier onlyReleaseAgent() {\n    if(msg.sender != releaseAgent) {\n        throw;\n    }\n    _;\n  }\n\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n    // Call StandardToken.transfer()\n   return super.transfer(_to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n    // Call StandardToken.transferForm()\n    return super.transferFrom(_from, _to, _value);\n  }\n\n}\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n\n\n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n\n\n\n/**\n * Safe unsigned safe math.\n *\n * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\n *\n * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol\n *\n * Maintained here until merged to mainline zeppelin-solidity.\n *\n */\nlibrary SafeMathLibExt {\n\n  function times(uint a, uint b) returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function divides(uint a, uint b) returns (uint) {\n    assert(b > 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function minus(uint a, uint b) returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function plus(uint a, uint b) returns (uint) {\n    uint c = a + b;\n    assert(c>=a);\n    return c;\n  }\n\n}\n\n\n\n\n/**\n * A token that can increase its supply by another contract.\n *\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\n *\n */\ncontract MintableTokenExt is StandardToken, Ownable {\n\n  using SafeMathLibExt for uint;\n\n  bool public mintingFinished = false;\n\n  /** List of agents that are allowed to create new tokens */\n  mapping (address => bool) public mintAgents;\n\n  event MintingAgentChanged(address addr, bool state  );\n\n  /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals.\n  * For example, for reserved tokens in percents 2.54%\n  * inPercentageUnit = 254\n  * inPercentageDecimals = 2\n  */\n  struct ReservedTokensData {\n    uint inTokens;\n    uint inPercentageUnit;\n    uint inPercentageDecimals;\n    bool isReserved;\n    bool isDistributed;\n  }\n\n  mapping (address => ReservedTokensData) public reservedTokensList;\n  address[] public reservedTokensDestinations;\n  uint public reservedTokensDestinationsLen = 0;\n  bool reservedTokensDestinationsAreSet = false;\n\n  modifier onlyMintAgent() {\n    // Only crowdsale contracts are allowed to mint new tokens\n    if(!mintAgents[msg.sender]) {\n        throw;\n    }\n    _;\n  }\n\n  /** Make sure we are not done yet. */\n  modifier canMint() {\n    if(mintingFinished) throw;\n    _;\n  }\n\n  function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n    ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n    reservedTokensData.isDistributed = true;\n  }\n\n  function isAddressReserved(address addr) public constant returns (bool isReserved) {\n    return reservedTokensList[addr].isReserved;\n  }\n\n  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n    return reservedTokensList[addr].isDistributed;\n  }\n\n  function getReservedTokens(address addr) public constant returns (uint inTokens) {\n    return reservedTokensList[addr].inTokens;\n  }\n\n  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n    return reservedTokensList[addr].inPercentageUnit;\n  }\n\n  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n    return reservedTokensList[addr].inPercentageDecimals;\n  }\n\n  function setReservedTokensListMultiple(\n    address[] addrs, \n    uint[] inTokens, \n    uint[] inPercentageUnit, \n    uint[] inPercentageDecimals\n  ) public canMint onlyOwner {\n    assert(!reservedTokensDestinationsAreSet);\n    assert(addrs.length == inTokens.length);\n    assert(inTokens.length == inPercentageUnit.length);\n    assert(inPercentageUnit.length == inPercentageDecimals.length);\n    for (uint iterator = 0; iterator < addrs.length; iterator++) {\n      if (addrs[iterator] != address(0)) {\n        setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n      }\n    }\n    reservedTokensDestinationsAreSet = true;\n  }\n\n  /**\n   * Create new tokens and allocate them to an address..\n   *\n   * Only callably by a crowdsale contract (mint agent).\n   */\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\n    totalSupply = totalSupply.plus(amount);\n    balances[receiver] = balances[receiver].plus(amount);\n\n    // This will make the mint transaction apper in EtherScan.io\n    // We can remove this after there is a standardized minting event\n    Transfer(0, receiver, amount);\n  }\n\n  /**\n   * Owner can allow a crowdsale contract to mint new tokens.\n   */\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n    mintAgents[addr] = state;\n    MintingAgentChanged(addr, state);\n  }\n\n  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n    assert(addr != address(0));\n    if (!isAddressReserved(addr)) {\n      reservedTokensDestinations.push(addr);\n      reservedTokensDestinationsLen++;\n    }\n\n    reservedTokensList[addr] = ReservedTokensData({\n      inTokens: inTokens, \n      inPercentageUnit: inPercentageUnit, \n      inPercentageDecimals: inPercentageDecimals,\n      isReserved: true,\n      isDistributed: false\n    });\n  }\n}\n\n\n/**\n * A crowdsaled token.\n *\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\n *\n * - The token transfer() is disabled until the crowdsale is over\n * - The token contract gives an opt-in upgrade path to a new contract\n * - The same token can be part of several crowdsales through approve() mechanism\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\n *\n */\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n\n  /** Name and symbol were updated. */\n  event UpdatedTokenInformation(string newName, string newSymbol);\n\n  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n\n  string public name;\n\n  string public symbol;\n\n  uint public decimals;\n\n  /* Minimum ammount of tokens every buyer can buy. */\n  uint public minCap;\n\n  /**\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   *\n   * @param _name Token name\n   * @param _symbol Token symbol - should be all caps\n   * @param _initialSupply How many tokens we start with\n   * @param _decimals Number of decimal places\n   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n   */\n  function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n    UpgradeableToken(msg.sender) {\n\n    // Create any address, can be transferred\n    // to team multisig via changeOwner(),\n    // also remember to call setUpgradeMaster()\n    owner = msg.sender;\n\n    name = _name;\n    symbol = _symbol;\n\n    totalSupply = _initialSupply;\n\n    decimals = _decimals;\n\n    minCap = _globalMinCap;\n\n    // Create initially all balance on the team multisig\n    balances[owner] = totalSupply;\n\n    if(totalSupply > 0) {\n      Minted(owner, totalSupply);\n    }\n\n    // No more new supply allowed after the token creation\n    if(!_mintable) {\n      mintingFinished = true;\n      if(totalSupply == 0) {\n        throw; // Cannot create a token without supply and no minting\n      }\n    }\n  }\n\n  /**\n   * When token is released to be transferable, enforce no new tokens can be created.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /**\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  /**\n   * Owner can update token information here.\n   *\n   * It is often useful to conceal the actual token association, until\n   * the token operations, like central issuance or reissuance have been completed.\n   *\n   * This function allows the token owner to rename the token after the operations\n   * have been completed and then point the audience to use the token contract.\n   */\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\n    name = _name;\n    symbol = _symbol;\n\n    UpdatedTokenInformation(name, symbol);\n  }\n\n  /**\n   * Claim tokens that were accidentally sent to this contract.\n   *\n   * @param _token The address of the token contract that you want to recover.\n   */\n  function claimTokens(address _token) public onlyOwner {\n    require(_token != address(0));\n\n    ERC20 token = ERC20(_token);\n    uint balance = token.balanceOf(this);\n    token.transfer(owner, balance);\n\n    ClaimedTokens(_token, owner, balance);\n  }\n\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x3abe03b6d22780363539f8a74d14a645b611c92d",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-06-29\n*/\n\n// Sources flattened with hardhat v2.4.1 https://hardhat.org\n\n// File @openzeppelin/contracts/utils/introspection/[email protected]\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\n// File @openzeppelin/contracts/token/ERC721/[email protected]\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\n\n// File @openzeppelin/contracts/token/ERC721/[email protected]\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\n\n// File @openzeppelin/contracts/token/ERC721/extensions/[email protected]\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\n// File @openzeppelin/contracts/utils/[email protected]\n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n// File @openzeppelin/contracts/utils/[email protected]\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\n// File @openzeppelin/contracts/utils/[email protected]\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n\n\n// File @openzeppelin/contracts/utils/introspection/[email protected]\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\n// File @openzeppelin/contracts/token/ERC721/[email protected]\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping (uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping (address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n            : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n     * in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n\n\n// File @openzeppelin/contracts/utils/[email protected]\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n}\n\n\n// File contracts/BlackPoolCup.sol\n\npragma solidity ^0.8.0;\n\n\ncontract BlackPoolCup is ERC721 {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    constructor() ERC721(\"BlackPool Cup\", \"BPC\") {}\n\n    mapping(uint => string) tokenURIs;\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n      return tokenURIs[tokenId];\n    }\n\n    function create(address player, string memory tokenURI)\n        public\n        returns (uint256)\n    {\n        _tokenIds.increment();\n\n        uint256 newItemId = _tokenIds.current();\n        _mint(player, newItemId);\n        tokenURIs[newItemId] = tokenURI;\n\n        return newItemId;\n    }\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x3abe5285ed57c8b028d62d30c456ca9eb3e74105",
    "source_code": "pragma solidity ^0.4.13;\n\ncontract Owned {\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public owner;\n\n    // This contract only defines a modifier and a few useful functions\n    // The function body is inserted where the special symbol \"_\" in the\n    // definition of a modifier appears.\n    modifier onlyOwner { if (msg.sender == owner) _; }\n\n    function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n        _dst.call.value(_value)(_data);\n    }\n}\n\ncontract ChooseWHGReturnAddress is Owned {\n\n    mapping (address => address) returnAddresses;\n    uint public endDate;\n\n    /// @param _endDate After this time, if `requestReturn()` has not been called\n    /// the upgraded parity multisig will be locked in as the &#39;returnAddr&#39;\n    function ChooseWHGReturnAddress(uint _endDate) {\n        endDate = _endDate;\n    }\n\n    /////////////////////////\n    //   IMPORTANT\n    /////////////////////////\n    // @dev The `returnAddr` can be changed only once.\n    //  We will send the funds to the chosen address. This is Crypto, if the\n    //  address is wrong, your funds could be lost, please, proceed with extreme\n    //  caution and treat this like you are sending all of your funds to this\n    //  address.\n\n    /// @notice This function is used to choose an address for returning the funds.\n    ///  This function can only be called once, PLEASE READ THE NOTE ABOVE.\n    /// @param _returnAddr The address that will receive the recued funds\n    function requestReturn(address _returnAddr) {\n\n        // After the end date, the newly deployed parity multisig will be\n        //  chosen if no transaction is made.\n        require(now <= endDate);\n\n        require(returnAddresses[msg.sender] == 0x0);\n        returnAddresses[msg.sender] = _returnAddr;\n        ReturnRequested(msg.sender, _returnAddr);\n    }\n    /// @notice This is a simple getter function that will be used to return the\n    ///  address that the WHG will return the funds to\n    /// @param _addr The address of the newly deployed parity multisig\n    /// @return address The chosen address that the funds will be returned to\n    function getReturnAddress(address _addr) constant returns (address) {\n        if (returnAddresses[_addr] == 0x0) {\n            return _addr;\n        } else {\n            return returnAddresses[_addr];\n        }\n    }\n\n    function isReturnRequested(address _addr) constant returns (bool) {\n        return returnAddresses[_addr] != 0x0;\n    }\n\n    event ReturnRequested(address indexed origin, address indexed returnAddress);\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x4149257d844Ef09f11b02f2e73CbDfaB4c911a73",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-09-02\n*/\n\n//SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/// @title ERC20 Bridge Logic Interface\n/// @author Vega Protocol\n/// @notice Implementations of this interface are used by Vega network users to deposit and withdraw ERC20 tokens to/from Vega.\n// @notice All funds deposited/withdrawn are to/from the ERC20_Asset_Pool\nabstract contract IERC20_Bridge_Logic {\n\n    /***************************EVENTS****************************/\n    event Asset_Withdrawn(address indexed user_address, address indexed asset_source, uint256 amount, uint256 nonce);\n    event Asset_Deposited(address indexed user_address, address indexed asset_source, uint256 amount, bytes32 vega_public_key);\n    event Asset_Deposit_Minimum_Set(address indexed asset_source,  uint256 new_minimum, uint256 nonce);\n    event Asset_Deposit_Maximum_Set(address indexed asset_source,  uint256 new_maximum, uint256 nonce);\n    event Asset_Listed(address indexed asset_source,  bytes32 indexed vega_asset_id, uint256 nonce);\n    event Asset_Removed(address indexed asset_source,  uint256 nonce);\n\n    /***************************FUNCTIONS*************************/\n    /// @notice This function lists the given ERC20 token contract as valid for deposit to this bridge\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param vega_asset_id Vega-generated asset ID for internal use in Vega Core\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit Asset_Listed if successful\n    function list_asset(address asset_source, bytes32 vega_asset_id, uint256 nonce, bytes memory signatures) public virtual;\n\n    /// @notice This function removes from listing the given ERC20 token contract. This marks the token as invalid for deposit to this bridge\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit Asset_Removed if successful\n    function remove_asset(address asset_source, uint256 nonce, bytes memory signatures) public virtual;\n\n    /// @notice This function sets the minimum allowable deposit for the given ERC20 token\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param minimum_amount Minimum deposit amount\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit Asset_Deposit_Minimum_Set if successful\n    function set_deposit_minimum(address asset_source, uint256 minimum_amount, uint256 nonce, bytes memory signatures) public virtual;\n\n    /// @notice This function sets the maximum allowable deposit for the given ERC20 token\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param maximum_amount Maximum deposit amount\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit Asset_Deposit_Maximum_Set if successful\n    function set_deposit_maximum(address asset_source, uint256 maximum_amount, uint256 nonce, bytes memory signatures) public virtual;\n\n    /// @notice This function withdrawals assets to the target Ethereum address\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param amount Amount of ERC20 tokens to withdraw\n    /// @param expiry Vega-assigned timestamp of withdrawal order expiration\n    /// @param target Target Ethereum address to receive withdrawn ERC20 tokens\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit Asset_Withdrawn if successful\n    function withdraw_asset(address asset_source, uint256 amount, uint256 expiry, address target, uint256 nonce, bytes memory signatures) public virtual;\n\n    /// @notice This function allows a user to deposit given ERC20 tokens into Vega\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param amount Amount of tokens to be deposited into Vega\n    /// @param vega_public_key Target Vega public key to be credited with this deposit\n    /// @dev MUST emit Asset_Deposited if successful\n    /// @dev ERC20 approve function should be run before running this\n    /// @notice ERC20 approve function should be run before running this\n    function deposit_asset(address asset_source, uint256 amount, bytes32 vega_public_key) public virtual;\n\n    /***************************VIEWS*****************************/\n    /// @notice This view returns true if the given ERC20 token contract has been listed valid for deposit\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return True if asset is listed\n    function is_asset_listed(address asset_source) public virtual view returns(bool);\n\n    /// @notice This view returns minimum valid deposit\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return Minimum valid deposit of given ERC20 token\n    function get_deposit_minimum(address asset_source) public virtual view returns(uint256);\n\n    /// @notice This view returns maximum valid deposit\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return Maximum valid deposit of given ERC20 token\n    function get_deposit_maximum(address asset_source) public virtual view returns(uint256);\n\n    /// @return current multisig_control_address\n    function get_multisig_control_address() public virtual view returns(address);\n\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return The assigned Vega Asset ID for given ERC20 token\n    function get_vega_asset_id(address asset_source) public virtual view returns(bytes32);\n\n    /// @param vega_asset_id Vega-assigned asset ID for which you want the ERC20 token address\n    /// @return The ERC20 token contract address for a given Vega Asset ID\n    function get_asset_source(bytes32 vega_asset_id) public virtual view returns(address);\n\n}\n/// @title MultisigControl Interface\n/// @author Vega Protocol\n/// @notice Implementations of this interface are used by the Vega network to control smart contracts without the need for Vega to have any Ethereum of its own.\n/// @notice To do this, the Vega validators sign a MultisigControl order to construct a signature bundle. Any interested party can then take that signature bundle and pay the gas to run the command on Ethereum\nabstract contract IMultisigControl {\n\n    /***************************EVENTS****************************/\n    event SignerAdded(address new_signer);\n    event SignerRemoved(address old_signer);\n    event ThresholdSet(uint16 new_threshold);\n\n    /**************************FUNCTIONS*********************/\n    /// @notice Sets threshold of signatures that must be met before function is executed.\n    /// @param new_threshold New threshold value\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @notice Ethereum has no decimals, threshold is % * 10 so 50% == 500 100% == 1000\n    /// @notice signatures are OK if they are >= threshold count of total valid signers\n    /// @dev MUST emit ThresholdSet event\n    function set_threshold(uint16 new_threshold, uint nonce, bytes memory signatures) public virtual;\n\n    /// @notice Adds new valid signer and adjusts signer count.\n    /// @param new_signer New signer address\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit 'SignerAdded' event\n    function add_signer(address new_signer, uint nonce, bytes memory signatures) public virtual;\n\n    /// @notice Removes currently valid signer and adjusts signer count.\n    /// @param old_signer Address of signer to be removed.\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit 'SignerRemoved' event\n    function remove_signer(address old_signer, uint nonce, bytes memory signatures) public virtual;\n\n    /// @notice Verifies a signature bundle and returns true only if the threshold of valid signers is met,\n    /// @notice this is a function that any function controlled by Vega MUST call to be securely controlled by the Vega network\n    /// @notice message to hash to sign follows this pattern:\n    /// @notice abi.encode( abi.encode(param1, param2, param3, ... , nonce, function_name_string), validating_contract_or_submitter_address);\n    /// @notice Note that validating_contract_or_submitter_address is the the submitting party. If on MultisigControl contract itself, it's the submitting ETH address\n    /// @notice if function on bridge that then calls Multisig, then it's the address of that contract\n    /// @notice Note also the embedded encoding, this is required to verify what function/contract the function call goes to\n    /// @return MUST return true if valid signatures are over the threshold\n    function verify_signatures(bytes memory signatures, bytes memory message, uint nonce) public virtual returns(bool);\n\n    /**********************VIEWS*********************/\n    /// @return Number of valid signers\n    function get_valid_signer_count() public virtual view returns(uint8);\n\n    /// @return Current threshold\n    function get_current_threshold() public virtual view returns(uint16);\n\n    /// @param signer_address target potential signer address\n    /// @return true if address provided is valid signer\n    function is_valid_signer(address signer_address) public virtual view returns(bool);\n\n    /// @param nonce Nonce to lookup\n    /// @return true if nonce has been used\n    function is_nonce_used(uint nonce) public virtual view returns(bool);\n}\n/// @title ERC20 Asset Pool\n/// @author Vega Protocol\n/// @notice This contract is the target for all deposits to the ERC20 Bridge via ERC20_Bridge_Logic\ncontract ERC20_Asset_Pool {\n\n    event Multisig_Control_Set(address indexed new_address);\n    event Bridge_Address_Set(address indexed new_address);\n\n    /// @return Current MultisigControl contract address\n    address public multisig_control_address;\n\n    /// @return Current ERC20_Bridge_Logic contract address\n    address public erc20_bridge_address;\n\n    /// @param multisig_control The initial MultisigControl contract address\n    /// @notice Emits Multisig_Control_Set event\n    constructor(address multisig_control) {\n        multisig_control_address = multisig_control;\n        emit Multisig_Control_Set(multisig_control);\n    }\n\n    /// @param new_address The new MultisigControl contract address.\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed set_multisig_control order\n    /// @notice See MultisigControl for more about signatures\n    /// @notice Emits Multisig_Control_Set event\n    function set_multisig_control(address new_address, uint256 nonce, bytes memory signatures) public {\n        bytes memory message = abi.encode(new_address, nonce, 'set_multisig_control');\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\n        multisig_control_address = new_address;\n        emit Multisig_Control_Set(new_address);\n    }\n\n    /// @param new_address The new ERC20_Bridge_Logic contract address.\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed set_bridge_address order\n    /// @notice See MultisigControl for more about signatures\n    /// @notice Emits Bridge_Address_Set event\n    function set_bridge_address(address new_address, uint256 nonce, bytes memory signatures) public {\n        bytes memory message = abi.encode(new_address, nonce, 'set_bridge_address');\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\n        erc20_bridge_address = new_address;\n        emit Bridge_Address_Set(new_address);\n    }\n\n    /// @notice This function can only be run by the current \"multisig_control_address\" and, if available, will send the target tokens to the target\n    /// @param token_address Contract address of the ERC20 token to be withdrawn\n    /// @param target Target Ethereum address that the ERC20 tokens will be sent to\n    /// @param amount Amount of ERC20 tokens to withdraw\n    /// @dev amount is in whatever the lowest decimal value the ERC20 token has. For instance, an 18 decimal ERC20 token, 1 \"amount\" == 0.000000000000000001\n    /// @return true if transfer was successful.\n    function withdraw(address token_address, address target, uint256 amount) public returns(bool) {\n        require(msg.sender == erc20_bridge_address, \"msg.sender not authorized bridge\");\n        require(IERC20(token_address).transfer(target, amount), \"token transfer failed\");\n        return true;\n    }\n}\n/// @title ERC20 Bridge Logic\n/// @author Vega Protocol\n/// @notice This contract is used by Vega network users to deposit and withdraw ERC20 tokens to/from Vega.\n// @notice All funds deposited/withdrawn are to/from the assigned ERC20_Asset_Pool\ncontract ERC20_Bridge_Logic is IERC20_Bridge_Logic {\n\n    //stops overflow\n    using SafeMath for uint256;\n\n    address multisig_control_address;\n    address erc20_asset_pool_address;\n    // asset address => is listed\n    mapping(address => bool) listed_tokens;\n    // asset address => minimum deposit amt\n    mapping(address => uint256) minimum_deposits;\n    // asset address => maximum deposit amt\n    mapping(address => uint256) maximum_deposits;\n    // Vega asset ID => asset_source\n    mapping(bytes32 => address) vega_asset_ids_to_source;\n    // asset_source => Vega asset ID\n    mapping(address => bytes32) asset_source_to_vega_asset_id;\n\n    /// @param erc20_asset_pool Initial Asset Pool contract address\n    /// @param multisig_control Initial MultisigControl contract address\n    constructor(address erc20_asset_pool, address multisig_control) {\n        erc20_asset_pool_address = erc20_asset_pool;\n        multisig_control_address = multisig_control;\n    }\n\n    /***************************FUNCTIONS*************************/\n    /// @notice This function lists the given ERC20 token contract as valid for deposit to this bridge\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param vega_asset_id Vega-generated asset ID for internal use in Vega Core\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits Asset_Listed if successful\n    function list_asset(address asset_source, bytes32 vega_asset_id, uint256 nonce, bytes memory signatures) public override {\n        require(!listed_tokens[asset_source], \"asset already listed\");\n        bytes memory message = abi.encode(asset_source, vega_asset_id, nonce, 'list_asset');\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\n        listed_tokens[asset_source] = true;\n        vega_asset_ids_to_source[vega_asset_id] = asset_source;\n        asset_source_to_vega_asset_id[asset_source] = vega_asset_id;\n        emit Asset_Listed(asset_source, vega_asset_id, nonce);\n    }\n\n    /// @notice This function removes from listing the given ERC20 token contract. This marks the token as invalid for deposit to this bridge\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits Asset_Removed if successful\n    function remove_asset(address asset_source, uint256 nonce, bytes memory signatures) public override {\n        require(listed_tokens[asset_source], \"asset not listed\");\n        bytes memory message = abi.encode(asset_source, nonce, 'remove_asset');\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\n        listed_tokens[asset_source] = false;\n        emit Asset_Removed(asset_source, nonce);\n    }\n\n    /// @notice This function sets the minimum allowable deposit for the given ERC20 token\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param minimum_amount Minimum deposit amount\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits Asset_Deposit_Minimum_Set if successful\n    function set_deposit_minimum(address asset_source, uint256 minimum_amount, uint256 nonce, bytes memory signatures) public override{\n        require(listed_tokens[asset_source], \"asset not listed\");\n        bytes memory message = abi.encode(asset_source, minimum_amount, nonce, 'set_deposit_minimum');\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\n        minimum_deposits[asset_source] = minimum_amount;\n        emit Asset_Deposit_Minimum_Set(asset_source, minimum_amount, nonce);\n    }\n\n    /// @notice This function sets the maximum allowable deposit for the given ERC20 token\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param maximum_amount Maximum deposit amount\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits Asset_Deposit_Maximum_Set if successful\n    function set_deposit_maximum(address asset_source, uint256 maximum_amount, uint256 nonce, bytes memory signatures) public override {\n        require(listed_tokens[asset_source], \"asset not listed\");\n        bytes memory message = abi.encode(asset_source, maximum_amount, nonce, 'set_deposit_maximum');\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\n        maximum_deposits[asset_source] = maximum_amount;\n        emit Asset_Deposit_Maximum_Set(asset_source, maximum_amount, nonce);\n    }\n\n    /// @notice This function withdrawals assets to the target Ethereum address\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param amount Amount of ERC20 tokens to withdraw\n    /// @param expiry Vega-assigned timestamp of withdrawal order expiration\n    /// @param target Target Ethereum address to receive withdrawn ERC20 tokens\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits Asset_Withdrawn if successful\n    function withdraw_asset(address asset_source, uint256 amount, uint256 expiry, address target, uint256 nonce, bytes memory signatures) public  override{\n        require(expiry > block.timestamp, \"withdrawal has expired\");\n        bytes memory message = abi.encode(asset_source, amount, expiry, target,  nonce, 'withdraw_asset');\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\n        require(ERC20_Asset_Pool(erc20_asset_pool_address).withdraw(asset_source, target, amount), \"token didn't transfer, rejected by asset pool.\");\n        emit Asset_Withdrawn(target, asset_source, amount, nonce);\n    }\n\n    /// @notice This function allows a user to deposit given ERC20 tokens into Vega\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param amount Amount of tokens to be deposited into Vega\n    /// @param vega_public_key Target Vega public key to be credited with this deposit\n    /// @dev MUST emit Asset_Deposited if successful\n    /// @dev ERC20 approve function should be run before running this\n    /// @notice ERC20 approve function should be run before running this\n    function deposit_asset(address asset_source, uint256 amount, bytes32 vega_public_key) public override {\n        require(listed_tokens[asset_source], \"asset not listed\");\n        //User must run approve before deposit\n        require(maximum_deposits[asset_source] == 0 || amount <= maximum_deposits[asset_source], \"deposit above maximum\");\n        require(amount >= minimum_deposits[asset_source], \"deposit below minimum\");\n        require(IERC20(asset_source).transferFrom(msg.sender, erc20_asset_pool_address, amount), \"transfer failed in deposit\");\n        emit Asset_Deposited(msg.sender, asset_source, amount, vega_public_key);\n    }\n\n    /***************************VIEWS*****************************/\n    /// @notice This view returns true if the given ERC20 token contract has been listed valid for deposit\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return True if asset is listed\n    function is_asset_listed(address asset_source) public override view returns(bool){\n        return listed_tokens[asset_source];\n    }\n\n    /// @notice This view returns minimum valid deposit\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return Minimum valid deposit of given ERC20 token\n    function get_deposit_minimum(address asset_source) public override view returns(uint256){\n        return minimum_deposits[asset_source];\n    }\n\n    /// @notice This view returns maximum valid deposit\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return Maximum valid deposit of given ERC20 token\n    function get_deposit_maximum(address asset_source) public override view returns(uint256){\n        return maximum_deposits[asset_source];\n    }\n\n    /// @return current multisig_control_address\n    function get_multisig_control_address() public override view returns(address) {\n        return multisig_control_address;\n    }\n\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return The assigned Vega Asset Id for given ERC20 token\n    function get_vega_asset_id(address asset_source) public override view returns(bytes32){\n        return asset_source_to_vega_asset_id[asset_source];\n    }\n\n    /// @param vega_asset_id Vega-assigned asset ID for which you want the ERC20 token address\n    /// @return The ERC20 token contract address for a given Vega Asset Id\n    function get_asset_source(bytes32 vega_asset_id) public override view returns(address){\n        return vega_asset_ids_to_source[vega_asset_id];\n    }\n}\n\n/**\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................DDD\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/",
    "vulnerability_type": "reentrancy"
  },
  {
    "address": "0x4188F085e53a410D8a61a73Cec11b570F6ae84C6",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-06-29\n*/\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n    * @dev Returns the token name.\n    */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address _owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor ()  {}\n\n    function _msgSender() internal view returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this;\n        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor ()  {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success,) = recipient.call{value : amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value : value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n    unchecked {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n        uint256 newAllowance = oldAllowance - value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract LoveVote is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public proposalValue = 500000 * 10 ** 18;\n\n    IERC20 votorToken;\n\n    mapping(address => bool) public directors;\n\n    struct Votor {\n        address account;\n        uint256 voteCountTotal;\n    }\n\n    mapping(address => Votor) public votorMap;\n    mapping(address => mapping(uint256 => uint256[5])) public userForProposalOptionAndCounts;\n\n    //Proposer\n    struct chairperson {\n        address account;\n        uint256 lastProposalBlockNumber;\n    }\n\n    mapping(address => chairperson) public chairpersonMap;\n\n    struct Proposal {\n        bool IsMajorProposal;\n        address Chairperson;\n        bytes32 Name;\n        uint256 OptionsTotalCounts;\n        bool IsEffective;\n        bool IsVotingEnd;\n        uint256 StartTime;\n        uint256 EndTime;\n        uint8 WinOption;\n    }\n\n    mapping(uint256 => mapping(uint8 => bytes32)) public ProposalOptions;\n\n    Proposal[] public Proposals;\n\n    mapping(uint256 => mapping(uint8 => uint256)) public ProposalsOptionsCounts;\n    mapping(uint256 => mapping(address => uint256[5])) public votorOptionAndCounts;\n\n    modifier validateByPid(uint256 _pid) {\n        require(_pid < Proposals.length, \"The proposal does not exist!\");\n        _;\n    }\n\n    event VoteEvent(address user, uint256 _pid, uint8 Option, uint256 _votes);\n    event GetVotor(address user, uint256 _pid, uint8 Option, uint256 account);\n    event ProposalEvent(address chairpersonUser, bytes32 _name, bytes32 _AOptions, bytes32 _BOptions, bytes32 _COptions,\n        bytes32 _DOptions, bytes32 _FOptions, bool _isMajorProposal);\n        \n    event ProposalStop(uint256 _pid,address msgsender);\n    event ProposaleCalculation(uint256 _pid, bool isMandatorySettlement,address msgsender);\n\n    constructor(IERC20 _votorToken){\n        require(address(_votorToken) !=address(0),\"_votorToken is zero value! \");\n        directors[msg.sender] = true;\n        votorToken = _votorToken;\n    }\n\n    function addDirector(address _director) external onlyOwner {\n        directors[_director] = true;\n    }\n\n    function delDirector(address _director) external onlyOwner {\n        directors[_director] = false;\n    }\n\n    function setProposalValue(uint256 number) external {\n        require(directors[msg.sender], \"Permission denied!\");\n        proposalValue = number;\n    }\n\n    function getProposalLen() external view returns (uint256){\n        return Proposals.length;\n    }\n\n    function vote(uint256 _pid, uint8 _options, uint256 _votes) external validateByPid(_pid) {\n        require(_options < 5, \"The option does not exist!\");\n        require(_votes >= 1 * 10 ** 18, \"At least one vote at a time!\");\n        Proposal storage thisProposal = Proposals[_pid];\n        require(thisProposal.IsEffective, \"The proposal is invalid!\");\n        require(!thisProposal.IsVotingEnd, \"The proposal is over!\");\n        require(thisProposal.EndTime >= block.timestamp, \"The proposal is over!\");\n        thisProposal.OptionsTotalCounts = thisProposal.OptionsTotalCounts.add(_votes);\n        ProposalsOptionsCounts[_pid][_options] = ProposalsOptionsCounts[_pid][_options].add(_votes);\n        votorToken.safeTransferFrom(msg.sender, address(this), _votes);\n        Votor storage user = votorMap[msg.sender];\n        user.account = msg.sender;\n        user.voteCountTotal = user.voteCountTotal.add(_votes);\n        votorOptionAndCounts[_pid][msg.sender][_options] = votorOptionAndCounts[_pid][msg.sender][_options].add(_votes);\n        userForProposalOptionAndCounts[msg.sender][_pid][_options] = userForProposalOptionAndCounts[msg.sender][_pid][_options].add(_votes);\n        emit VoteEvent(msg.sender, _pid, _options, _votes);\n    }\n\n    function getVoted(uint256 _pid) external validateByPid(_pid) {\n        Proposal storage thisProposal = Proposals[_pid];\n        Votor storage user = votorMap[msg.sender];\n        require(!thisProposal.IsEffective || thisProposal.IsVotingEnd, \"It can't be redeemed yet!\");\n        for (uint8 i = 0; i < 5; i++) {\n            if (userForProposalOptionAndCounts[msg.sender][_pid][i] > 0) {\n                votorToken.safeTransfer(msg.sender, userForProposalOptionAndCounts[msg.sender][_pid][i]);\n                user.voteCountTotal = user.voteCountTotal.sub(userForProposalOptionAndCounts[msg.sender][_pid][i]);\n                userForProposalOptionAndCounts[msg.sender][_pid][i] = 0;\n                emit GetVotor(msg.sender, _pid, i, userForProposalOptionAndCounts[msg.sender][_pid][i]);\n            }\n        }\n    }\n\n    function proposal(bytes32 _name, bytes32 _AOptions, bytes32 _BOptions, bytes32 _COptions, bytes32 _DOptions,\n        bytes32 _FOptions, bool _isMajorProposal, uint256 _endDay) external returns (bool){\n        require(votorToken.balanceOf(msg.sender) > proposalValue, \"Insufficient balance!\");\n        require(block.number.sub(chairpersonMap[msg.sender].lastProposalBlockNumber) > 129600, \"Permission denied\");\n\n        uint256 _endTime = block.timestamp + _endDay.mul(86400);\n        if (block.number.sub(chairpersonMap[msg.sender].lastProposalBlockNumber) > 129600) {\n            Proposals.push(Proposal({\n            IsMajorProposal : _isMajorProposal,\n            Chairperson : msg.sender,\n            Name : _name,\n            OptionsTotalCounts : 0,\n            StartTime : block.timestamp,\n            EndTime : _endTime,\n            IsEffective : true,\n            IsVotingEnd : false,\n            WinOption : 6\n            }));\n            ProposalOptions[Proposals.length - 1][0] = _AOptions;\n            ProposalOptions[Proposals.length - 1][1] = _BOptions;\n            ProposalOptions[Proposals.length - 1][2] = _COptions;\n            ProposalOptions[Proposals.length - 1][3] = _DOptions;\n            ProposalOptions[Proposals.length - 1][4] = _FOptions;\n            chairpersonMap[msg.sender] = chairperson({\n            account : msg.sender,\n            lastProposalBlockNumber : block.number\n            });\n\n            emit ProposalEvent(msg.sender, _name, _AOptions, _BOptions, _COptions, _DOptions, _FOptions, _isMajorProposal);\n            return true;\n        } else {\n            return false;\n        }\n\n    }\n\n    function IsProposalEnd(uint256 endblock) external view returns (bool isEnd){\n        if (endblock <= block.number) {\n            return true;\n        }\n    }\n\n    function proposalStop(uint256 _pid) external validateByPid(_pid) {\n        Proposal storage thisProposal = Proposals[_pid];\n        require(thisProposal.Chairperson == msg.sender || directors[msg.sender], \"Permission denied!\");\n        thisProposal.IsEffective = false;\n        emit ProposalStop(_pid,msg.sender);\n    }\n\n    function proposaleCalculation(uint256 _pid, bool isMandatorySettlement) external validateByPid(_pid) {\n        Proposal storage thisProposal = Proposals[_pid];\n        require(thisProposal.IsEffective, \"The proposal is invalid!\");\n        require(!thisProposal.IsVotingEnd, \"The proposal is over!\");\n        if (!isMandatorySettlement) {\n            require(thisProposal.EndTime < block.timestamp, \"Voting time is not yet up!\");\n        }\n        require(thisProposal.Chairperson == msg.sender || directors[msg.sender], \"Permission denied!\");\n\n        if (thisProposal.IsMajorProposal) {\n            uint256 winerVotes = thisProposal.OptionsTotalCounts.div(2);\n            for (uint8 i = 0; i < 5; i++) {\n                if (ProposalsOptionsCounts[_pid][i] > winerVotes) {\n                    thisProposal.WinOption = i;\n                }\n            }\n        } else {\n            uint256 winerVotes = ProposalsOptionsCounts[_pid][0];\n            for (uint8 i = 1; i < 5; i++) {\n                if (ProposalsOptionsCounts[_pid][i] > winerVotes) {\n                    winerVotes = ProposalsOptionsCounts[_pid][i];\n                    thisProposal.WinOption = i;\n                }\n            }\n        }\n        thisProposal.EndTime = block.timestamp;\n        thisProposal.IsVotingEnd = true;\n        emit ProposaleCalculation(_pid,isMandatorySettlement,msg.sender);\n    }\n\n}",
    "vulnerability_type": "reentrancy"
  },
  {
    "address": "0x419f10dc6135981b2719795647e8cfbc5d25617b",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2022-04-13\n*/\n\n// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.4;\n\n// Copyright (C) 2018 Rain <[email protected]>\n\ninterface ICodex {\n    function init(address vault) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address,\n        bytes32,\n        uint256\n    ) external;\n\n    function credit(address) external view returns (uint256);\n\n    function unbackedDebt(address) external view returns (uint256);\n\n    function balances(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function vaults(address vault)\n        external\n        view\n        returns (\n            uint256 totalNormalDebt,\n            uint256 rate,\n            uint256 debtCeiling,\n            uint256 debtFloor\n        );\n\n    function positions(\n        address vault,\n        uint256 tokenId,\n        address position\n    ) external view returns (uint256 collateral, uint256 normalDebt);\n\n    function globalDebt() external view returns (uint256);\n\n    function globalUnbackedDebt() external view returns (uint256);\n\n    function globalDebtCeiling() external view returns (uint256);\n\n    function delegates(address, address) external view returns (uint256);\n\n    function grantDelegate(address) external;\n\n    function revokeDelegate(address) external;\n\n    function modifyBalance(\n        address,\n        uint256,\n        address,\n        int256\n    ) external;\n\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function settleUnbackedDebt(uint256 debt) external;\n\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external;\n\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 rate\n    ) external;\n\n    function lock() external;\n}\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\ninterface IDebtAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function tokenToSellBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function aer() external view returns (address);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(\n        address recipient,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock() external;\n\n    function cancelAuction(uint256 id) external;\n}\ninterface ISurplusAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(uint256 creditToSell, uint256 bid) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 creditToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock(uint256 credit) external;\n\n    function cancelAuction(uint256 id) external;\n}\n\ninterface IAer {\n    function codex() external view returns (ICodex);\n\n    function surplusAuction() external view returns (ISurplusAuction);\n\n    function debtAuction() external view returns (IDebtAuction);\n\n    function debtQueue(uint256) external view returns (uint256);\n\n    function queuedDebt() external view returns (uint256);\n\n    function debtOnAuction() external view returns (uint256);\n\n    function auctionDelay() external view returns (uint256);\n\n    function debtAuctionSellSize() external view returns (uint256);\n\n    function debtAuctionBidSize() external view returns (uint256);\n\n    function surplusAuctionSellSize() external view returns (uint256);\n\n    function surplusBuffer() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function queueDebt(uint256 debt) external;\n\n    function unqueueDebt(uint256 queuedAt) external;\n\n    function settleDebtWithSurplus(uint256 debt) external;\n\n    function settleAuctionedDebt(uint256 debt) external;\n\n    function startDebtAuction() external returns (uint256 auctionId);\n\n    function startSurplusAuction() external returns (uint256 auctionId);\n\n    function transferCredit(address to, uint256 credit) external;\n\n    function lock() external;\n}interface IPublican {\n    function vaults(address vault) external view returns (uint256, uint256);\n\n    function codex() external view returns (ICodex);\n\n    function aer() external view returns (IAer);\n\n    function baseInterest() external view returns (uint256);\n\n    function init(address vault) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function virtualRate(address vault) external returns (uint256 rate);\n\n    function collect(address vault) external returns (uint256 rate);\n}\ninterface IGuarded {\n    function ANY_SIG() external view returns (bytes32);\n\n    function ANY_CALLER() external view returns (address);\n\n    function allowCaller(bytes32 sig, address who) external;\n\n    function blockCaller(bytes32 sig, address who) external;\n\n    function canCall(bytes32 sig, address who) external view returns (bool);\n}\n/// @title Guarded\n/// @notice Mixin implementing an authentication scheme on a method level\nabstract contract Guarded is IGuarded {\n    /// ======== Custom Errors ======== ///\n\n    error Guarded__notRoot();\n    error Guarded__notGranted();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Wildcard for granting a caller to call every guarded method\n    bytes32 public constant override ANY_SIG = keccak256(\"ANY_SIG\");\n    /// @notice Wildcard for granting a caller to call every guarded method\n    address public constant override ANY_CALLER = address(uint160(uint256(bytes32(keccak256(\"ANY_CALLER\")))));\n\n    /// @notice Mapping storing who is granted to which method\n    /// @dev Method Signature => Caller => Bool\n    mapping(bytes32 => mapping(address => bool)) private _canCall;\n\n    /// ======== Events ======== ///\n\n    event AllowCaller(bytes32 sig, address who);\n    event BlockCaller(bytes32 sig, address who);\n\n    constructor() {\n        // set root\n        _setRoot(msg.sender);\n    }\n\n    /// ======== Auth ======== ///\n\n    modifier callerIsRoot() {\n        if (_canCall[ANY_SIG][msg.sender]) {\n            _;\n        } else revert Guarded__notRoot();\n    }\n\n    modifier checkCaller() {\n        if (canCall(msg.sig, msg.sender)) {\n            _;\n        } else revert Guarded__notGranted();\n    }\n\n    /// @notice Grant the right to call method `sig` to `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function allowCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = true;\n        emit AllowCaller(sig, who);\n    }\n\n    /// @notice Revoke the right to call method `sig` from `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should not be able to call `sig` anymore\n    function blockCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = false;\n        emit BlockCaller(sig, who);\n    }\n\n    /// @notice Returns if `who` can call `sig`\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function canCall(bytes32 sig, address who) public view override returns (bool) {\n        return (_canCall[sig][who] || _canCall[ANY_SIG][who] || _canCall[sig][ANY_CALLER]);\n    }\n\n    /// @notice Sets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be set as root\n    function _setRoot(address root) internal {\n        _canCall[ANY_SIG][root] = true;\n        emit AllowCaller(ANY_SIG, root);\n    }\n\n    /// @notice Unsets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be unset as root\n    function _unsetRoot(address root) internal {\n        _canCall[ANY_SIG][root] = false;\n        emit AllowCaller(ANY_SIG, root);\n    }\n}// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\nuint256 constant MLN = 10**6;\nuint256 constant BLN = 10**9;\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**18;\nuint256 constant RAD = 10**18;\n\n/* solhint-disable func-visibility, no-inline-assembly */\n\nerror Math__toInt256_overflow(uint256 x);\n\nfunction toInt256(uint256 x) pure returns (int256) {\n    if (x > uint256(type(int256).max)) revert Math__toInt256_overflow(x);\n    return int256(x);\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x <= y ? x : y;\n    }\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x >= y ? x : y;\n    }\n}\n\nerror Math__diff_overflow(uint256 x, uint256 y);\n\nfunction diff(uint256 x, uint256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) - int256(y);\n        if (!(int256(x) >= 0 && int256(y) >= 0)) revert Math__diff_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow(uint256 x, uint256 y);\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add_overflow(x, y);\n    }\n}\n\nerror Math__add48_overflow(uint256 x, uint256 y);\n\nfunction add48(uint48 x, uint48 y) pure returns (uint48 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add48_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow_signed(uint256 x, int256 y);\n\nfunction add(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x + uint256(y);\n        if (!(y >= 0 || z <= x)) revert Math__add_overflow_signed(x, y);\n        if (!(y <= 0 || z >= x)) revert Math__add_overflow_signed(x, y);\n    }\n}\n\nerror Math__sub_overflow(uint256 x, uint256 y);\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x - y) > x) revert Math__sub_overflow(x, y);\n    }\n}\n\nerror Math__sub_overflow_signed(uint256 x, int256 y);\n\nfunction sub(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x - uint256(y);\n        if (!(y <= 0 || z <= x)) revert Math__sub_overflow_signed(x, y);\n        if (!(y >= 0 || z >= x)) revert Math__sub_overflow_signed(x, y);\n    }\n}\n\nerror Math__mul_overflow(uint256 x, uint256 y);\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (!(y == 0 || (z = x * y) / y == x)) revert Math__mul_overflow(x, y);\n    }\n}\n\nerror Math__mul_overflow_signed(uint256 x, int256 y);\n\nfunction mul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) * y;\n        if (int256(x) < 0) revert Math__mul_overflow_signed(x, y);\n        if (!(y == 0 || z / y == int256(x))) revert Math__mul_overflow_signed(x, y);\n    }\n}\n\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, y) / WAD;\n    }\n}\n\nfunction wmul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = mul(x, y) / int256(WAD);\n    }\n}\n\nerror Math__div_overflow(uint256 x, uint256 y);\n\nfunction div(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (y == 0) revert Math__div_overflow(x, y);\n        return x / y;\n    }\n}\n\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, WAD) / y;\n    }\n}\n\n// optimized version from dss PR #78\nfunction wpow(\n    uint256 x,\n    uint256 n,\n    uint256 b\n) pure returns (uint256 z) {\n    unchecked {\n        assembly {\n            switch n\n            case 0 {\n                z := b\n            }\n            default {\n                switch x\n                case 0 {\n                    z := 0\n                }\n                default {\n                    switch mod(n, 2)\n                    case 0 {\n                        z := b\n                    }\n                    default {\n                        z := x\n                    }\n                    let half := div(b, 2) // for rounding.\n                    for {\n                        n := div(n, 2)\n                    } n {\n                        n := div(n, 2)\n                    } {\n                        let xx := mul(x, x)\n                        if shr(128, x) {\n                            revert(0, 0)\n                        }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) {\n                            revert(0, 0)\n                        }\n                        x := div(xxRound, b)\n                        if mod(n, 2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                                revert(0, 0)\n                            }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) {\n                                revert(0, 0)\n                            }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* solhint-disable func-visibility, no-inline-assembly */\n/// @title Publican\n/// @notice `Publican` is responsible for setting the debt interest rate and collecting interest\n/// Uses Jug.sol from DSS (MakerDAO) / TaxCollector.sol from GEB (Reflexer Labs) as a blueprint\n/// Changes from Jug.sol / TaxCollector.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - configuration by Vaults\ncontract Publican is Guarded, IPublican {\n    /// ======== Custom Errors ======== ///\n\n    error Publican__init_vaultAlreadyInit();\n    error Publican__setParam_notCollected();\n    error Publican__setParam_unrecognizedParam();\n    error Publican__collect_invalidBlockTimestamp();\n\n    /// ======== Storage ======== ///\n\n    // Vault specific configuration data\n    struct VaultConfig {\n        // Collateral-specific, per-second stability fee contribution [wad]\n        uint256 interestPerSecond;\n        // Time of last drip [unix epoch time]\n        uint256 lastCollected;\n    }\n\n    /// @notice Vault Configs\n    /// @dev Vault => Vault Config\n    mapping(address => VaultConfig) public override vaults;\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice Aer\n    IAer public override aer;\n\n    /// @notice Global, per-second stability fee contribution [wad]\n    uint256 public override baseInterest;\n\n    /// ======== Events ======== ///\n    event Init(address indexed vault);\n    event SetParam(bytes32 indexed param, uint256);\n    event SetParam(bytes32 indexed param, address indexed data);\n    event SetParam(address indexed vault, bytes32 indexed param, uint256 data);\n    event Collect(address indexed vault);\n\n    constructor(address codex_) Guarded() {\n        codex = ICodex(codex_);\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Initializes a new Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    function init(address vault) external override checkCaller {\n        VaultConfig storage v = vaults[vault];\n        if (v.interestPerSecond != 0) revert Publican__init_vaultAlreadyInit();\n        v.interestPerSecond = WAD;\n        v.lastCollected = block.timestamp;\n        emit Init(vault);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller {\n        if (block.timestamp != vaults[vault].lastCollected) revert Publican__setParam_notCollected();\n        if (param == \"interestPerSecond\") vaults[vault].interestPerSecond = data;\n        else revert Publican__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (param == \"baseInterest\") baseInterest = data;\n        else revert Publican__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(bytes32 param, address data) external override checkCaller {\n        if (param == \"aer\") aer = IAer(data);\n        else revert Publican__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Interest Rates ======== ///\n\n    /// @notice Returns the up to date rate (virtual rate) for a given vault as the rate stored in Codex\n    /// might be outdated\n    /// @param vault Address of the Vault\n    /// @return rate Virtual rate\n    function virtualRate(address vault) external view override returns (uint256 rate) {\n        (, uint256 prev, , ) = codex.vaults(vault);\n        if (block.timestamp < vaults[vault].lastCollected) return prev;\n        rate = wmul(\n            wpow(\n                add(baseInterest, vaults[vault].interestPerSecond),\n                sub(block.timestamp, vaults[vault].lastCollected),\n                WAD\n            ),\n            prev\n        );\n    }\n\n    /// @notice Collects accrued interest from all Position on a Vault by updating the Vault's rate\n    /// @param vault Address of the Vault\n    /// @return rate Set rate\n    function collect(address vault) public override returns (uint256 rate) {\n        if (block.timestamp < vaults[vault].lastCollected) revert Publican__collect_invalidBlockTimestamp();\n        (, uint256 prev, , ) = codex.vaults(vault);\n        rate = wmul(\n            wpow(\n                add(baseInterest, vaults[vault].interestPerSecond),\n                sub(block.timestamp, vaults[vault].lastCollected),\n                WAD\n            ),\n            prev\n        );\n        codex.modifyRate(vault, address(aer), diff(rate, prev));\n        vaults[vault].lastCollected = block.timestamp;\n        emit Collect(vault);\n    }\n\n    /// @notice Batches interest collection. See `collect(address vault)`.\n    /// @param vaults_ Array of Vault addresses\n    /// @return rates Set rates for each updated Vault\n    function collectMany(address[] memory vaults_) external returns (uint256[] memory) {\n        uint256[] memory rates = new uint256[](vaults_.length);\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            rates[i] = collect(vaults_[i]);\n        }\n        return rates;\n    }\n}\ncontract Delayed {\n    error Delayed__setParam_notDelayed();\n    error Delayed__delay_invalidEta();\n    error Delayed__execute_unknown();\n    error Delayed__execute_stillDelayed();\n    error Delayed__execute_executionError();\n\n    mapping(bytes32 => bool) public queue;\n    uint256 public delay;\n\n    event SetParam(bytes32 param, uint256 data);\n    event Queue(address target, bytes data, uint256 eta);\n    event Unqueue(address target, bytes data, uint256 eta);\n    event Execute(address target, bytes data, uint256 eta);\n\n    constructor(uint256 delay_) {\n        delay = delay_;\n        emit SetParam(\"delay\", delay_);\n    }\n\n    function _setParam(bytes32 param, uint256 data) internal {\n        if (param == \"delay\") delay = data;\n        emit SetParam(param, data);\n    }\n\n    function _delay(\n        address target,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        if (eta < block.timestamp + delay) revert Delayed__delay_invalidEta();\n        queue[keccak256(abi.encode(target, data, eta))] = true;\n        emit Queue(target, data, eta);\n    }\n\n    function _skip(\n        address target,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        queue[keccak256(abi.encode(target, data, eta))] = false;\n        emit Unqueue(target, data, eta);\n    }\n\n    function execute(\n        address target,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes memory out) {\n        bytes32 callHash = keccak256(abi.encode(target, data, eta));\n\n        if (!queue[callHash]) revert Delayed__execute_unknown();\n        if (block.timestamp < eta) revert Delayed__execute_stillDelayed();\n\n        queue[callHash] = false;\n\n        bool ok;\n        (ok, out) = target.call(data);\n        if (!ok) revert Delayed__execute_executionError();\n\n        emit Execute(target, data, eta);\n    }\n}interface IGuard {\n    function isGuard() external view returns (bool);\n}\n\nabstract contract BaseGuard is Delayed, IGuard {\n    /// ======== Custom Errors ======== ///\n\n    error BaseGuard__isSenatus_notSenatus();\n    error BaseGuard__isGuardian_notGuardian();\n    error BaseGuard__isDelayed_notSelf(address, address);\n    error BaseGuard__inRange_notInRange();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Address of the DAO\n    address public senatus;\n    /// @notice Address of the guardian\n    address public guardian;\n\n    constructor(\n        address senatus_,\n        address guardian_,\n        uint256 delay\n    ) Delayed(delay) {\n        senatus = senatus_;\n        guardian = guardian_;\n    }\n\n    modifier isSenatus() {\n        if (msg.sender != senatus) revert BaseGuard__isSenatus_notSenatus();\n        _;\n    }\n\n    modifier isGuardian() {\n        if (msg.sender != guardian) revert BaseGuard__isGuardian_notGuardian();\n        _;\n    }\n\n    modifier isDelayed() {\n        if (msg.sender != address(this)) revert BaseGuard__isDelayed_notSelf(msg.sender, address(this));\n        _;\n    }\n\n    /// @notice Callback method which allows Guard to check if he has sufficient rights over the corresponding contract\n    /// @return bool True if he has sufficient rights\n    function isGuard() external view virtual override returns (bool);\n\n    /// @notice Updates the address of senatus\n    /// @dev Can only be called by Senatus\n    /// @param senatus_ Address of the new senatus\n    function setSenatus(address senatus_) external isSenatus {\n        senatus = senatus_;\n    }\n\n    /// @notice Updates the address of the guardian\n    /// @dev Can only be called by Senatus\n    /// @param guardian_ Address of the new guardian\n    function setGuardian(address guardian_) external isSenatus {\n        guardian = guardian_;\n    }\n\n    /// ======== Capabilities ======== ///\n\n    /// @notice Updates the time which has to elapse for certain parameter updates\n    /// @dev Can only be called by Senatus\n    /// @param delay Time which has to elapse before parameter can be updated [seconds]\n    function setDelay(uint256 delay) external isSenatus {\n        _setParam(\"delay\", delay);\n    }\n\n    /// @notice Schedule method call for methods which have to be delayed\n    /// @dev Can only be called by the guardian\n    /// @param data Call data\n    function schedule(bytes calldata data) external isGuardian {\n        _delay(address(this), data, block.timestamp + delay);\n    }\n\n    /// ======== Helper Methods ======== ///\n\n    /// @notice Checks if `value` is at least equal to `min_` or at most equal to `max`\n    /// @dev Revers if check failed\n    /// @param value Value to check\n    /// @param min_ Min. value for `value`\n    /// @param max Max. value for `value`\n    function _inRange(\n        uint256 value,\n        uint256 min_,\n        uint256 max\n    ) internal pure {\n        if (max < value || value < min_) revert BaseGuard__inRange_notInRange();\n    }\n}\n/// @title PublicanGuard\n/// @notice Contract which guards parameter updates for `Publican`\ncontract PublicanGuard is BaseGuard {\n    /// ======== Custom Errors ======== ///\n\n    error PublicanGuard__isGuard_cantCall();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Address of Publican\n    Publican public immutable publican;\n\n    constructor(\n        address senatus,\n        address guardian,\n        uint256 delay,\n        address publican_\n    ) BaseGuard(senatus, guardian, delay) {\n        publican = Publican(publican_);\n    }\n\n    /// @notice See `BaseGuard`\n    function isGuard() external view override returns (bool) {\n        if (!publican.canCall(publican.ANY_SIG(), address(this))) revert PublicanGuard__isGuard_cantCall();\n        return true;\n    }\n\n    /// ======== Capabilities ======== ///\n\n    /// @notice Sets the `aer` parameter on Publican after the `delay` has passed.\n    /// @dev Can only be called by the guardian. After `delay` has passed it can be `execute`'d.\n    /// @param aer See. Publican\n    function setAer(address aer) external isDelayed {\n        publican.setParam(\"aer\", aer);\n    }\n\n    /// @notice Sets the `baseInterest` parameter on Publican\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param baseInterest See. Publican\n    function setBaseInterest(uint256 baseInterest) external isGuardian {\n        _inRange(baseInterest, WAD, 1000000006341958396); // 0 - 20%\n        publican.setParam(\"baseInterest\", baseInterest);\n    }\n\n    /// @notice Sets the `interestPerSecond` parameter on Publican\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param vault Address of the vault for which to set the parameter\n    /// @param interestPerSecond See. Publican\n    function setInterestPerSecond(address vault, uint256 interestPerSecond) external isGuardian {\n        _inRange(interestPerSecond, WAD, 1000000006341958396); // 0 - 20%\n        publican.setParam(vault, \"interestPerSecond\", interestPerSecond);\n    }\n}",
    "vulnerability_type": "reentrancy"
  },
  {
    "address": "0x41a608D50DD254cF3204506F8b30f52aFA9df767",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2022-04-14\n*/\n\n// SPDX-License-Identifier: UNLICENSED\n/**\n\nhttps://t.me/IrohINU\n                        ⡀⡀⠀⢂⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⢡⠀⢈⣆⣸⣀⡘⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠂⠀⠀⠀⠀⢡⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠤⠀⠀⠈⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⢐⠌⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠊⠔⠁⠀⠀⠀⠀⢀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠔⠀⡀⠀⠀⠀⡠⠒⢉⡠⠤⠤⠄⡠⡀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠌⠀⠀⠡⠄⠀⠸⣠⠖⠉⠀⠀⠀⠀⠀⠈⠁⠀⠀⠀⠀⠴⠾⠷⠦⢤⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡐⠀⠀⠀⠀⠀⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⡡⠂⠈⠢⡆⠀⠀⠀⠀⠀⣠⠤⢶⣶⢤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢓⠀⠀⠀⠀⠃⢠⠀⠀⠠⠀⠀⠀⠈⠛⠋⠀⠀⠀⠀⠀⠀⡀⠀⠸⠿⠍⢲⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢦⢀⠀⠀⠁⡼⠀⠀⡀⠀⠀⠑⠀⠒⠂⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⡀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⢁⠎⠀⠑⠄⠠⠃⠀⠀⢗⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠎⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⢀⠎⠀⠀⠀⣰⠅⠀⠀⠀⠀⠈⠀⢐⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢄⠀⣠⣾⡀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀⠀⠀⣠⠊⠀⠀⠀⠀⠀⠀⢀⠂⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠂⠀⠠⠈⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⡠⡀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠈⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠀⠀⠀⠀⣸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠈⡐⠀⢀⣔⣁⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢤⠀⠀⠀⡦⠠⠀⠀⠀⠀⠈⢆⠀⢀⣴⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⢬⠀⠈⣉⣞⠅⠀⠀⢒⠆⠀⠀⠀⠀⠀⠀⠀⠀⢘⡄⠀⠠⣇⠀⠀⠀⠀⠀⠀⠘⡆⣼⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀\n⠀⠀⠀⠀⢀⢂⣠⣾⣿⣿⣧⡤⠞⠓⡲⠷⠒⠊⠉⠉⠉⠙⠿⣿⣿⣦⣤⣻⠄⠀⠀⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⢿⡀⠀⠈⠀⠀⠀⠀\n⠀⠀⠀⣠⣶⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠓⢍⡛⢿⣷⣄⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀\n⣠⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠢⢝⣿⣷⣄⠀⠀⠀⠀⠈⡏⠙⠿⠿⠛⢹⣿⣷⣄⡀⠀⠀⠀\n⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⣷⣦⣄⡀⣦⡟⠀⠀⠀⠀⢸⣿⣿⣿⣿⣦⣀⠀\n⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠊⠙⠛⠿⠟⠛⠁⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣷\n⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣤⣴⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣦⣤⣤⣄⣀⡀⢀⣿⣿⣿⣿⣿⣿⣿⣿\n⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n  \n*/\npragma solidity ^0.8.4;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ncontract Ownable is Context {\n    address private _owner;\n    address private _previousOwner;\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n}\n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n}\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n}\n\ncontract IROHINU is Context, IERC20, Ownable {\n\n    using SafeMath for uint256;\n\n    string private constant _name = \"IrohInu\";\n    string private constant _symbol = \"IROHINU\";\n    uint8 private constant _decimals = 9;\n\n    mapping(address => uint256) private _rOwned;\n    mapping(address => uint256) private _tOwned;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => bool) private _isExcludedFromFee;\n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 1000000 * 10**9;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    //Buy Fee\n    uint256 private _redisFeeOnBuy = 1;\n    uint256 private _taxFeeOnBuy = 10;\n\n    //Sell Fee\n    uint256 private _redisFeeOnSell = 1;\n    uint256 private _taxFeeOnSell = 12;\n\n    //Original Fee\n    uint256 private _redisFee = _redisFeeOnSell;\n    uint256 private _taxFee = _taxFeeOnSell;\n\n    uint256 private _previousredisFee = _redisFee;\n    uint256 private _previoustaxFee = _taxFee;\n\n    mapping(address => bool) public bots;\n    mapping(address => uint256) private cooldown;\n\n    address payable private _developmentAddress = payable(0x8629E78EA553f1Db6E17e6B70D0208e5a1b0e619);\n    address payable private _marketingAddress = payable(0x8629E78EA553f1Db6E17e6B70D0208e5a1b0e619);\n\n    IUniswapV2Router02 public uniswapV2Router;\n    address public uniswapV2Pair;\n\n    bool private tradingOpen = false;\n    bool private inSwap = false;\n    bool private swapEnabled = true;\n\n    uint256 public _maxTxAmount = 10000 * 10**9; //1%\n    uint256 public _maxWalletSize = 30000 * 10**9; //3%\n    uint256 public _swapTokensAtAmount = 4000 * 10**9; //.4%\n\n    event MaxTxAmountUpdated(uint256 _maxTxAmount);\n    modifier lockTheSwap {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n    constructor() {\n\n        _rOwned[_msgSender()] = _rTotal;\n\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        uniswapV2Router = _uniswapV2Router;\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[_developmentAddress] = true;\n        _isExcludedFromFee[_marketingAddress] = true;\n\n\n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n\n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public pure override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    function tokenFromReflection(uint256 rAmount)\n        private\n        view\n        returns (uint256)\n    {\n        require(\n            rAmount <= _rTotal,\n            \"Amount must be less than total reflections\"\n        );\n        uint256 currentRate = _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function removeAllFee() private {\n        if (_redisFee == 0 && _taxFee == 0) return;\n\n        _previousredisFee = _redisFee;\n        _previoustaxFee = _taxFee;\n\n        _redisFee = 0;\n        _taxFee = 0;\n    }\n\n    function restoreAllFee() private {\n        _redisFee = _previousredisFee;\n        _taxFee = _previoustaxFee;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        if (from != owner() && to != owner()) {\n\n            //Trade start check\n            if (!tradingOpen) {\n                require(from == owner(), \"TOKEN: This account cannot send tokens until trading is enabled\");\n            }\n\n            require(amount <= _maxTxAmount, \"TOKEN: Max Transaction Limit\");\n            require(!bots[from] && !bots[to], \"TOKEN: Your account is blacklisted!\");\n\n            if(to != uniswapV2Pair) {\n                require(balanceOf(to) + amount < _maxWalletSize, \"TOKEN: Balance exceeds wallet size!\");\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            bool canSwap = contractTokenBalance >= _swapTokensAtAmount;\n\n            if(contractTokenBalance >= _maxTxAmount)\n            {\n                contractTokenBalance = _maxTxAmount;\n            }\n\n            if (canSwap && !inSwap && from != uniswapV2Pair && swapEnabled && !_isExcludedFromFee[from] && !_isExcludedFromFee[to]) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if (contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }\n\n        bool takeFee = true;\n\n        //Transfer Tokens\n        if ((_isExcludedFromFee[from] || _isExcludedFromFee[to]) || (from != uniswapV2Pair && to != uniswapV2Pair)) {\n            takeFee = false;\n        } else {\n\n            //Set Fee for Buys\n            if(from == uniswapV2Pair && to != address(uniswapV2Router)) {\n                _redisFee = _redisFeeOnBuy;\n                _taxFee = _taxFeeOnBuy;\n            }\n\n            //Set Fee for Sells\n            if (to == uniswapV2Pair && from != address(uniswapV2Router)) {\n                _redisFee = _redisFeeOnSell;\n                _taxFee = _taxFeeOnSell;\n            }\n\n        }\n\n        _tokenTransfer(from, to, amount, takeFee);\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function sendETHToFee(uint256 amount) private {\n        _developmentAddress.transfer(amount.div(2));\n        _marketingAddress.transfer(amount.div(2));\n    }\n\n    function setTrading(bool _tradingOpen) public onlyOwner {\n        tradingOpen = _tradingOpen;\n    }\n\n    function manualswap() external {\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\n        uint256 contractBalance = balanceOf(address(this));\n        swapTokensForEth(contractBalance);\n    }\n\n    function manualsend() external {\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\n        uint256 contractETHBalance = address(this).balance;\n        sendETHToFee(contractETHBalance);\n    }\n\n    function blockBots(address[] memory bots_) public onlyOwner {\n        for (uint256 i = 0; i < bots_.length; i++) {\n            bots[bots_[i]] = true;\n        }\n    }\n\n    function unblockBot(address notbot) public onlyOwner {\n        bots[notbot] = false;\n    }\n\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bool takeFee\n    ) private {\n        if (!takeFee) removeAllFee();\n        _transferStandard(sender, recipient, amount);\n        if (!takeFee) restoreAllFee();\n    }\n\n    function _transferStandard(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        (\n            uint256 rAmount,\n            uint256 rTransferAmount,\n            uint256 rFee,\n            uint256 tTransferAmount,\n            uint256 tFee,\n            uint256 tTeam\n        ) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeTeam(tTeam);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _takeTeam(uint256 tTeam) private {\n        uint256 currentRate = _getRate();\n        uint256 rTeam = tTeam.mul(currentRate);\n        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    receive() external payable {}\n\n    function _getValues(uint256 tAmount)\n        private\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) =\n            _getTValues(tAmount, _redisFee, _taxFee);\n        uint256 currentRate = _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) =\n            _getRValues(tAmount, tFee, tTeam, currentRate);\n\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n    }\n\n    function _getTValues(\n        uint256 tAmount,\n        uint256 redisFee,\n        uint256 taxFee\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 tFee = tAmount.mul(redisFee).div(100);\n        uint256 tTeam = tAmount.mul(taxFee).div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n\n        return (tTransferAmount, tFee, tTeam);\n    }\n\n    function _getRValues(\n        uint256 tAmount,\n        uint256 tFee,\n        uint256 tTeam,\n        uint256 currentRate\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTeam = tTeam.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns (uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns (uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n\n        return (rSupply, tSupply);\n    }\n\n    function setFee(uint256 redisFeeOnBuy, uint256 redisFeeOnSell, uint256 taxFeeOnBuy, uint256 taxFeeOnSell) public onlyOwner {\n        _redisFeeOnBuy = redisFeeOnBuy;\n        _redisFeeOnSell = redisFeeOnSell;\n\n        _taxFeeOnBuy = taxFeeOnBuy;\n        _taxFeeOnSell = taxFeeOnSell;\n    }\n\n    //Set minimum tokens required to swap.\n    function setMinSwapTokensThreshold(uint256 swapTokensAtAmount) public onlyOwner {\n        _swapTokensAtAmount = swapTokensAtAmount;\n    }\n\n    //Set minimum tokens required to swap.\n    function toggleSwap(bool _swapEnabled) public onlyOwner {\n        swapEnabled = _swapEnabled;\n    }\n\n\n    //Set MAx transaction\n    function setMaxTxnAmount(uint256 maxTxAmount) public onlyOwner {\n        _maxTxAmount = maxTxAmount;\n    }\n\n    function setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {\n        _maxWalletSize = maxWalletSize;\n    }\n\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\n        for(uint256 i = 0; i < accounts.length; i++) {\n            _isExcludedFromFee[accounts[i]] = excluded;\n        }\n    }\n}",
    "vulnerability_type": "reentrancy"
  },
  {
    "address": "0x41be2f5463d8790316e98577cfee823607673bb6",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-05-15\n*/\n\n/**\n *Submitted for verification at Etherscan.io on 2019-10-22\n*/\n\npragma solidity ^0.4.23;\n\n// File: contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts/lifecycle/Pausable.sol\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n \n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: contracts/math/SafeMath.sol\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/ERC20/ERC20Basic.sol\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: contracts/ERC20/BasicToken.sol\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: contracts/ERC20/ERC20.sol\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: contracts/ERC20/StandardToken.sol\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n}\n\n// File: contracts/ERC20/PausableToken.sol\n\n/**\n * @title Pausable token\n * @dev StandardToken modified with pausable transfers.\n **/\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(\n    address _to,\n    uint256 _value\n  )\n    public\n    whenNotPaused\n    returns (bool)\n  {\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    whenNotPaused\n    returns (bool)\n  {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  function approve(\n    address _spender,\n    uint256 _value\n  )\n    public\n    whenNotPaused\n    returns (bool)\n  {\n    return super.approve(_spender, _value);\n  }\n\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    whenNotPaused\n    returns (bool success)\n  {\n    return super.increaseApproval(_spender, _addedValue);\n  }\n\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    whenNotPaused\n    returns (bool success)\n  {\n    return super.decreaseApproval(_spender, _subtractedValue);\n  }\n}\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ASD {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function burn(uint256 _value) public;\n}\n\n\ncontract AscendEXSouvenir is PausableToken {\n    using SafeMath for uint256;\n\n    string  public  constant name = \"AscendEX Souvenir token\";\n    string  public  constant symbol = \"ASDS\";\n    uint8   public  constant decimals = 18;\n    uint256 public  constant limit =  100 * 10**8 * 10 ** 18;\n\n    // AscendEX token smart contract address\n    address private ASDAddress = 0xff742d05420B6Aca4481F635aD8341F81A6300C2;\n\n    constructor()  public   {\n        paused = true; // set  no  transaction;\n\n        // init totalSupply_\n        totalSupply_ = 4854497281.556 * 10 ** 18;\n\n        balances[this] = totalSupply_;\n        emit Transfer(address(0x0), this, totalSupply_);\n    }\n\n    function setASDAddress(address _newAddress) public onlyOwner {\n        // owner can re-assign the admin\n        require(_newAddress != address(0));\n        ASDAddress = _newAddress;\n    }\n\n    // burn by contract and swap ASDS to contract address\n    function swap(uint256 _value) public onlyOwner  returns (bool) {\n        require(totalSupply_.add(_value) <= limit);\n\n        ASD asd = ASD(ASDAddress);\n        asd.burn(_value);\n\n        totalSupply_ = totalSupply_.add(_value);\n        balances[this] = balances[this].add(_value);\n        emit Transfer(address(0), this, _value);\n\n        return true;\n    }\n\n    // burn by contract but swap ASDS to _to address\n    function swapto(address _to,uint256 _value) public onlyOwner  returns (bool) {\n        require(totalSupply_.add(_value) <= limit);\n\n        ASD asd = ASD(ASDAddress);\n        asd.burn(_value);\n\n        totalSupply_ = totalSupply_.add(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(address(0), _to, _value);\n\n        return true;\n    }\n\n    // fill burn ASD token by others\n    function fill() public onlyOwner  returns (bool) {\n        ASD asd = ASD(ASDAddress);\n        uint256 total = asd.totalSupply();\n\n        uint256 _value = limit.sub(total).sub(totalSupply_);\n\n        totalSupply_ = totalSupply_.add(_value);\n        balances[this] = balances[this].add(_value);\n        emit Transfer(address(0), this, _value);\n\n        return true;\n    }\n\n    function send(address _to, uint256 _value) public onlyOwner whenNotPaused returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[this]);\n\n        balances[this] = balances[this].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(this, _to, _value);\n\n        return true;\n    }\n}",
    "vulnerability_type": "reentrancy"
  },
  {
    "address": "0x41c9e11d10528a03ff15d9b7e36e2a1fa21898b8",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-11-17\n*/\n\n/**\n *Submitted for verification at Etherscan.io on 2021-11-11\n*/\n\n/*\n\nTelegram : https://t.me/sigmaerc20\nWebsite : thesigmachad.com\n\n*/\n\n\npragma solidity ^0.8.4;\n// SPDX-License-Identifier: Unlicensed\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\n \nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n    address private _previousOwner;\n    uint256 private _lockTime;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n     /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n}\n\n// pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\n\n// pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\n// pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\n\n\n// pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\n\ncontract SIGMA is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcludedFromFee;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n    \n    mapping (address => bool) private _isBlackListedBot;\n    address[] private _blackListedBots;\n    \n   \n    uint256 private constant MAX = ~uint256(0);\n\n    uint256 private _tTotal = 1000000 * 10**6 * 10**9;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = \"SIGMA\";\n    string private _symbol = \"SIGMA\";\n    uint8 private _decimals = 9;\n    \n    uint256 public _taxFee;\n    uint256 private _previousTaxFee = _taxFee;\n\n    uint256 public _devFee;\n    uint256 private _previousDevFee = _devFee;\n\n    address payable public _devWalletAddress;\n\n    IUniswapV2Router02 public immutable uniswapV2Router;\n    address public immutable uniswapV2Pair;\n    \n    bool inSwapAndSend;\n    bool public swapAndSendEnabled = true;\n    \n    bool private tradingEnabled = false;\n    \n    uint256 public _maxTxAmount = 10000 * 10**6 * 10**9;\n    uint256 private numTokensSellToAddToLiquidity = 500 * 10**6 * 10**9;\n    \n    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\n    address private _admin;\n    event SwapAndSendEnabledUpdated(bool enabled);\n    event SwapAndSend(\n        uint256 tokensSwapped,\n        uint256 ethReceived\n    );\n    \n    modifier lockTheSwap {\n        inSwapAndSend = true;\n        _;\n        inSwapAndSend = false;\n    }\n    \n    constructor (address payable devWalletAddress) {\n        _devWalletAddress = devWalletAddress;\n        _admin = _msgSender();\n        _rOwned[_msgSender()] = _rTotal;\n\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n         // Create a uniswap pair for this new token\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n\n        // set the rest of the contract variables\n        uniswapV2Router = _uniswapV2Router;\n        \n        //exclude owner and this contract from fee\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        \n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    \n    function setDevFeeDisabled(bool _devFeeEnabled ) public returns (bool){\n        require(msg.sender == _admin, \"OnlyAdmin can disable dev fee\");\n        swapAndSendEnabled = _devFeeEnabled;\n        return(swapAndSendEnabled);\n    }\n    \n    \n    /*depl address can always change fees to lower than 10 to allow the project to scale*/\n    function setTaxFee(uint256 taxFee, uint256 devFee ) public {\n        require(msg.sender == _admin, \"OnlyAdmin can disable dev fee\");\n        require(taxFee<12, \"Reflection tax can not be greater than 10\");\n        require(devFee<12, \"Dev tax can not be greater than 10\");\n        require(devFee.add(taxFee)<16, \"Total Fees cannot be greater than 15\");\n        _taxFee = devFee;\n        _devFee = devFee;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcludedFromReward(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function deliver(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeFromReward(address account) public onlyOwner() {\n        // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeInReward(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n    \n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n    \n    function excludeFromFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = true;\n    }\n    \n    function includeInFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = false;\n    }\n    \n    function _setdevWallet(address payable devWalletAddress) external onlyOwner() {\n        _devWalletAddress = devWalletAddress;\n    }\n    \n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\n        _maxTxAmount = _tTotal.mul(maxTxPercent).div(\n            10**2\n        );\n    }\n\n    function setSwapAndSendEnabled(bool _enabled) public onlyOwner {\n        swapAndSendEnabled = _enabled;\n        emit SwapAndSendEnabledUpdated(_enabled);\n    }\n    \n        \n    function manualswap() external {\n        require(_msgSender() == _admin);\n        uint256 contractBalance = balanceOf(address(this));\n        swapTokensForEth(contractBalance);\n    }\n    \n    function manualsend() external {\n        require(_msgSender() == _admin);\n        uint256 contractETHBalance = address(this).balance;\n        sendETHTodev(contractETHBalance);\n    }\n    \n     //to recieve ETH from uniswapV2Router when swaping\n    receive() external payable {}\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, _getRate());\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);\n    }\n\n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) {\n        uint256 tFee = calculateTaxFee(tAmount);\n        uint256 tLiquidity = calculateDevFee(tAmount);\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity);\n        return (tTransferAmount, tFee, tLiquidity);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rLiquidity = tLiquidity.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n    \n    function _takeLiquidity(uint256 tLiquidity) private {\n        uint256 currentRate =  _getRate();\n        uint256 rLiquidity = tLiquidity.mul(currentRate);\n        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);\n        if(_isExcluded[address(this)])\n            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);\n    }\n    \n    function calculateTaxFee(uint256 _amount) private view returns (uint256) {\n        return _amount.mul(_taxFee).div(\n            10**2\n        );\n    }\n\n    function calculateDevFee(uint256 _amount) private view returns (uint256) {\n        return _amount.mul(_devFee).div(\n            10**2\n        );\n    }\n    \n    function addBotToBlackList(address account) external onlyOwner() {\n        require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not blacklist Uniswap router.');\n        require(!_isBlackListedBot[account], \"Account is already blacklisted\");\n        _isBlackListedBot[account] = true;\n        _blackListedBots.push(account);\n    }\n\n    function removeBotFromBlackList(address account) external onlyOwner() {\n        require(_isBlackListedBot[account], \"Account is not blacklisted\");\n        for (uint256 i = 0; i < _blackListedBots.length; i++) {\n            if (_blackListedBots[i] == account) {\n                _blackListedBots[i] = _blackListedBots[_blackListedBots.length - 1];\n                _isBlackListedBot[account] = false;\n                _blackListedBots.pop();\n                break;\n            }\n        }\n    }\n    \n    function openTrading() external onlyOwner() {\n        require(!tradingEnabled, \"Trading has already Been enabled\");\n        _taxFee = 2;\n        _devFee = 10;\n        tradingEnabled = true;\n        swapAndSendEnabled = true;\n    }\n    \n    \n    function removeAllFee() private {\n        if(_taxFee == 0 && _devFee == 0) return;\n        \n        _previousTaxFee = _taxFee;\n        _previousDevFee = _devFee;\n        \n        _taxFee = 0;\n        _devFee = 0;\n    }\n    \n    function restoreAllFee() private {\n        _taxFee = _previousTaxFee;\n        _devFee = _previousDevFee;\n    }\n    \n    function isExcludedFromFee(address account) public view returns(bool) {\n        return _isExcludedFromFee[account];\n    }\n    \n    function getDevFee() public view returns(uint256) {\n        return _devFee;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        \n        require(!_isBlackListedBot[to], \"You have no power here!\");\n        require(!_isBlackListedBot[msg.sender], \"You have no power here!\");\n        require(!_isBlackListedBot[from], \"You have no power here!\");\n        \n        \n        if(from != owner() && to != owner()) {\n            require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n            require(tradingEnabled, \"Trading has not been enabled\");\n        }\n        // is the token balance of this contract address over the min number of\n        // tokens that we need to initiate a swap + liquidity lock?\n        // also, don't get caught in a circular liquidity event.\n        // also, don't swap & liquify if sender is uniswap pair.\n        uint256 contractTokenBalance = balanceOf(address(this));\n        \n        if(contractTokenBalance >= _maxTxAmount)\n        {\n            contractTokenBalance = _maxTxAmount;\n        }\n        \n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\n        if (\n            overMinTokenBalance &&\n            !inSwapAndSend &&\n            from != uniswapV2Pair &&\n            swapAndSendEnabled\n        ) {\n            //add liquidity\n            swapAndSend(contractTokenBalance);\n        }\n        \n        //indicates if fee should be deducted from transfer\n        bool takeFee = true;\n        \n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n            takeFee = false;\n        }\n        \n        //transfer amount, it will take tax, burn, liquidity fee\n        _tokenTransfer(from,to,amount,takeFee);\n    }\n\n    function swapAndSend(uint256 contractTokenBalance) private lockTheSwap {\n        // split the contract balance into halves\n        uint256 tokenBalance = contractTokenBalance;\n\n        // capture the contract's current ETH balance.\n        // this is so that we can capture exactly the amount of ETH that the\n        // swap creates, and not make the liquidity event include any ETH that\n        // has been manually sent to the contract\n        uint256 initialBalance = address(this).balance;\n\n        // swap tokens for ETH\n        swapTokensForEth(tokenBalance); // <-  breaks the ETH -> HATE swap when swap+liquify is triggered\n\n        // how much ETH did we just swap into?\n        uint256 newBalance = address(this).balance.sub(initialBalance);\n\n        sendETHTodev(newBalance);\n        // add liquidity to uniswap\n        \n        emit SwapAndSend(tokenBalance, newBalance);\n    }\n\n    function sendETHTodev(uint256 amount) private {\n      _devWalletAddress.transfer(amount);\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) private {\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // make the swap\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    //this method is responsible for taking all fee, if takeFee is true\n    function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\n        if(!takeFee)\n            removeAllFee();\n        \n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferStandard(sender, recipient, amount);\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n        \n        if(!takeFee)\n            restoreAllFee();\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n}",
    "vulnerability_type": "reentrancy"
  },
  {
    "address": "0x41d25082b49116cc809b0e0ab31a0c5d8d3288eb",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-06-30\n*/\n\npragma solidity =0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address to, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Ownable {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed from, address indexed to);\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Ownable: Caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(address transferOwner) external onlyOwner {\n        require(transferOwner != newOwner);\n        newOwner = transferOwner;\n    }\n\n    function acceptOwnership() virtual public {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\ncontract ERC20ToBEP20Wrapper is Ownable {\n    struct UnwrapInfo {\n        uint amount;\n        uint fee;\n        uint bscNonce;\n    }\n\n    IERC20 public immutable NBU;\n    uint public minWrapAmount;\n\n    mapping(address => uint) public userWrapNonces;\n    mapping(address => uint) public userUnwrapNonces;\n    mapping(address => mapping(uint => uint)) public bscToEthUserUnwrapNonces;\n    mapping(address => mapping(uint => uint)) public wraps;\n    mapping(address => mapping(uint => UnwrapInfo)) public unwraps;\n\n    event Wrap(address indexed user, uint indexed wrapNonce, uint amount);\n    event Unwrap(address indexed user, uint indexed unwrapNonce, uint indexed bscNonce, uint amount, uint fee);\n    event UpdateMinWrapAmount(uint indexed amount);\n    event Rescue(address indexed to, uint amount);\n    event RescueToken(address token, address indexed to, uint amount);\n\n    constructor(address nbu) {\n        NBU = IERC20(nbu);\n    }\n    \n    function wrap(uint amount) external {\n        require(amount >= minWrapAmount, \"ERC20ToBEP20Wrapper: Value too small\");\n        \n        require(NBU.transferFrom(msg.sender, address(this), amount), \"ERC20ToBEP20Wrapper: Error transferring\");\n        uint userWrapNonce = ++userWrapNonces[msg.sender];\n        wraps[msg.sender][userWrapNonce] = amount;\n        emit Wrap(msg.sender, userWrapNonce, amount);\n    }\n\n    function unwrapBatch(address[] memory users, uint[] memory amounts, uint[] memory fees, uint[] memory bscNonces) external onlyOwner {\n        require(users.length == amounts.length && users.length == fees.length && users.length == bscNonces.length, \"ERC20ToBEP20Wrapper: wrong lengths\");\n        for (uint256 i = 0; i < users.length; i++) {\n            _unwrap(users[i], amounts[i], fees[i], bscNonces[i]);\n        }\n    }\n\n    function unwrap(address user, uint amount, uint fee, uint bscNonce) external onlyOwner {\n        _unwrap(user, amount, fee, bscNonce);\n    }\n\n    function _unwrap(address user, uint amount, uint fee, uint bscNonce) private {\n        require(user != address(0), \"ERC20ToBEP20Wrapper: Can't be zero address\");\n        require(bscToEthUserUnwrapNonces[user][bscNonce] == 0, \"ERC20ToBEP20Wrapper: Already processed\");\n        require(amount >= fee, \"ERC20ToBEP20Wrapper: Fee ig greater than amount\");\n        \n        require(NBU.transfer(user, amount - fee), \"ERC20ToBEP20Wrapper: Error transferring\");\n        uint unwrapNonce = ++userUnwrapNonces[user];\n        bscToEthUserUnwrapNonces[user][bscNonce] = unwrapNonce;\n        unwraps[user][unwrapNonce].amount = amount;\n        unwraps[user][unwrapNonce].fee = fee;\n        unwraps[user][unwrapNonce].bscNonce = bscNonce;\n        emit Unwrap(user, unwrapNonce, bscNonce, amount, fee);\n    }\n\n    //Admin functions\n    function rescue(address payable to, uint256 amount) external onlyOwner {\n        require(to != address(0), \"ERC20ToBEP20Wrapper: Can't be zero address\");\n        require(amount > 0, \"ERC20ToBEP20Wrapper: Should be greater than 0\");\n        TransferHelper.safeTransferETH(to, amount);\n        emit Rescue(to, amount);\n    }\n\n    function rescue(address to, address token, uint256 amount) external onlyOwner {\n        require(to != address(0), \"ERC20ToBEP20Wrapper: Can't be zero address\");\n        require(amount > 0, \"ERC20ToBEP20Wrapper: Should be greater than 0\");\n        TransferHelper.safeTransfer(token, to, amount);\n        emit RescueToken(token, to, amount);\n    }\n\n    function updateMinWrapAmount(uint amount) external onlyOwner {\n        require(amount > 0, \"ERC20ToBEP20Wrapper: Should be greater than 0\");\n        minWrapAmount = amount;\n        emit UpdateMinWrapAmount(amount);\n    }\n}",
    "vulnerability_type": "reentrancy"
  },
  {
    "address": "0x41d85e1df7ed165897f91194535927554bd3705e",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-07-24\n*/\n\n// t.me/NecroMeme\n// 14% TAX Total - 7% on Sells | 7% on Buys\n// No MAX TX\n// No blacklists, renounce will happen early on blacklist function is not working\n// No retarded drains\n// SPDX-License-Identifier: Unlicensed\n\npragma solidity ^0.6.12;\n\n    abstract contract Context {\n        function _msgSender() internal view virtual returns (address payable) {\n            return msg.sender;\n        }\n\n        function _msgData() internal view virtual returns (bytes memory) {\n            this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n            return msg.data;\n        }\n    }\n\n    interface IERC20 {\n        /**\n        * @dev Returns the amount of tokens in existence.\n        */\n        function totalSupply() external view returns (uint256);\n\n        /**\n        * @dev Returns the amount of tokens owned by `account`.\n        */\n        function balanceOf(address account) external view returns (uint256);\n\n        /**\n        * @dev Moves `amount` tokens from the caller's account to `recipient`.\n        *\n        * Returns a boolean value indicating whether the operation succeeded.\n        *\n        * Emits a {Transfer} event.\n        */\n        function transfer(address recipient, uint256 amount) external returns (bool);\n\n        /**\n        * @dev Returns the remaining number of tokens that `spender` will be\n        * allowed to spend on behalf of `owner` through {transferFrom}. This is\n        * zero by default.\n        *\n        * This value changes when {approve} or {transferFrom} are called.\n        */\n        function allowance(address owner, address spender) external view returns (uint256);\n\n        /**\n        * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n        *\n        * Returns a boolean value indicating whether the operation succeeded.\n        *\n        * IMPORTANT: Beware that changing an allowance with this method brings the risk\n        * that someone may use both the old and the new allowance by unfortunate\n        * transaction ordering. One possible solution to mitigate this race\n        * condition is to first reduce the spender's allowance to 0 and set the\n        * desired value afterwards:\n        * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        *\n        * Emits an {Approval} event.\n        */\n        function approve(address spender, uint256 amount) external returns (bool);\n\n        /**\n        * @dev Moves `amount` tokens from `sender` to `recipient` using the\n        * allowance mechanism. `amount` is then deducted from the caller's\n        * allowance.\n        *\n        * Returns a boolean value indicating whether the operation succeeded.\n        *\n        * Emits a {Transfer} event.\n        */\n        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n        /**\n        * @dev Emitted when `value` tokens are moved from one account (`from`) to\n        * another (`to`).\n        *\n        * Note that `value` may be zero.\n        */\n        event Transfer(address indexed from, address indexed to, uint256 value);\n\n        /**\n        * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n        * a call to {approve}. `value` is the new allowance.\n        */\n        event Approval(address indexed owner, address indexed spender, uint256 value);\n    }\n\n    library SafeMath {\n        /**\n        * @dev Returns the addition of two unsigned integers, reverting on\n        * overflow.\n        *\n        * Counterpart to Solidity's `+` operator.\n        *\n        * Requirements:\n        *\n        * - Addition cannot overflow.\n        */\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\n            uint256 c = a + b;\n            require(c >= a, \"SafeMath: addition overflow\");\n\n            return c;\n        }\n\n        /**\n        * @dev Returns the subtraction of two unsigned integers, reverting on\n        * overflow (when the result is negative).\n        *\n        * Counterpart to Solidity's `-` operator.\n        *\n        * Requirements:\n        *\n        * - Subtraction cannot overflow.\n        */\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n            return sub(a, b, \"SafeMath: subtraction overflow\");\n        }\n\n        /**\n        * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n        * overflow (when the result is negative).\n        *\n        * Counterpart to Solidity's `-` operator.\n        *\n        * Requirements:\n        *\n        * - Subtraction cannot overflow.\n        */\n        function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n            require(b <= a, errorMessage);\n            uint256 c = a - b;\n\n            return c;\n        }\n\n        /**\n        * @dev Returns the multiplication of two unsigned integers, reverting on\n        * overflow.\n        *\n        * Counterpart to Solidity's `*` operator.\n        *\n        * Requirements:\n        *\n        * - Multiplication cannot overflow.\n        */\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) {\n                return 0;\n            }\n\n            uint256 c = a * b;\n            require(c / a == b, \"SafeMath: multiplication overflow\");\n\n            return c;\n        }\n\n        /**\n        * @dev Returns the integer division of two unsigned integers. Reverts on\n        * division by zero. The result is rounded towards zero.\n        *\n        * Counterpart to Solidity's `/` operator. Note: this function uses a\n        * `revert` opcode (which leaves remaining gas untouched) while Solidity\n        * uses an invalid opcode to revert (consuming all remaining gas).\n        *\n        * Requirements:\n        *\n        * - The divisor cannot be zero.\n        */\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\n            return div(a, b, \"SafeMath: division by zero\");\n        }\n\n        /**\n        * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n        * division by zero. The result is rounded towards zero.\n        *\n        * Counterpart to Solidity's `/` operator. Note: this function uses a\n        * `revert` opcode (which leaves remaining gas untouched) while Solidity\n        * uses an invalid opcode to revert (consuming all remaining gas).\n        *\n        * Requirements:\n        *\n        * - The divisor cannot be zero.\n        */\n        function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n            require(b > 0, errorMessage);\n            uint256 c = a / b;\n            // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n            return c;\n        }\n\n        /**\n        * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n        * Reverts when dividing by zero.\n        *\n        * Counterpart to Solidity's `%` operator. This function uses a `revert`\n        * opcode (which leaves remaining gas untouched) while Solidity uses an\n        * invalid opcode to revert (consuming all remaining gas).\n        *\n        * Requirements:\n        *\n        * - The divisor cannot be zero.\n        */\n        function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n            return mod(a, b, \"SafeMath: modulo by zero\");\n        }\n\n        /**\n        * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n        * Reverts with custom message when dividing by zero.\n        *\n        * Counterpart to Solidity's `%` operator. This function uses a `revert`\n        * opcode (which leaves remaining gas untouched) while Solidity uses an\n        * invalid opcode to revert (consuming all remaining gas).\n        *\n        * Requirements:\n        *\n        * - The divisor cannot be zero.\n        */\n        function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n            require(b != 0, errorMessage);\n            return a % b;\n        }\n    }\n\n    library Address {\n        /**\n        * @dev Returns true if `account` is a contract.\n        *\n        * [IMPORTANT]\n        * ====\n        * It is unsafe to assume that an address for which this function returns\n        * false is an externally-owned account (EOA) and not a contract.\n        *\n        * Among others, `isContract` will return false for the following\n        * types of addresses:\n        *\n        *  - an externally-owned account\n        *  - a contract in construction\n        *  - an address where a contract will be created\n        *  - an address where a contract lived, but was destroyed\n        * ====\n        */\n        function isContract(address account) internal view returns (bool) {\n            // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n            // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n            // for accounts without code, i.e. `keccak256('')`\n            bytes32 codehash;\n            bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n            // solhint-disable-next-line no-inline-assembly\n            assembly { codehash := extcodehash(account) }\n            return (codehash != accountHash && codehash != 0x0);\n        }\n\n        /**\n        * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n        * `recipient`, forwarding all available gas and reverting on errors.\n        *\n        * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n        * of certain opcodes, possibly making contracts go over the 2300 gas limit\n        * imposed by `transfer`, making them unable to receive funds via\n        * `transfer`. {sendValue} removes this limitation.\n        *\n        * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n        *\n        * IMPORTANT: because control is transferred to `recipient`, care must be\n        * taken to not create reentrancy vulnerabilities. Consider using\n        * {ReentrancyGuard} or the\n        * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n        */\n        function sendValue(address payable recipient, uint256 amount) internal {\n            require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n            // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n            (bool success, ) = recipient.call{ value: amount }(\"\");\n            require(success, \"Address: unable to send value, recipient may have reverted\");\n        }\n\n        /**\n        * @dev Performs a Solidity function call using a low level `call`. A\n        * plain`call` is an unsafe replacement for a function call: use this\n        * function instead.\n        *\n        * If `target` reverts with a revert reason, it is bubbled up by this\n        * function (like regular Solidity function calls).\n        *\n        * Returns the raw returned data. To convert to the expected return value,\n        * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n        *\n        * Requirements:\n        *\n        * - `target` must be a contract.\n        * - calling `target` with `data` must not revert.\n        *\n        * _Available since v3.1._\n        */\n        function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n        }\n\n        /**\n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n        * `errorMessage` as a fallback revert reason when `target` reverts.\n        *\n        * _Available since v3.1._\n        */\n        function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n            return _functionCallWithValue(target, data, 0, errorMessage);\n        }\n\n        /**\n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n        * but also transferring `value` wei to `target`.\n        *\n        * Requirements:\n        *\n        * - the calling contract must have an ETH balance of at least `value`.\n        * - the called Solidity function must be `payable`.\n        *\n        * _Available since v3.1._\n        */\n        function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n            return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n        }\n\n        /**\n        * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n        * with `errorMessage` as a fallback revert reason when `target` reverts.\n        *\n        * _Available since v3.1._\n        */\n        function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n            require(address(this).balance >= value, \"Address: insufficient balance for call\");\n            return _functionCallWithValue(target, data, value, errorMessage);\n        }\n\n        function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n            require(isContract(target), \"Address: call to non-contract\");\n\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n            if (success) {\n                return returndata;\n            } else {\n                // Look for revert reason and bubble it up if present\n                if (returndata.length > 0) {\n                    // The easiest way to bubble the revert reason is using memory via assembly\n\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        let returndata_size := mload(returndata)\n                        revert(add(32, returndata), returndata_size)\n                    }\n                } else {\n                    revert(errorMessage);\n                }\n            }\n        }\n    }\n\n    contract Ownable is Context {\n        address private _owner;\n        address private _previousOwner;\n        uint256 private _lockTime;\n\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        /**\n        * @dev Initializes the contract setting the deployer as the initial owner.\n        */\n        constructor () internal {\n            address msgSender = _msgSender();\n            _owner = msgSender;\n            emit OwnershipTransferred(address(0), msgSender);\n        }\n\n        /**\n        * @dev Returns the address of the current owner.\n        */\n        function owner() public view returns (address) {\n            return _owner;\n        }\n\n        /**\n        * @dev Throws if called by any account other than the owner.\n        */\n        modifier onlyOwner() {\n            require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n            _;\n        }\n\n        /**\n        * @dev Leaves the contract without owner. It will not be possible to call\n        * `onlyOwner` functions anymore. Can only be called by the current owner.\n        *\n        * NOTE: Renouncing ownership will leave the contract without an owner,\n        * thereby removing any functionality that is only available to the owner.\n        */\n        function renounceOwnership() public virtual onlyOwner {\n            emit OwnershipTransferred(_owner, address(0));\n            _owner = address(0);\n        }\n\n        /**\n        * @dev Transfers ownership of the contract to a new account (`newOwner`).\n        * Can only be called by the current owner.\n        */\n        function transferOwnership(address newOwner) public virtual onlyOwner {\n            require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n            emit OwnershipTransferred(_owner, newOwner);\n            _owner = newOwner;\n        }\n\n        function geUnlockTime() public view returns (uint256) {\n            return _lockTime;\n        }\n\n        //Locks the contract for owner for the amount of time provided\n        function lock(uint256 time) public virtual onlyOwner {\n            _previousOwner = _owner;\n            _owner = address(0);\n            _lockTime = now + time;\n            emit OwnershipTransferred(_owner, address(0));\n        }\n        \n        //Unlocks the contract for owner when _lockTime is exceeds\n        function unlock() public virtual {\n            require(_previousOwner == msg.sender, \"You don't have permission to unlock\");\n            require(now > _lockTime , \"Contract is locked until 7 days\");\n            emit OwnershipTransferred(_owner, _previousOwner);\n            _owner = _previousOwner;\n        }\n    }  \n\n    interface IUniswapV2Factory {\n        event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n        function feeTo() external view returns (address);\n        function feeToSetter() external view returns (address);\n\n        function getPair(address tokenA, address tokenB) external view returns (address pair);\n        function allPairs(uint) external view returns (address pair);\n        function allPairsLength() external view returns (uint);\n\n        function createPair(address tokenA, address tokenB) external returns (address pair);\n\n        function setFeeTo(address) external;\n        function setFeeToSetter(address) external;\n    } \n\n    interface IUniswapV2Pair {\n        event Approval(address indexed owner, address indexed spender, uint value);\n        event Transfer(address indexed from, address indexed to, uint value);\n\n        function name() external pure returns (string memory);\n        function symbol() external pure returns (string memory);\n        function decimals() external pure returns (uint8);\n        function totalSupply() external view returns (uint);\n        function balanceOf(address owner) external view returns (uint);\n        function allowance(address owner, address spender) external view returns (uint);\n\n        function approve(address spender, uint value) external returns (bool);\n        function transfer(address to, uint value) external returns (bool);\n        function transferFrom(address from, address to, uint value) external returns (bool);\n\n        function DOMAIN_SEPARATOR() external view returns (bytes32);\n        function PERMIT_TYPEHASH() external pure returns (bytes32);\n        function nonces(address owner) external view returns (uint);\n\n        function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n        event Mint(address indexed sender, uint amount0, uint amount1);\n        event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n        event Swap(\n            address indexed sender,\n            uint amount0In,\n            uint amount1In,\n            uint amount0Out,\n            uint amount1Out,\n            address indexed to\n        );\n        event Sync(uint112 reserve0, uint112 reserve1);\n\n        function MINIMUM_LIQUIDITY() external pure returns (uint);\n        function factory() external view returns (address);\n        function token0() external view returns (address);\n        function token1() external view returns (address);\n        function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n        function price0CumulativeLast() external view returns (uint);\n        function price1CumulativeLast() external view returns (uint);\n        function kLast() external view returns (uint);\n\n        function mint(address to) external returns (uint liquidity);\n        function burn(address to) external returns (uint amount0, uint amount1);\n        function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n        function skim(address to) external;\n        function sync() external;\n\n        function initialize(address, address) external;\n    }\n\n    interface IUniswapV2Router01 {\n        function factory() external pure returns (address);\n        function WETH() external pure returns (address);\n\n        function addLiquidity(\n            address tokenA,\n            address tokenB,\n            uint amountADesired,\n            uint amountBDesired,\n            uint amountAMin,\n            uint amountBMin,\n            address to,\n            uint deadline\n        ) external returns (uint amountA, uint amountB, uint liquidity);\n        function addLiquidityETH(\n            address token,\n            uint amountTokenDesired,\n            uint amountTokenMin,\n            uint amountETHMin,\n            address to,\n            uint deadline\n        ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n        function removeLiquidity(\n            address tokenA,\n            address tokenB,\n            uint liquidity,\n            uint amountAMin,\n            uint amountBMin,\n            address to,\n            uint deadline\n        ) external returns (uint amountA, uint amountB);\n        function removeLiquidityETH(\n            address token,\n            uint liquidity,\n            uint amountTokenMin,\n            uint amountETHMin,\n            address to,\n            uint deadline\n        ) external returns (uint amountToken, uint amountETH);\n        function removeLiquidityWithPermit(\n            address tokenA,\n            address tokenB,\n            uint liquidity,\n            uint amountAMin,\n            uint amountBMin,\n            address to,\n            uint deadline,\n            bool approveMax, uint8 v, bytes32 r, bytes32 s\n        ) external returns (uint amountA, uint amountB);\n        function removeLiquidityETHWithPermit(\n            address token,\n            uint liquidity,\n            uint amountTokenMin,\n            uint amountETHMin,\n            address to,\n            uint deadline,\n            bool approveMax, uint8 v, bytes32 r, bytes32 s\n        ) external returns (uint amountToken, uint amountETH);\n        function swapExactTokensForTokens(\n            uint amountIn,\n            uint amountOutMin,\n            address[] calldata path,\n            address to,\n            uint deadline\n        ) external returns (uint[] memory amounts);\n        function swapTokensForExactTokens(\n            uint amountOut,\n            uint amountInMax,\n            address[] calldata path,\n            address to,\n            uint deadline\n        ) external returns (uint[] memory amounts);\n        function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n            external\n            payable\n            returns (uint[] memory amounts);\n        function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n            external\n            returns (uint[] memory amounts);\n        function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n            external\n            returns (uint[] memory amounts);\n        function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n            external\n            payable\n            returns (uint[] memory amounts);\n\n        function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n        function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n        function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n        function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n        function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n    }\n\n    interface IUniswapV2Router02 is IUniswapV2Router01 {\n        function removeLiquidityETHSupportingFeeOnTransferTokens(\n            address token,\n            uint liquidity,\n            uint amountTokenMin,\n            uint amountETHMin,\n            address to,\n            uint deadline\n        ) external returns (uint amountETH);\n        function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n            address token,\n            uint liquidity,\n            uint amountTokenMin,\n            uint amountETHMin,\n            address to,\n            uint deadline,\n            bool approveMax, uint8 v, bytes32 r, bytes32 s\n        ) external returns (uint amountETH);\n\n        function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            uint amountIn,\n            uint amountOutMin,\n            address[] calldata path,\n            address to,\n            uint deadline\n        ) external;\n        function swapExactETHForTokensSupportingFeeOnTransferTokens(\n            uint amountOutMin,\n            address[] calldata path,\n            address to,\n            uint deadline\n        ) external payable;\n        function swapExactTokensForETHSupportingFeeOnTransferTokens(\n            uint amountIn,\n            uint amountOutMin,\n            address[] calldata path,\n            address to,\n            uint deadline\n        ) external;\n    }\n\n    // Contract implementation\n    contract NecroMeme is Context, IERC20, Ownable {\n        using SafeMath for uint256;\n        using Address for address;\n\n        mapping (address => uint256) private _rOwned;\n        mapping (address => uint256) private _tOwned;\n        mapping (address => mapping (address => uint256)) private _allowances;\n\n        mapping (address => bool) private _isExcludedFromFee;\n    \n        mapping (address => bool) private _isExcluded;\n        address[] private _excluded;\n        mapping (address => bool) private _isBlackListedBot;\n        address[] private _blackListedBots;\n    \n        uint256 private constant MAX = ~uint256(0);\n        uint256 private _tTotal = 1000000000000000000000;  //1,000,000,000,000\n        uint256 private _rTotal = (MAX - (MAX % _tTotal));\n        uint256 private _tFeeTotal;\n\n        string private _name = 'NecroMeme';\n        string private _symbol = 'NecroMeme';\n        uint8 private _decimals = 9;\n        \n        // Tax and charity fees will start at 0 so we don't have a big impact when deploying to Uniswap\n        // Charity wallet address is null but the method to set the address is exposed\n        uint256 private _taxFee = 5; \n        uint256 private _charityFee = 5;\n        uint256 private _previousTaxFee = _taxFee;\n        uint256 private _previousCharityFee = _charityFee;\n\n        address payable public _charityWalletAddress;\n        address payable public _marketingWalletAddress;\n        \n        IUniswapV2Router02 public immutable uniswapV2Router;\n        address public immutable uniswapV2Pair;\n\n        bool inSwap = false;\n        bool public swapEnabled = true;\n\n        uint256 public _maxTxAmount = _tTotal; //no max tx limit rn \n        uint256 private _numOfTokensToExchangeForCharity = 5000000000000000;\n\n        event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\n        event SwapEnabledUpdated(bool enabled);\n\n        modifier lockTheSwap {\n            inSwap = true;\n            _;\n            inSwap = false;\n        }\n\n        constructor (address payable charityWalletAddress, address payable marketingWalletAddress) public {\n            _charityWalletAddress = charityWalletAddress;\n            _marketingWalletAddress = marketingWalletAddress;\n            _rOwned[_msgSender()] = _rTotal;\n\n            IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // UniswapV2 for Ethereum network\n            // Create a uniswap pair for this new token\n            uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n                .createPair(address(this), _uniswapV2Router.WETH());\n\n            // set the rest of the contract variables\n            uniswapV2Router = _uniswapV2Router;\n\n            // Exclude owner and this contract from fee\n            _isExcludedFromFee[owner()] = true;\n            _isExcludedFromFee[address(this)] = true;\n            \n            _isBlackListedBot[address(0xE031b36b53E53a292a20c5F08fd1658CDdf74fce)] = true;\n            _blackListedBots.push(address(0xE031b36b53E53a292a20c5F08fd1658CDdf74fce));\n    \n            _isBlackListedBot[address(0xe516bDeE55b0b4e9bAcaF6285130De15589B1345)] = true;\n            _blackListedBots.push(address(0xe516bDeE55b0b4e9bAcaF6285130De15589B1345));\n    \n            _isBlackListedBot[address(0xa1ceC245c456dD1bd9F2815a6955fEf44Eb4191b)] = true;\n            _blackListedBots.push(address(0xa1ceC245c456dD1bd9F2815a6955fEf44Eb4191b));\n    \n            _isBlackListedBot[address(0xd7d3EE77D35D0a56F91542D4905b1a2b1CD7cF95)] = true;\n            _blackListedBots.push(address(0xd7d3EE77D35D0a56F91542D4905b1a2b1CD7cF95));\n    \n            _isBlackListedBot[address(0xFe76f05dc59fEC04184fA0245AD0C3CF9a57b964)] = true;\n            _blackListedBots.push(address(0xFe76f05dc59fEC04184fA0245AD0C3CF9a57b964));\n    \n            _isBlackListedBot[address(0xDC81a3450817A58D00f45C86d0368290088db848)] = true;\n            _blackListedBots.push(address(0xDC81a3450817A58D00f45C86d0368290088db848));\n    \n            _isBlackListedBot[address(0x45fD07C63e5c316540F14b2002B085aEE78E3881)] = true;\n            _blackListedBots.push(address(0x45fD07C63e5c316540F14b2002B085aEE78E3881));\n    \n            _isBlackListedBot[address(0x27F9Adb26D532a41D97e00206114e429ad58c679)] = true;\n            _blackListedBots.push(address(0x27F9Adb26D532a41D97e00206114e429ad58c679));\n            \n            _isBlackListedBot[address(0x9282dc5c422FA91Ff2F6fF3a0b45B7BF97CF78E7)] = true;\n            _blackListedBots.push(address(0x9282dc5c422FA91Ff2F6fF3a0b45B7BF97CF78E7));\n            \n            _isBlackListedBot[address(0xfad95B6089c53A0D1d861eabFaadd8901b0F8533)] = true;\n            _blackListedBots.push(address(0xfad95B6089c53A0D1d861eabFaadd8901b0F8533));\n            \n            _isBlackListedBot[address(0x1d6E8BAC6EA3730825bde4B005ed7B2B39A2932d)] = true;\n            _blackListedBots.push(address(0x1d6E8BAC6EA3730825bde4B005ed7B2B39A2932d));\n            \n            _isBlackListedBot[address(0x000000000000084e91743124a982076C59f10084)] = true;\n            _blackListedBots.push(address(0x000000000000084e91743124a982076C59f10084));\n\n            _isBlackListedBot[address(0x6dA4bEa09C3aA0761b09b19837D9105a52254303)] = true;\n            _blackListedBots.push(address(0x6dA4bEa09C3aA0761b09b19837D9105a52254303));\n            \n            _isBlackListedBot[address(0x323b7F37d382A68B0195b873aF17CeA5B67cd595)] = true;\n            _blackListedBots.push(address(0x323b7F37d382A68B0195b873aF17CeA5B67cd595));\n            \n            _isBlackListedBot[address(0x000000005804B22091aa9830E50459A15E7C9241)] = true;\n            _blackListedBots.push(address(0x000000005804B22091aa9830E50459A15E7C9241));\n            \n            _isBlackListedBot[address(0xA3b0e79935815730d942A444A84d4Bd14A339553)] = true;\n            _blackListedBots.push(address(0xA3b0e79935815730d942A444A84d4Bd14A339553));\n            \n            _isBlackListedBot[address(0xf6da21E95D74767009acCB145b96897aC3630BaD)] = true;\n            _blackListedBots.push(address(0xf6da21E95D74767009acCB145b96897aC3630BaD));\n            \n            _isBlackListedBot[address(0x0000000000007673393729D5618DC555FD13f9aA)] = true;\n            _blackListedBots.push(address(0x0000000000007673393729D5618DC555FD13f9aA));\n            \n            _isBlackListedBot[address(0x00000000000003441d59DdE9A90BFfb1CD3fABf1)] = true;\n            _blackListedBots.push(address(0x00000000000003441d59DdE9A90BFfb1CD3fABf1));\n            \n            _isBlackListedBot[address(0x59903993Ae67Bf48F10832E9BE28935FEE04d6F6)] = true;\n            _blackListedBots.push(address(0x59903993Ae67Bf48F10832E9BE28935FEE04d6F6));\n            \n            _isBlackListedBot[address(0x000000917de6037d52b1F0a306eeCD208405f7cd)] = true;\n            _blackListedBots.push(address(0x000000917de6037d52b1F0a306eeCD208405f7cd));\n            \n            _isBlackListedBot[address(0x7100e690554B1c2FD01E8648db88bE235C1E6514)] = true;\n            _blackListedBots.push(address(0x7100e690554B1c2FD01E8648db88bE235C1E6514));\n            \n            _isBlackListedBot[address(0x72b30cDc1583224381132D379A052A6B10725415)] = true;\n            _blackListedBots.push(address(0x72b30cDc1583224381132D379A052A6B10725415));\n            \n            _isBlackListedBot[address(0x9eDD647D7d6Eceae6bB61D7785Ef66c5055A9bEE)] = true;\n            _blackListedBots.push(address(0x9eDD647D7d6Eceae6bB61D7785Ef66c5055A9bEE));\n\n            _isBlackListedBot[address(0xfe9d99ef02E905127239E85A611c29ad32c31c2F)] = true;\n            _blackListedBots.push(address(0xfe9d99ef02E905127239E85A611c29ad32c31c2F));\n            \n            _isBlackListedBot[address(0x39608b6f20704889C51C0Ae28b1FCA8F36A5239b)] = true;\n            _blackListedBots.push(address(0x39608b6f20704889C51C0Ae28b1FCA8F36A5239b));\n            \n            _isBlackListedBot[address(0xc496D84215d5018f6F53E7F6f12E45c9b5e8e8A9)] = true;\n            _blackListedBots.push(address(0xc496D84215d5018f6F53E7F6f12E45c9b5e8e8A9));\n\n            _isBlackListedBot[address(0x59341Bc6b4f3Ace878574b05914f43309dd678c7)] = true;\n            _blackListedBots.push(address(0x59341Bc6b4f3Ace878574b05914f43309dd678c7));\n\n            _isBlackListedBot[address(0xe986d48EfeE9ec1B8F66CD0b0aE8e3D18F091bDF)] = true;\n            _blackListedBots.push(address(0xe986d48EfeE9ec1B8F66CD0b0aE8e3D18F091bDF));\n\n            _isBlackListedBot[address(0x4aEB32e16DcaC00B092596ADc6CD4955EfdEE290)] = true;\n            _blackListedBots.push(address(0x4aEB32e16DcaC00B092596ADc6CD4955EfdEE290));\n            \n            _isBlackListedBot[address(0x136F4B5b6A306091b280E3F251fa0E21b1280Cd5)] = true;\n            _blackListedBots.push(address(0x136F4B5b6A306091b280E3F251fa0E21b1280Cd5));\n            \n            _isBlackListedBot[address(0x39608b6f20704889C51C0Ae28b1FCA8F36A5239b)] = true;\n            _blackListedBots.push(address(0x39608b6f20704889C51C0Ae28b1FCA8F36A5239b));\n            \n            _isBlackListedBot[address(0x5B83A351500B631cc2a20a665ee17f0dC66e3dB7)] = true;\n            _blackListedBots.push(address(0x5B83A351500B631cc2a20a665ee17f0dC66e3dB7));\n            \n            \n            emit Transfer(address(0), _msgSender(), _tTotal);\n        }\n\n        function name() public view returns (string memory) {\n            return _name;\n        }\n\n        function symbol() public view returns (string memory) {\n            return _symbol;\n        }\n\n        function decimals() public view returns (uint8) {\n            return _decimals;\n        }\n\n        function totalSupply() public view override returns (uint256) {\n            return _tTotal;\n        }\n\n        function balanceOf(address account) public view override returns (uint256) {\n            if (_isExcluded[account]) return _tOwned[account];\n            return tokenFromReflection(_rOwned[account]);\n        }\n\n        function transfer(address recipient, uint256 amount) public override returns (bool) {\n            _transfer(_msgSender(), recipient, amount);\n            return true;\n        }\n\n        function allowance(address owner, address spender) public view override returns (uint256) {\n            return _allowances[owner][spender];\n        }\n\n        function approve(address spender, uint256 amount) public override returns (bool) {\n            _approve(_msgSender(), spender, amount);\n            return true;\n        }\n\n        function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n            _transfer(sender, recipient, amount);\n            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n            return true;\n        }\n\n        function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n            _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n            return true;\n        }\n\n        function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n            _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n            return true;\n        }\n\n        function isExcluded(address account) public view returns (bool) {\n            return _isExcluded[account];\n        }\n        \n        function isBlackListed(address account) public view returns (bool) {\n            return _isBlackListedBot[account];\n        }\n\n        function setExcludeFromFee(address account, bool excluded) external onlyOwner() {\n            _isExcludedFromFee[account] = excluded;\n        }\n\n        function totalFees() public view returns (uint256) {\n            return _tFeeTotal;\n        }\n\n        function deliver(uint256 tAmount) public {\n            address sender = _msgSender();\n            require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n            (uint256 rAmount,,,,,) = _getValues(tAmount);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _rTotal = _rTotal.sub(rAmount);\n            _tFeeTotal = _tFeeTotal.add(tAmount);\n        }\n\n        function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n            require(tAmount <= _tTotal, \"Amount must be less than supply\");\n            if (!deductTransferFee) {\n                (uint256 rAmount,,,,,) = _getValues(tAmount);\n                return rAmount;\n            } else {\n                (,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n                return rTransferAmount;\n            }\n        }\n\n        function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n            require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n            uint256 currentRate =  _getRate();\n            return rAmount.div(currentRate);\n        }\n\n        function excludeAccount(address account) external onlyOwner() {\n            require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');\n            require(!_isExcluded[account], \"Account is already excluded\");\n            if(_rOwned[account] > 0) {\n                _tOwned[account] = tokenFromReflection(_rOwned[account]);\n            }\n            _isExcluded[account] = true;\n            _excluded.push(account);\n        }\n\n        function includeAccount(address account) external onlyOwner() {\n            require(_isExcluded[account], \"Account is already excluded\");\n            for (uint256 i = 0; i < _excluded.length; i++) {\n                if (_excluded[i] == account) {\n                    _excluded[i] = _excluded[_excluded.length - 1];\n                    _tOwned[account] = 0;\n                    _isExcluded[account] = false;\n                    _excluded.pop();\n                    break;\n                }\n            }\n        }\n        \n        function addBotToBlackList(address account) external onlyOwner() {\n            require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not blacklist Uniswap router.');\n            require(!_isBlackListedBot[account], \"Account is already blacklisted\");\n            _isBlackListedBot[account] = true;\n            _blackListedBots.push(account);\n        }\n    \n        function removeBotFromBlackList(address account) external onlyOwner() {\n            require(_isBlackListedBot[account], \"Account is not blacklisted\");\n            for (uint256 i = 0; i < _blackListedBots.length; i++) {\n                if (_blackListedBots[i] == account) {\n                    _blackListedBots[i] = _blackListedBots[_blackListedBots.length - 1];\n                    _isBlackListedBot[account] = false;\n                    _blackListedBots.pop();\n                    break;\n                }\n            }\n        }\n\n        function removeAllFee() private {\n            if(_taxFee == 0 && _charityFee == 0) return;\n            \n            _previousTaxFee = _taxFee;\n            _previousCharityFee = _charityFee;\n            \n            _taxFee = 0;\n            _charityFee = 0;\n        }\n    \n        function restoreAllFee() private {\n            _taxFee = _previousTaxFee;\n            _charityFee = _previousCharityFee;\n        }\n    \n        function isExcludedFromFee(address account) public view returns(bool) {\n            return _isExcludedFromFee[account];\n        }\n        \n            function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\n        _maxTxAmount = _tTotal.mul(maxTxPercent).div(\n            10**2\n        );\n        }\n\n        function _approve(address owner, address spender, uint256 amount) private {\n            require(owner != address(0), \"ERC20: approve from the zero address\");\n            require(spender != address(0), \"ERC20: approve to the zero address\");\n\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n\n        function _transfer(address sender, address recipient, uint256 amount) private {\n            require(sender != address(0), \"ERC20: transfer from the zero address\");\n            require(recipient != address(0), \"ERC20: transfer to the zero address\");\n            require(amount > 0, \"Transfer amount must be greater than zero\");\n            require(!_isBlackListedBot[recipient], \"You have no power here!\");\n            require(!_isBlackListedBot[msg.sender], \"You have no power here!\");\n            \n            if(sender != owner() && recipient != owner())\n                require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n\n            // is the token balance of this contract address over the min number of\n            // tokens that we need to initiate a swap?\n            // also, don't get caught in a circular charity event.\n            // also, don't swap if sender is uniswap pair.\n            uint256 contractTokenBalance = balanceOf(address(this));\n            \n            if(contractTokenBalance >= _maxTxAmount)\n            {\n                contractTokenBalance = _maxTxAmount;\n            }\n            \n            bool overMinTokenBalance = contractTokenBalance >= _numOfTokensToExchangeForCharity;\n            if (!inSwap && swapEnabled && overMinTokenBalance && sender != uniswapV2Pair) {\n                // We need to swap the current tokens to ETH and send to the charity wallet\n                swapTokensForEth(contractTokenBalance);\n                \n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToCharity(address(this).balance);\n                }\n            }\n            \n            //indicates if fee should be deducted from transfer\n            bool takeFee = true;\n            \n            //if any account belongs to _isExcludedFromFee account then remove the fee\n            if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){\n                takeFee = false;\n            }\n            \n            //transfer amount, it will take tax and charity fee\n            _tokenTransfer(sender,recipient,amount,takeFee);\n        }\n\n        function swapTokensForEth(uint256 tokenAmount) private lockTheSwap{\n            // generate the uniswap pair path of token -> weth\n            address[] memory path = new address[](2);\n            path[0] = address(this);\n            path[1] = uniswapV2Router.WETH();\n\n            _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n            // make the swap\n            uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n                tokenAmount,\n                0, // accept any amount of ETH\n                path,\n                address(this),\n                block.timestamp\n            );\n        }\n        \n        function sendETHToCharity(uint256 amount) private {\n            _charityWalletAddress.transfer(amount.div(2));\n            _marketingWalletAddress.transfer(amount.div(2));\n        }\n        \n        // We are exposing these functions to be able to manual swap and send\n        // in case the token is highly valued and 5M becomes too much\n        function manualSwap() external onlyOwner() {\n            uint256 contractBalance = balanceOf(address(this));\n            swapTokensForEth(contractBalance);\n        }\n        \n        function manualSend() external onlyOwner() {\n            uint256 contractETHBalance = address(this).balance;\n            sendETHToCharity(contractETHBalance);\n        }\n\n        function setSwapEnabled(bool enabled) external onlyOwner(){\n            swapEnabled = enabled;\n        }\n        \n        function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\n            if(!takeFee)\n                removeAllFee();\n\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferToExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferStandard(sender, recipient, amount);\n            } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferBothExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n\n            if(!takeFee)\n                restoreAllFee();\n        }\n\n        function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n            _takeCharity(tCharity); \n            _reflectFee(rFee, tFee);\n            emit Transfer(sender, recipient, tTransferAmount);\n        }\n\n        function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n            _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);    \n            _takeCharity(tCharity);           \n            _reflectFee(rFee, tFee);\n            emit Transfer(sender, recipient, tTransferAmount);\n        }\n\n        function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);\n            _tOwned[sender] = _tOwned[sender].sub(tAmount);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n            _takeCharity(tCharity);   \n            _reflectFee(rFee, tFee);\n            emit Transfer(sender, recipient, tTransferAmount);\n        }\n\n        function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);\n            _tOwned[sender] = _tOwned[sender].sub(tAmount);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n            _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n            _takeCharity(tCharity);         \n            _reflectFee(rFee, tFee);\n            emit Transfer(sender, recipient, tTransferAmount);\n        }\n\n        function _takeCharity(uint256 tCharity) private {\n            uint256 currentRate =  _getRate();\n            uint256 rCharity = tCharity.mul(currentRate);\n            _rOwned[address(this)] = _rOwned[address(this)].add(rCharity);\n            if(_isExcluded[address(this)])\n                _tOwned[address(this)] = _tOwned[address(this)].add(tCharity);\n        }\n\n        function _reflectFee(uint256 rFee, uint256 tFee) private {\n            _rTotal = _rTotal.sub(rFee);\n            _tFeeTotal = _tFeeTotal.add(tFee);\n        }\n\n         //to recieve ETH from uniswapV2Router when swaping\n        receive() external payable {}\n\n        function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n            (uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getTValues(tAmount, _taxFee, _charityFee);\n            uint256 currentRate =  _getRate();\n            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n            return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tCharity);\n        }\n\n        function _getTValues(uint256 tAmount, uint256 taxFee, uint256 charityFee) private pure returns (uint256, uint256, uint256) {\n            uint256 tFee = tAmount.mul(taxFee).div(100);\n            uint256 tCharity = tAmount.mul(charityFee).div(100);\n            uint256 tTransferAmount = tAmount.sub(tFee).sub(tCharity);\n            return (tTransferAmount, tFee, tCharity);\n        }\n\n        function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n            uint256 rAmount = tAmount.mul(currentRate);\n            uint256 rFee = tFee.mul(currentRate);\n            uint256 rTransferAmount = rAmount.sub(rFee);\n            return (rAmount, rTransferAmount, rFee);\n        }\n\n        function _getRate() private view returns(uint256) {\n            (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n            return rSupply.div(tSupply);\n        }\n\n        function _getCurrentSupply() private view returns(uint256, uint256) {\n            uint256 rSupply = _rTotal;\n            uint256 tSupply = _tTotal;      \n            for (uint256 i = 0; i < _excluded.length; i++) {\n                if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n                rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n                tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n            }\n            if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n            return (rSupply, tSupply);\n        }\n        \n        function _getTaxFee() private view returns(uint256) {\n            return _taxFee;\n        }\n\n        function _getMaxTxAmount() private view returns(uint256) {\n            return _maxTxAmount;\n        }\n\n        function _getETHBalance() public view returns(uint256 balance) {\n            return address(this).balance;\n        }\n        \n        function _setTaxFee(uint256 taxFee) external onlyOwner() {\n            require(taxFee >= 1 && taxFee <= 10, 'taxFee should be in 1 - 10');\n            _taxFee = taxFee;\n        }\n\n        function _setCharityFee(uint256 charityFee) external onlyOwner() {\n            require(charityFee >= 1 && charityFee <= 11, 'charityFee should be in 1 - 11');\n            _charityFee = charityFee;\n        }\n        \n        function _setCharityWallet(address payable charityWalletAddress) external onlyOwner() {\n            _charityWalletAddress = charityWalletAddress;\n        }\n        \n        \n    }",
    "vulnerability_type": "reentrancy"
  },
  {
    "address": "0x420904134ffd1badbd1df179fa7d02105d1d69bb",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-06-22\n*/\n\n/**\n *Submitted for verification at Etherscan.io on 2021-04-23\n*/\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.6.12;\n\n    abstract contract Context {\n        function _msgSender() internal view virtual returns (address payable) {\n            return msg.sender;\n        }\n\n        function _msgData() internal view virtual returns (bytes memory) {\n            this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n            return msg.data;\n        }\n    }\n\n    interface IERC20 {\n        /**\n        * @dev Returns the amount of tokens in existence.\n        */\n        function totalSupply() external view returns (uint256);\n\n        /**\n        * @dev Returns the amount of tokens owned by `account`.\n        */\n        function balanceOf(address account) external view returns (uint256);\n\n        /**\n        * @dev Moves `amount` tokens from the caller's account to `recipient`.\n        *\n        * Returns a boolean value indicating whether the operation succeeded.\n        *\n        * Emits a {Transfer} event.\n        */\n        function transfer(address recipient, uint256 amount) external returns (bool);\n\n        /**\n        * @dev Returns the remaining number of tokens that `spender` will be\n        * allowed to spend on behalf of `owner` through {transferFrom}. This is\n        * zero by default.\n        *\n        * This value changes when {approve} or {transferFrom} are called.\n        */\n        function allowance(address owner, address spender) external view returns (uint256);\n\n        /**\n        * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n        *\n        * Returns a boolean value indicating whether the operation succeeded.\n        *\n        * IMPORTANT: Beware that changing an allowance with this method brings the risk\n        * that someone may use both the old and the new allowance by unfortunate\n        * transaction ordering. One possible solution to mitigate this race\n        * condition is to first reduce the spender's allowance to 0 and set the\n        * desired value afterwards:\n        * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        *\n        * Emits an {Approval} event.\n        */\n        function approve(address spender, uint256 amount) external returns (bool);\n\n        /**\n        * @dev Moves `amount` tokens from `sender` to `recipient` using the\n        * allowance mechanism. `amount` is then deducted from the caller's\n        * allowance.\n        *\n        * Returns a boolean value indicating whether the operation succeeded.\n        *\n        * Emits a {Transfer} event.\n        */\n        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n        /**\n        * @dev Emitted when `value` tokens are moved from one account (`from`) to\n        * another (`to`).\n        *\n        * Note that `value` may be zero.\n        */\n        event Transfer(address indexed from, address indexed to, uint256 value);\n\n        /**\n        * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n        * a call to {approve}. `value` is the new allowance.\n        */\n        event Approval(address indexed owner, address indexed spender, uint256 value);\n    }\n\n    library SafeMath {\n        /**\n        * @dev Returns the addition of two unsigned integers, reverting on\n        * overflow.\n        *\n        * Counterpart to Solidity's `+` operator.\n        *\n        * Requirements:\n        *\n        * - Addition cannot overflow.\n        */\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\n            uint256 c = a + b;\n            require(c >= a, \"SafeMath: addition overflow\");\n\n            return c;\n        }\n\n        /**\n        * @dev Returns the subtraction of two unsigned integers, reverting on\n        * overflow (when the result is negative).\n        *\n        * Counterpart to Solidity's `-` operator.\n        *\n        * Requirements:\n        *\n        * - Subtraction cannot overflow.\n        */\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n            return sub(a, b, \"SafeMath: subtraction overflow\");\n        }\n\n        /**\n        * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n        * overflow (when the result is negative).\n        *\n        * Counterpart to Solidity's `-` operator.\n        *\n        * Requirements:\n        *\n        * - Subtraction cannot overflow.\n        */\n        function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n            require(b <= a, errorMessage);\n            uint256 c = a - b;\n\n            return c;\n        }\n\n        /**\n        * @dev Returns the multiplication of two unsigned integers, reverting on\n        * overflow.\n        *\n        * Counterpart to Solidity's `*` operator.\n        *\n        * Requirements:\n        *\n        * - Multiplication cannot overflow.\n        */\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) {\n                return 0;\n            }\n\n            uint256 c = a * b;\n            require(c / a == b, \"SafeMath: multiplication overflow\");\n\n            return c;\n        }\n\n        /**\n        * @dev Returns the integer division of two unsigned integers. Reverts on\n        * division by zero. The result is rounded towards zero.\n        *\n        * Counterpart to Solidity's `/` operator. Note: this function uses a\n        * `revert` opcode (which leaves remaining gas untouched) while Solidity\n        * uses an invalid opcode to revert (consuming all remaining gas).\n        *\n        * Requirements:\n        *\n        * - The divisor cannot be zero.\n        */\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\n            return div(a, b, \"SafeMath: division by zero\");\n        }\n\n        /**\n        * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n        * division by zero. The result is rounded towards zero.\n        *\n        * Counterpart to Solidity's `/` operator. Note: this function uses a\n        * `revert` opcode (which leaves remaining gas untouched) while Solidity\n        * uses an invalid opcode to revert (consuming all remaining gas).\n        *\n        * Requirements:\n        *\n        * - The divisor cannot be zero.\n        */\n        function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n            require(b > 0, errorMessage);\n            uint256 c = a / b;\n            // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n            return c;\n        }\n\n        /**\n        * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n        * Reverts when dividing by zero.\n        *\n        * Counterpart to Solidity's `%` operator. This function uses a `revert`\n        * opcode (which leaves remaining gas untouched) while Solidity uses an\n        * invalid opcode to revert (consuming all remaining gas).\n        *\n        * Requirements:\n        *\n        * - The divisor cannot be zero.\n        */\n        function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n            return mod(a, b, \"SafeMath: modulo by zero\");\n        }\n\n        /**\n        * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n        * Reverts with custom message when dividing by zero.\n        *\n        * Counterpart to Solidity's `%` operator. This function uses a `revert`\n        * opcode (which leaves remaining gas untouched) while Solidity uses an\n        * invalid opcode to revert (consuming all remaining gas).\n        *\n        * Requirements:\n        *\n        * - The divisor cannot be zero.\n        */\n        function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n            require(b != 0, errorMessage);\n            return a % b;\n        }\n    }\n\n    library Address {\n        /**\n        * @dev Returns true if `account` is a contract.\n        *\n        * [IMPORTANT]\n        * ====\n        * It is unsafe to assume that an address for which this function returns\n        * false is an externally-owned account (EOA) and not a contract.\n        *\n        * Among others, `isContract` will return false for the following\n        * types of addresses:\n        *\n        *  - an externally-owned account\n        *  - a contract in construction\n        *  - an address where a contract will be created\n        *  - an address where a contract lived, but was destroyed\n        * ====\n        */\n        function isContract(address account) internal view returns (bool) {\n            // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n            // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n            // for accounts without code, i.e. `keccak256('')`\n            bytes32 codehash;\n            bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n            // solhint-disable-next-line no-inline-assembly\n            assembly { codehash := extcodehash(account) }\n            return (codehash != accountHash && codehash != 0x0);\n        }\n\n        /**\n        * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n        * `recipient`, forwarding all available gas and reverting on errors.\n        *\n        * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n        * of certain opcodes, possibly making contracts go over the 2300 gas limit\n        * imposed by `transfer`, making them unable to receive funds via\n        * `transfer`. {sendValue} removes this limitation.\n        *\n        * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n        *\n        * IMPORTANT: because control is transferred to `recipient`, care must be\n        * taken to not create reentrancy vulnerabilities. Consider using\n        * {ReentrancyGuard} or the\n        * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n        */\n        function sendValue(address payable recipient, uint256 amount) internal {\n            require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n            // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n            (bool success, ) = recipient.call{ value: amount }(\"\");\n            require(success, \"Address: unable to send value, recipient may have reverted\");\n        }\n\n        /**\n        * @dev Performs a Solidity function call using a low level `call`. A\n        * plain`call` is an unsafe replacement for a function call: use this\n        * function instead.\n        *\n        * If `target` reverts with a revert reason, it is bubbled up by this\n        * function (like regular Solidity function calls).\n        *\n        * Returns the raw returned data. To convert to the expected return value,\n        * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n        *\n        * Requirements:\n        *\n        * - `target` must be a contract.\n        * - calling `target` with `data` must not revert.\n        *\n        * _Available since v3.1._\n        */\n        function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n        }\n\n        /**\n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n        * `errorMessage` as a fallback revert reason when `target` reverts.\n        *\n        * _Available since v3.1._\n        */\n        function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n            return _functionCallWithValue(target, data, 0, errorMessage);\n        }\n\n        /**\n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n        * but also transferring `value` wei to `target`.\n        *\n        * Requirements:\n        *\n        * - the calling contract must have an ETH balance of at least `value`.\n        * - the called Solidity function must be `payable`.\n        *\n        * _Available since v3.1._\n        */\n        function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n            return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n        }\n\n        /**\n        * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n        * with `errorMessage` as a fallback revert reason when `target` reverts.\n        *\n        * _Available since v3.1._\n        */\n        function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n            require(address(this).balance >= value, \"Address: insufficient balance for call\");\n            return _functionCallWithValue(target, data, value, errorMessage);\n        }\n\n        function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n            require(isContract(target), \"Address: call to non-contract\");\n\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n            if (success) {\n                return returndata;\n            } else {\n                // Look for revert reason and bubble it up if present\n                if (returndata.length > 0) {\n                    // The easiest way to bubble the revert reason is using memory via assembly\n\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        let returndata_size := mload(returndata)\n                        revert(add(32, returndata), returndata_size)\n                    }\n                } else {\n                    revert(errorMessage);\n                }\n            }\n        }\n    }\n\n    contract Ownable is Context {\n        address private _owner;\n        address private _previousOwner;\n        uint256 private _lockTime;\n\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        /**\n        * @dev Initializes the contract setting the deployer as the initial owner.\n        */\n        constructor () internal {\n            address msgSender = _msgSender();\n            _owner = msgSender;\n            emit OwnershipTransferred(address(0), msgSender);\n        }\n\n        /**\n        * @dev Returns the address of the current owner.\n        */\n        function owner() public view returns (address) {\n            return _owner;\n        }\n\n        /**\n        * @dev Throws if called by any account other than the owner.\n        */\n        modifier onlyOwner() {\n            require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n            _;\n        }\n\n        /**\n        * @dev Leaves the contract without owner. It will not be possible to call\n        * `onlyOwner` functions anymore. Can only be called by the current owner.\n        *\n        * NOTE: Renouncing ownership will leave the contract without an owner,\n        * thereby removing any functionality that is only available to the owner.\n        */\n        function renounceOwnership() public virtual onlyOwner {\n            emit OwnershipTransferred(_owner, address(0));\n            _owner = address(0);\n        }\n\n        /**\n        * @dev Transfers ownership of the contract to a new account (`newOwner`).\n        * Can only be called by the current owner.\n        */\n        function transferOwnership(address newOwner) public virtual onlyOwner {\n            require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n            emit OwnershipTransferred(_owner, newOwner);\n            _owner = newOwner;\n        }\n\n        function geUnlockTime() public view returns (uint256) {\n            return _lockTime;\n        }\n\n        //Locks the contract for owner for the amount of time provided\n        function lock(uint256 time) public virtual onlyOwner {\n            _previousOwner = _owner;\n            _owner = address(0);\n            _lockTime = now + time;\n            emit OwnershipTransferred(_owner, address(0));\n        }\n        \n        //Unlocks the contract for owner when _lockTime is exceeds\n        function unlock() public virtual {\n            require(_previousOwner == msg.sender, \"You don't have permission to unlock\");\n            require(now > _lockTime , \"Contract is locked until 7 days\");\n            emit OwnershipTransferred(_owner, _previousOwner);\n            _owner = _previousOwner;\n        }\n    }  \n\n    interface IUniswapV2Factory {\n        event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n        function feeTo() external view returns (address);\n        function feeToSetter() external view returns (address);\n\n        function getPair(address tokenA, address tokenB) external view returns (address pair);\n        function allPairs(uint) external view returns (address pair);\n        function allPairsLength() external view returns (uint);\n\n        function createPair(address tokenA, address tokenB) external returns (address pair);\n\n        function setFeeTo(address) external;\n        function setFeeToSetter(address) external;\n    } \n\n    interface IUniswapV2Pair {\n        event Approval(address indexed owner, address indexed spender, uint value);\n        event Transfer(address indexed from, address indexed to, uint value);\n\n        function name() external pure returns (string memory);\n        function symbol() external pure returns (string memory);\n        function decimals() external pure returns (uint8);\n        function totalSupply() external view returns (uint);\n        function balanceOf(address owner) external view returns (uint);\n        function allowance(address owner, address spender) external view returns (uint);\n\n        function approve(address spender, uint value) external returns (bool);\n        function transfer(address to, uint value) external returns (bool);\n        function transferFrom(address from, address to, uint value) external returns (bool);\n\n        function DOMAIN_SEPARATOR() external view returns (bytes32);\n        function PERMIT_TYPEHASH() external pure returns (bytes32);\n        function nonces(address owner) external view returns (uint);\n\n        function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n        event Mint(address indexed sender, uint amount0, uint amount1);\n        event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n        event Swap(\n            address indexed sender,\n            uint amount0In,\n            uint amount1In,\n            uint amount0Out,\n            uint amount1Out,\n            address indexed to\n        );\n        event Sync(uint112 reserve0, uint112 reserve1);\n\n        function MINIMUM_LIQUIDITY() external pure returns (uint);\n        function factory() external view returns (address);\n        function token0() external view returns (address);\n        function token1() external view returns (address);\n        function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n        function price0CumulativeLast() external view returns (uint);\n        function price1CumulativeLast() external view returns (uint);\n        function kLast() external view returns (uint);\n\n        function mint(address to) external returns (uint liquidity);\n        function burn(address to) external returns (uint amount0, uint amount1);\n        function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n        function skim(address to) external;\n        function sync() external;\n\n        function initialize(address, address) external;\n    }\n\n    interface IUniswapV2Router01 {\n        function factory() external pure returns (address);\n        function WETH() external pure returns (address);\n\n        function addLiquidity(\n            address tokenA,\n            address tokenB,\n            uint amountADesired,\n            uint amountBDesired,\n            uint amountAMin,\n            uint amountBMin,\n            address to,\n            uint deadline\n        ) external returns (uint amountA, uint amountB, uint liquidity);\n        function addLiquidityETH(\n            address token,\n            uint amountTokenDesired,\n            uint amountTokenMin,\n            uint amountETHMin,\n            address to,\n            uint deadline\n        ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n        function removeLiquidity(\n            address tokenA,\n            address tokenB,\n            uint liquidity,\n            uint amountAMin,\n            uint amountBMin,\n            address to,\n            uint deadline\n        ) external returns (uint amountA, uint amountB);\n        function removeLiquidityETH(\n            address token,\n            uint liquidity,\n            uint amountTokenMin,\n            uint amountETHMin,\n            address to,\n            uint deadline\n        ) external returns (uint amountToken, uint amountETH);\n        function removeLiquidityWithPermit(\n            address tokenA,\n            address tokenB,\n            uint liquidity,\n            uint amountAMin,\n            uint amountBMin,\n            address to,\n            uint deadline,\n            bool approveMax, uint8 v, bytes32 r, bytes32 s\n        ) external returns (uint amountA, uint amountB);\n        function removeLiquidityETHWithPermit(\n            address token,\n            uint liquidity,\n            uint amountTokenMin,\n            uint amountETHMin,\n            address to,\n            uint deadline,\n            bool approveMax, uint8 v, bytes32 r, bytes32 s\n        ) external returns (uint amountToken, uint amountETH);\n        function swapExactTokensForTokens(\n            uint amountIn,\n            uint amountOutMin,\n            address[] calldata path,\n            address to,\n            uint deadline\n        ) external returns (uint[] memory amounts);\n        function swapTokensForExactTokens(\n            uint amountOut,\n            uint amountInMax,\n            address[] calldata path,\n            address to,\n            uint deadline\n        ) external returns (uint[] memory amounts);\n        function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n            external\n            payable\n            returns (uint[] memory amounts);\n        function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n            external\n            returns (uint[] memory amounts);\n        function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n            external\n            returns (uint[] memory amounts);\n        function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n            external\n            payable\n            returns (uint[] memory amounts);\n\n        function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n        function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n        function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n        function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n        function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n    }\n\n    interface IUniswapV2Router02 is IUniswapV2Router01 {\n        function removeLiquidityETHSupportingFeeOnTransferTokens(\n            address token,\n            uint liquidity,\n            uint amountTokenMin,\n            uint amountETHMin,\n            address to,\n            uint deadline\n        ) external returns (uint amountETH);\n        function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n            address token,\n            uint liquidity,\n            uint amountTokenMin,\n            uint amountETHMin,\n            address to,\n            uint deadline,\n            bool approveMax, uint8 v, bytes32 r, bytes32 s\n        ) external returns (uint amountETH);\n\n        function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            uint amountIn,\n            uint amountOutMin,\n            address[] calldata path,\n            address to,\n            uint deadline\n        ) external;\n        function swapExactETHForTokensSupportingFeeOnTransferTokens(\n            uint amountOutMin,\n            address[] calldata path,\n            address to,\n            uint deadline\n        ) external payable;\n        function swapExactTokensForETHSupportingFeeOnTransferTokens(\n            uint amountIn,\n            uint amountOutMin,\n            address[] calldata path,\n            address to,\n            uint deadline\n        ) external;\n    }\n\n    // Contract implementation\n    contract YingYangShiba is Context, IERC20, Ownable {\n        using SafeMath for uint256;\n        using Address for address;\n\n        mapping (address => uint256) private _rOwned;\n        mapping (address => uint256) private _tOwned;\n        mapping (address => mapping (address => uint256)) private _allowances;\n\n        mapping (address => bool) private _isExcludedFromFee;\n\n        mapping (address => bool) private _isExcluded;\n        address[] private _excluded;\n    \n        uint256 private constant MAX = ~uint256(0);\n        uint256 private _tTotal = 1000000000000 * 10**9;\n        uint256 private _rTotal = (MAX - (MAX % _tTotal));\n        uint256 private _tFeeTotal;\n\n        string private _name = 'YingYang Shiba';\n        string private _symbol = 'YYIBA';\n        uint8 private _decimals = 9;\n        \n        // Tax and team fees will start at 0 so we don't have a big impact when deploying to Uniswap\n        // Team wallet address is null but the method to set the address is exposed\n        uint256 private _taxFee = 10; \n        uint256 private _teamFee = 10;\n        uint256 private _previousTaxFee = _taxFee;\n        uint256 private _previousTeamFee = _teamFee;\n\n        address payable public _teamWalletAddress;\n        address payable public _marketingWalletAddress;\n        \n        IUniswapV2Router02 public immutable uniswapV2Router;\n        address public immutable uniswapV2Pair;\n\n        bool inSwap = false;\n        bool public swapEnabled = true;\n\n        uint256 private _maxTxAmount = 100000000000000e9;\n        // We will set a minimum amount of tokens to be swaped => 5M\n        uint256 private _numOfTokensToExchangeForTeam = 5 * 10**3 * 10**9;\n\n        event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\n        event SwapEnabledUpdated(bool enabled);\n\n        modifier lockTheSwap {\n            inSwap = true;\n            _;\n            inSwap = false;\n        }\n\n        constructor (address payable teamWalletAddress, address payable marketingWalletAddress) public {\n            _teamWalletAddress = teamWalletAddress;\n            _marketingWalletAddress = marketingWalletAddress;\n            _rOwned[_msgSender()] = _rTotal;\n\n            IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // UniswapV2 for Ethereum network\n            // Create a uniswap pair for this new token\n            uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n                .createPair(address(this), _uniswapV2Router.WETH());\n\n            // set the rest of the contract variables\n            uniswapV2Router = _uniswapV2Router;\n\n            // Exclude owner and this contract from fee\n            _isExcludedFromFee[owner()] = true;\n            _isExcludedFromFee[address(this)] = true;\n\n            emit Transfer(address(0), _msgSender(), _tTotal);\n        }\n\n        function name() public view returns (string memory) {\n            return _name;\n        }\n\n        function symbol() public view returns (string memory) {\n            return _symbol;\n        }\n\n        function decimals() public view returns (uint8) {\n            return _decimals;\n        }\n\n        function totalSupply() public view override returns (uint256) {\n            return _tTotal;\n        }\n\n        function balanceOf(address account) public view override returns (uint256) {\n            if (_isExcluded[account]) return _tOwned[account];\n            return tokenFromReflection(_rOwned[account]);\n        }\n\n        function transfer(address recipient, uint256 amount) public override returns (bool) {\n            _transfer(_msgSender(), recipient, amount);\n            return true;\n        }\n\n        function allowance(address owner, address spender) public view override returns (uint256) {\n            return _allowances[owner][spender];\n        }\n\n        function approve(address spender, uint256 amount) public override returns (bool) {\n            _approve(_msgSender(), spender, amount);\n            return true;\n        }\n\n        function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n            _transfer(sender, recipient, amount);\n            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n            return true;\n        }\n\n        function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n            _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n            return true;\n        }\n\n        function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n            _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n            return true;\n        }\n\n        function isExcluded(address account) public view returns (bool) {\n            return _isExcluded[account];\n        }\n\n        function setExcludeFromFee(address account, bool excluded) external onlyOwner() {\n            _isExcludedFromFee[account] = excluded;\n        }\n\n        function totalFees() public view returns (uint256) {\n            return _tFeeTotal;\n        }\n\n        function deliver(uint256 tAmount) public {\n            address sender = _msgSender();\n            require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n            (uint256 rAmount,,,,,) = _getValues(tAmount);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _rTotal = _rTotal.sub(rAmount);\n            _tFeeTotal = _tFeeTotal.add(tAmount);\n        }\n\n        function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n            require(tAmount <= _tTotal, \"Amount must be less than supply\");\n            if (!deductTransferFee) {\n                (uint256 rAmount,,,,,) = _getValues(tAmount);\n                return rAmount;\n            } else {\n                (,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n                return rTransferAmount;\n            }\n        }\n\n        function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n            require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n            uint256 currentRate =  _getRate();\n            return rAmount.div(currentRate);\n        }\n\n        function excludeAccount(address account) external onlyOwner() {\n            require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');\n            require(!_isExcluded[account], \"Account is already excluded\");\n            if(_rOwned[account] > 0) {\n                _tOwned[account] = tokenFromReflection(_rOwned[account]);\n            }\n            _isExcluded[account] = true;\n            _excluded.push(account);\n        }\n\n        function includeAccount(address account) external onlyOwner() {\n            require(_isExcluded[account], \"Account is already excluded\");\n            for (uint256 i = 0; i < _excluded.length; i++) {\n                if (_excluded[i] == account) {\n                    _excluded[i] = _excluded[_excluded.length - 1];\n                    _tOwned[account] = 0;\n                    _isExcluded[account] = false;\n                    _excluded.pop();\n                    break;\n                }\n            }\n        }\n\n        function removeAllFee() private {\n            if(_taxFee == 0 && _teamFee == 0) return;\n            \n            _previousTaxFee = _taxFee;\n            _previousTeamFee = _teamFee;\n            \n            _taxFee = 0;\n            _teamFee = 0;\n        }\n    \n        function restoreAllFee() private {\n            _taxFee = _previousTaxFee;\n            _teamFee = _previousTeamFee;\n        }\n    \n        function isExcludedFromFee(address account) public view returns(bool) {\n            return _isExcludedFromFee[account];\n        }\n\n        function _approve(address owner, address spender, uint256 amount) private {\n            require(owner != address(0), \"ERC20: approve from the zero address\");\n            require(spender != address(0), \"ERC20: approve to the zero address\");\n\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n\n        function _transfer(address sender, address recipient, uint256 amount) private {\n            require(sender != address(0), \"ERC20: transfer from the zero address\");\n            require(recipient != address(0), \"ERC20: transfer to the zero address\");\n            require(amount > 0, \"Transfer amount must be greater than zero\");\n            \n            if(sender != owner() && recipient != owner())\n                require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n\n            // is the token balance of this contract address over the min number of\n            // tokens that we need to initiate a swap?\n            // also, don't get caught in a circular team event.\n            // also, don't swap if sender is uniswap pair.\n            uint256 contractTokenBalance = balanceOf(address(this));\n            \n            if(contractTokenBalance >= _maxTxAmount)\n            {\n                contractTokenBalance = _maxTxAmount;\n            }\n            \n            bool overMinTokenBalance = contractTokenBalance >= _numOfTokensToExchangeForTeam;\n            if (!inSwap && swapEnabled && overMinTokenBalance && sender != uniswapV2Pair) {\n                // We need to swap the current tokens to ETH and send to the team wallet\n                swapTokensForEth(contractTokenBalance);\n                \n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToTeam(address(this).balance);\n                }\n            }\n            \n            //indicates if fee should be deducted from transfer\n            bool takeFee = true;\n            \n            //if any account belongs to _isExcludedFromFee account then remove the fee\n            if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){\n                takeFee = false;\n            }\n            \n            //transfer amount, it will take tax and team fee\n            _tokenTransfer(sender,recipient,amount,takeFee);\n        }\n\n        function swapTokensForEth(uint256 tokenAmount) private lockTheSwap{\n            // generate the uniswap pair path of token -> weth\n            address[] memory path = new address[](2);\n            path[0] = address(this);\n            path[1] = uniswapV2Router.WETH();\n\n            _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n            // make the swap\n            uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n                tokenAmount,\n                0, // accept any amount of ETH\n                path,\n                address(this),\n                block.timestamp\n            );\n        }\n        \n        function sendETHToTeam(uint256 amount) private {\n            _teamWalletAddress.transfer(amount.div(2));\n            _marketingWalletAddress.transfer(amount.div(2));\n        }\n        \n        // We are exposing these functions to be able to manual swap and send\n        // in case the token is highly valued and 5M becomes too much\n        function manualSwap() external onlyOwner() {\n            uint256 contractBalance = balanceOf(address(this));\n            swapTokensForEth(contractBalance);\n        }\n        \n        function manualSend() external onlyOwner() {\n            uint256 contractETHBalance = address(this).balance;\n            sendETHToTeam(contractETHBalance);\n        }\n\n        function setSwapEnabled(bool enabled) external onlyOwner(){\n            swapEnabled = enabled;\n        }\n        \n        function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\n            if(!takeFee)\n                removeAllFee();\n\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferToExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferStandard(sender, recipient, amount);\n            } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferBothExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n\n            if(!takeFee)\n                restoreAllFee();\n        }\n\n        function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n            _takeTeam(tTeam); \n            _reflectFee(rFee, tFee);\n            emit Transfer(sender, recipient, tTransferAmount);\n        }\n\n        function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n            _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);    \n            _takeTeam(tTeam);           \n            _reflectFee(rFee, tFee);\n            emit Transfer(sender, recipient, tTransferAmount);\n        }\n\n        function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n            _tOwned[sender] = _tOwned[sender].sub(tAmount);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n            _takeTeam(tTeam);   \n            _reflectFee(rFee, tFee);\n            emit Transfer(sender, recipient, tTransferAmount);\n        }\n\n        function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n            _tOwned[sender] = _tOwned[sender].sub(tAmount);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n            _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n            _takeTeam(tTeam);         \n            _reflectFee(rFee, tFee);\n            emit Transfer(sender, recipient, tTransferAmount);\n        }\n\n        function _takeTeam(uint256 tTeam) private {\n            uint256 currentRate =  _getRate();\n            uint256 rTeam = tTeam.mul(currentRate);\n            _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n            if(_isExcluded[address(this)])\n                _tOwned[address(this)] = _tOwned[address(this)].add(tTeam);\n        }\n\n        function _reflectFee(uint256 rFee, uint256 tFee) private {\n            _rTotal = _rTotal.sub(rFee);\n            _tFeeTotal = _tFeeTotal.add(tFee);\n        }\n\n         //to recieve ETH from uniswapV2Router when swaping\n        receive() external payable {}\n\n        function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n            (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _taxFee, _teamFee);\n            uint256 currentRate =  _getRate();\n            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n            return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n        }\n\n        function _getTValues(uint256 tAmount, uint256 taxFee, uint256 teamFee) private pure returns (uint256, uint256, uint256) {\n            uint256 tFee = tAmount.mul(taxFee).div(100);\n            uint256 tTeam = tAmount.mul(teamFee).div(100);\n            uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n            return (tTransferAmount, tFee, tTeam);\n        }\n\n        function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n            uint256 rAmount = tAmount.mul(currentRate);\n            uint256 rFee = tFee.mul(currentRate);\n            uint256 rTransferAmount = rAmount.sub(rFee);\n            return (rAmount, rTransferAmount, rFee);\n        }\n\n        function _getRate() private view returns(uint256) {\n            (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n            return rSupply.div(tSupply);\n        }\n\n        function _getCurrentSupply() private view returns(uint256, uint256) {\n            uint256 rSupply = _rTotal;\n            uint256 tSupply = _tTotal;      \n            for (uint256 i = 0; i < _excluded.length; i++) {\n                if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n                rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n                tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n            }\n            if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n            return (rSupply, tSupply);\n        }\n        \n        function _getTaxFee() private view returns(uint256) {\n            return _taxFee;\n        }\n\n        function _getMaxTxAmount() private view returns(uint256) {\n            return _maxTxAmount;\n        }\n\n        function _getETHBalance() public view returns(uint256 balance) {\n            return address(this).balance;\n        }\n        \n        function _setTaxFee(uint256 taxFee) external onlyOwner() {\n            require(taxFee >= 1 && taxFee <= 25, 'taxFee should be in 1 - 25');\n            _taxFee = taxFee;\n        }\n\n        function _setTeamFee(uint256 teamFee) external onlyOwner() {\n            require(teamFee >= 1 && teamFee <= 25, 'teamFee should be in 1 - 25');\n            _teamFee = teamFee;\n        }\n        \n        function _setTeamWallet(address payable teamWalletAddress) external onlyOwner() {\n            _teamWalletAddress = teamWalletAddress;\n        }\n        \n        function _setMaxTxAmount(uint256 maxTxAmount) external onlyOwner() {\n            require(maxTxAmount >= 100000000000000e9 , 'maxTxAmount should be greater than 100000000000000e9');\n            _maxTxAmount = maxTxAmount;\n        }\n    }",
    "vulnerability_type": "reentrancy"
  },
  {
    "address": "0x4225867ed7a0bcbcd389d4e4a8ce914434fd4ae7",
    "source_code": "pragma solidity ^0.4.21;\n\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender) public view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\n    function approve(address spender, uint256 value) public returns (bool);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeERC20 {\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n        assert(token.transfer(to, value));\n    }\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal{\n        assert(token.transferFrom(from, to, value));\n    }\n}\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a / b;\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract owned {\n    address public owner;\n    function owned() public {\n        owner = msg.sender;\n    }\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function transferOwnership(address newOwner) onlyOwner public {\n        owner = newOwner;\n    }\n}\n\ncontract TOSLittleHodingContract is owned{\n    using SafeERC20 for ERC20;\n    using SafeMath for uint;\n    string public constant name = \"TOSLittleHodingContract\";\n    uint[6] public releasePercentages = [\n        15,  //15%\n        35,   //20%\n        50,   //15%\n        65,   //15%\n        80,   //15%\n        100   //20%\n    ];\n\n    uint256 public constant HOLDING_START               = 1533916800;  //2018/8/11 0:0:0\n    uint256 public constant RELEASE_START               = 1541260800; //2018/11/4 0:0:0\n    uint256 public constant RELEASE_INTERVAL            = 30 days; // 30 days\n    uint256 public RELEASE_END                          = RELEASE_START.add(RELEASE_INTERVAL.mul(5));\n    ERC20 public tosToken = ERC20(0xFb5a551374B656C6e39787B1D3A03fEAb7f3a98E);\n    \n    mapping (address => uint256) public lockBalanceOf; /// reward + principal\n    mapping (address => uint256) public principalsRecords;\n    mapping (address => uint256) public rewards;\n    mapping (address => uint256) public released;\n\n    uint256 public totalLockPrincipal = 0; \n    uint256 public totalLockAmount = 0;\n\n    bool public isReward = false;\n\n    function TOSLittleHodingContract() public {}\n    function lock(uint256 lockAmount) public {\n\n        require(lockAmount > 1 * 10 ** 18);\n        require(now <= HOLDING_START); \n\n        uint256 reward = lockAmount.mul(20).div(100);\n\n        require(reward <= (tosToken.balanceOf(this).sub(totalLockAmount)));\n        tosToken.safeTransferFrom(msg.sender, this, lockAmount);\n\n        lockBalanceOf[msg.sender] = lockBalanceOf[msg.sender].add(lockAmount).add(reward);\n        principalsRecords[msg.sender] = principalsRecords[msg.sender].add(lockAmount);\n        rewards[msg.sender] = rewards[msg.sender].add(reward);\n        totalLockPrincipal = totalLockPrincipal.add(lockAmount);\n        totalLockAmount = totalLockAmount.add(lockAmount).add(reward);\n\n        if (totalLockPrincipal >= 5000000 * 10 ** 18) { //10,000,000\n            isReward = true;\n        }\n    }\n\n    function release() public {\n\n        if (isReward) {\n            _releaseWithReward();\n        }\n        else {\n            _sendBack();\n        }\n    }\n\n    function _sendBack() internal {\n        require(now > HOLDING_START.add(5 minutes));\n        require(principalsRecords[msg.sender] > 0);\n        require(lockBalanceOf[msg.sender] > 0);\n\n        tosToken.safeTransfer(msg.sender, principalsRecords[msg.sender]);\n        lockBalanceOf[msg.sender] = 0;\n        totalLockPrincipal = totalLockPrincipal.sub(principalsRecords[msg.sender]); \n    }\n\n    function _releaseWithReward() internal {\n\n        uint256 num = now.sub(RELEASE_START).div(RELEASE_INTERVAL);\n\n        uint256 releaseAmount = 0;\n        if (num >= releasePercentages.length.sub(1)) {\n            releaseAmount = lockBalanceOf[msg.sender];\n            released[msg.sender] = 100;\n        }\n        else {\n            releaseAmount = principalsRecords[msg.sender].add(rewards[msg.sender]).mul(releasePercentages[num].sub(released[msg.sender])).div(100);\n            released[msg.sender] = releasePercentages[num];\n        }\n\n        require(releaseAmount > 0);\n        tosToken.safeTransfer(msg.sender, releaseAmount);\n        lockBalanceOf[msg.sender] = lockBalanceOf[msg.sender].sub(releaseAmount);\n        totalLockAmount = totalLockAmount.sub(releaseAmount);\n    }\n\n    function remainingReward() public onlyOwner {\n        require(now > HOLDING_START.sub(5 minutes)); \n\n        if (isReward) {\n            require(tosToken.balanceOf(this) > totalLockAmount);\n            tosToken.safeTransfer(owner, tosToken.balanceOf(this).sub(totalLockAmount));\n        }\n        else {\n            require(tosToken.balanceOf(this) > totalLockPrincipal);\n            tosToken.safeTransfer(owner, tosToken.balanceOf(this).sub(totalLockPrincipal));\n        }\n    }\n}",
    "vulnerability_type": "reentrancy"
  },
  {
    "address": "0x422CccC96E3F08EbbF6D0aDfd44DCB4203Ea9940",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2022-04-19\n*/\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.9;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ncontract Ownable is Context {\n    address private _owner;\n    address private _previousOwner;\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n}\n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n}\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n}\n\ncontract BirdBusters is Context, IERC20, Ownable {\n\n    using SafeMath for uint256;\n\n    string private constant _name = \"Bird Busters\";\n    string private constant _symbol = \"BBUST\";\n    uint8 private constant _decimals = 9;\n\n    mapping(address => uint256) private _rOwned;\n    mapping(address => uint256) private _tOwned;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => bool) private _isExcludedFromFee;\n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 100000000000 * 10**9;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n    uint256 private _redisFeeOnBuy = 0;\n    uint256 private _taxFeeOnBuy = 8;\n    uint256 private _redisFeeOnSell = 0;\n    uint256 private _taxFeeOnSell = 8;\n\n    //Original Fee\n    uint256 private _redisFee = _redisFeeOnSell;\n    uint256 private _taxFee = _taxFeeOnSell;\n\n    uint256 private _previousredisFee = _redisFee;\n    uint256 private _previoustaxFee = _taxFee;\n\n    mapping(address => bool) public bots; mapping (address => uint256) public _buyMap;\n    address payable private _developmentAddress = payable(0x27a04D817dd1c39417441A15a667f85133ACBa7e);\n    address payable private _marketingAddress = payable(0x27a04D817dd1c39417441A15a667f85133ACBa7e);\n\n    IUniswapV2Router02 public uniswapV2Router;\n    address public uniswapV2Pair;\n\n    bool private tradingOpen;\n    bool private inSwap = false;\n    bool private swapEnabled = true;\n\n    uint256 public _maxTxAmount = 100000000000 * 10**9;\n    uint256 public _maxWalletSize = 4000000000 * 10**9;\n    uint256 public _swapTokensAtAmount = 3000000000 * 10**9;\n\n    event MaxTxAmountUpdated(uint256 _maxTxAmount);\n    modifier lockTheSwap {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n    constructor() {\n\n        _rOwned[_msgSender()] = _rTotal;\n\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);//\n        uniswapV2Router = _uniswapV2Router;\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[_developmentAddress] = true;\n        _isExcludedFromFee[_marketingAddress] = true;\n\n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n\n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public pure override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    function tokenFromReflection(uint256 rAmount)\n        private\n        view\n        returns (uint256)\n    {\n        require(\n            rAmount <= _rTotal,\n            \"Amount must be less than total reflections\"\n        );\n        uint256 currentRate = _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function removeAllFee() private {\n        if (_redisFee == 0 && _taxFee == 0) return;\n\n        _previousredisFee = _redisFee;\n        _previoustaxFee = _taxFee;\n\n        _redisFee = 0;\n        _taxFee = 0;\n    }\n\n    function restoreAllFee() private {\n        _redisFee = _previousredisFee;\n        _taxFee = _previoustaxFee;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        if (from != owner() && to != owner()) {\n\n            //Trade start check\n            if (!tradingOpen) {\n                require(from == owner(), \"TOKEN: This account cannot send tokens until trading is enabled\");\n            }\n\n            require(amount <= _maxTxAmount, \"TOKEN: Max Transaction Limit\");\n            require(!bots[from] && !bots[to], \"TOKEN: Your account is blacklisted!\");\n\n            if(to != uniswapV2Pair) {\n                require(balanceOf(to) + amount < _maxWalletSize, \"TOKEN: Balance exceeds wallet size!\");\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            bool canSwap = contractTokenBalance >= _swapTokensAtAmount;\n\n            if(contractTokenBalance >= _maxTxAmount)\n            {\n                contractTokenBalance = _maxTxAmount;\n            }\n\n            if (canSwap && !inSwap && from != uniswapV2Pair && swapEnabled && !_isExcludedFromFee[from] && !_isExcludedFromFee[to]) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if (contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }\n\n        bool takeFee = true;\n\n        //Transfer Tokens\n        if ((_isExcludedFromFee[from] || _isExcludedFromFee[to]) || (from != uniswapV2Pair && to != uniswapV2Pair)) {\n            takeFee = false;\n        } else {\n\n            //Set Fee for Buys\n            if(from == uniswapV2Pair && to != address(uniswapV2Router)) {\n                _redisFee = _redisFeeOnBuy;\n                _taxFee = _taxFeeOnBuy;\n            }\n\n            //Set Fee for Sells\n            if (to == uniswapV2Pair && from != address(uniswapV2Router)) {\n                _redisFee = _redisFeeOnSell;\n                _taxFee = _taxFeeOnSell;\n            }\n\n        }\n\n        _tokenTransfer(from, to, amount, takeFee);\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function sendETHToFee(uint256 amount) private {\n        _marketingAddress.transfer(amount);\n    }\n\n    function setTrading(bool _tradingOpen) public onlyOwner {\n        tradingOpen = _tradingOpen;\n    }\n\n    function manualswap() external {\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\n        uint256 contractBalance = balanceOf(address(this));\n        swapTokensForEth(contractBalance);\n    }\n\n    function manualsend() external {\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\n        uint256 contractETHBalance = address(this).balance;\n        sendETHToFee(contractETHBalance);\n    }\n\n    function blockBots(address[] memory bots_) public onlyOwner {\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\n        for (uint256 i = 0; i < bots_.length; i++) {\n            bots[bots_[i]] = true;\n        }\n    }\n\n    function unblockBot(address notbot) public onlyOwner {\n        bots[notbot] = false;\n    }\n\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bool takeFee\n    ) private {\n        if (!takeFee) removeAllFee();\n        _transferStandard(sender, recipient, amount);\n        if (!takeFee) restoreAllFee();\n    }\n\n    function _transferStandard(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        (\n            uint256 rAmount,\n            uint256 rTransferAmount,\n            uint256 rFee,\n            uint256 tTransferAmount,\n            uint256 tFee,\n            uint256 tTeam\n        ) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeTeam(tTeam);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _takeTeam(uint256 tTeam) private {\n        uint256 currentRate = _getRate();\n        uint256 rTeam = tTeam.mul(currentRate);\n        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    receive() external payable {}\n\n    function _getValues(uint256 tAmount)\n        private\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) =\n            _getTValues(tAmount, _redisFee, _taxFee);\n        uint256 currentRate = _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) =\n            _getRValues(tAmount, tFee, tTeam, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n    }\n\n    function _getTValues(\n        uint256 tAmount,\n        uint256 redisFee,\n        uint256 taxFee\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 tFee = tAmount.mul(redisFee).div(100);\n        uint256 tTeam = tAmount.mul(taxFee).div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n        return (tTransferAmount, tFee, tTeam);\n    }\n\n    function _getRValues(\n        uint256 tAmount,\n        uint256 tFee,\n        uint256 tTeam,\n        uint256 currentRate\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTeam = tTeam.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns (uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns (uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n\n    function setFee(uint256 redisFeeOnBuy, uint256 redisFeeOnSell, uint256 taxFeeOnBuy, uint256 taxFeeOnSell) public onlyOwner {\n        _redisFeeOnBuy = redisFeeOnBuy;\n        _redisFeeOnSell = redisFeeOnSell;\n        _taxFeeOnBuy = taxFeeOnBuy;\n        _taxFeeOnSell = taxFeeOnSell;\n    }\n\n    //Set minimum tokens required to swap.\n    function setMinSwapTokensThreshold(uint256 swapTokensAtAmount) public {\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\n        _swapTokensAtAmount = swapTokensAtAmount;\n    }\n\n    //Set minimum tokens required to swap.\n    function toggleSwap(bool _swapEnabled) public onlyOwner {\n        swapEnabled = _swapEnabled;\n    }\n\n    //Set maximum transaction\n    function setMaxTxnAmount(uint256 maxTxAmount) public onlyOwner {\n        _maxTxAmount = maxTxAmount;\n    }\n\n    function setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {\n        _maxWalletSize = maxWalletSize;\n    }\n\n}",
    "vulnerability_type": "reentrancy"
  },
  {
    "address": "0x42489f5e7611c92cf94d4ee7fd5348a273dde9cc",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2022-03-30\n*/\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.9;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ncontract Ownable is Context {\n    address private _owner;\n    address private _previousOwner;\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n}\n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n}\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n}\n\ncontract KIBIRU is Context, IERC20, Ownable {\n\n    using SafeMath for uint256;\n\n    string private constant _name = \"KIBIRU\";\n    string private constant _symbol = \"KIBU\";\n    uint8 private constant _decimals = 9;\n\n    mapping(address => uint256) private _rOwned;\n    mapping(address => uint256) private _tOwned;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => bool) private _isExcludedFromFee;\n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 1000000 * 10**9;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n    uint256 private _redisFeeOnBuy = 1;\n    uint256 private _taxFeeOnBuy = 97;\n    uint256 private _redisFeeOnSell = 1;\n    uint256 private _taxFeeOnSell = 12;\n\n    //Original Fee\n    uint256 private _redisFee = _redisFeeOnSell;\n    uint256 private _taxFee = _taxFeeOnSell;\n\n    uint256 private _previousredisFee = _redisFee;\n    uint256 private _previoustaxFee = _taxFee;\n\n    mapping(address => bool) public bots; mapping (address => uint256) public _buyMap;\n    address payable private _developmentAddress = payable(0xC017996B7133056a5e387b437B4d02e4F89eAdb9);\n    address payable private _marketingAddress = payable(0xC017996B7133056a5e387b437B4d02e4F89eAdb9);\n\n    IUniswapV2Router02 public uniswapV2Router;\n    address public uniswapV2Pair;\n\n    bool private tradingOpen;\n    bool private inSwap = true;\n    bool private swapEnabled = true;\n\n    uint256 public _maxTxAmount = 1000000 * 10**9;\n    uint256 public _maxWalletSize = 20000 * 10**9;\n    uint256 public _swapTokensAtAmount = 10000 * 10**9;\n\n    event MaxTxAmountUpdated(uint256 _maxTxAmount);\n    modifier lockTheSwap {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n    constructor() {\n\n        _rOwned[_msgSender()] = _rTotal;\n\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);//\n        uniswapV2Router = _uniswapV2Router;\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[_developmentAddress] = true;\n        _isExcludedFromFee[_marketingAddress] = true;\n\n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n\n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public pure override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    function tokenFromReflection(uint256 rAmount)\n        private\n        view\n        returns (uint256)\n    {\n        require(\n            rAmount <= _rTotal,\n            \"Amount must be less than total reflections\"\n        );\n        uint256 currentRate = _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function removeAllFee() private {\n        if (_redisFee == 0 && _taxFee == 0) return;\n\n        _previousredisFee = _redisFee;\n        _previoustaxFee = _taxFee;\n\n        _redisFee = 0;\n        _taxFee = 0;\n    }\n\n    function restoreAllFee() private {\n        _redisFee = _previousredisFee;\n        _taxFee = _previoustaxFee;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        if (from != owner() && to != owner()) {\n\n            //Trade start check\n            if (!tradingOpen) {\n                require(from == owner(), \"TOKEN: This account cannot send tokens until trading is enabled\");\n            }\n\n            require(amount <= _maxTxAmount, \"TOKEN: Max Transaction Limit\");\n            require(!bots[from] && !bots[to], \"TOKEN: Your account is blacklisted!\");\n\n            if(to != uniswapV2Pair) {\n                require(balanceOf(to) + amount < _maxWalletSize, \"TOKEN: Balance exceeds wallet size!\");\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            bool canSwap = contractTokenBalance >= _swapTokensAtAmount;\n\n            if(contractTokenBalance >= _maxTxAmount)\n            {\n                contractTokenBalance = _maxTxAmount;\n            }\n\n            if (canSwap && !inSwap && from != uniswapV2Pair && swapEnabled && !_isExcludedFromFee[from] && !_isExcludedFromFee[to]) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if (contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }\n\n        bool takeFee = true;\n\n        //Transfer Tokens\n        if ((_isExcludedFromFee[from] || _isExcludedFromFee[to]) || (from != uniswapV2Pair && to != uniswapV2Pair)) {\n            takeFee = false;\n        } else {\n\n            //Set Fee for Buys\n            if(from == uniswapV2Pair && to != address(uniswapV2Router)) {\n                _redisFee = _redisFeeOnBuy;\n                _taxFee = _taxFeeOnBuy;\n            }\n\n            //Set Fee for Sells\n            if (to == uniswapV2Pair && from != address(uniswapV2Router)) {\n                _redisFee = _redisFeeOnSell;\n                _taxFee = _taxFeeOnSell;\n            }\n\n        }\n\n        _tokenTransfer(from, to, amount, takeFee);\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function sendETHToFee(uint256 amount) private {\n        _marketingAddress.transfer(amount);\n    }\n\n    function setTrading(bool _tradingOpen) public onlyOwner {\n        tradingOpen = _tradingOpen;\n    }\n\n    function manualswap() external {\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\n        uint256 contractBalance = balanceOf(address(this));\n        swapTokensForEth(contractBalance);\n    }\n\n    function manualsend() external {\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\n        uint256 contractETHBalance = address(this).balance;\n        sendETHToFee(contractETHBalance);\n    }\n\n    function blockBots(address[] memory bots_) public onlyOwner {\n        for (uint256 i = 0; i < bots_.length; i++) {\n            bots[bots_[i]] = true;\n        }\n    }\n\n    function unblockBot(address notbot) public onlyOwner {\n        bots[notbot] = false;\n    }\n\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bool takeFee\n    ) private {\n        if (!takeFee) removeAllFee();\n        _transferStandard(sender, recipient, amount);\n        if (!takeFee) restoreAllFee();\n    }\n\n    function _transferStandard(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        (\n            uint256 rAmount,\n            uint256 rTransferAmount,\n            uint256 rFee,\n            uint256 tTransferAmount,\n            uint256 tFee,\n            uint256 tTeam\n        ) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeTeam(tTeam);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _takeTeam(uint256 tTeam) private {\n        uint256 currentRate = _getRate();\n        uint256 rTeam = tTeam.mul(currentRate);\n        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    receive() external payable {}\n\n    function _getValues(uint256 tAmount)\n        private\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) =\n            _getTValues(tAmount, _redisFee, _taxFee);\n        uint256 currentRate = _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) =\n            _getRValues(tAmount, tFee, tTeam, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n    }\n\n    function _getTValues(\n        uint256 tAmount,\n        uint256 redisFee,\n        uint256 taxFee\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 tFee = tAmount.mul(redisFee).div(100);\n        uint256 tTeam = tAmount.mul(taxFee).div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n        return (tTransferAmount, tFee, tTeam);\n    }\n\n    function _getRValues(\n        uint256 tAmount,\n        uint256 tFee,\n        uint256 tTeam,\n        uint256 currentRate\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTeam = tTeam.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns (uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns (uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n\n    function setFee(uint256 redisFeeOnBuy, uint256 redisFeeOnSell, uint256 taxFeeOnBuy, uint256 taxFeeOnSell) public onlyOwner {\n        _redisFeeOnBuy = redisFeeOnBuy;\n        _redisFeeOnSell = redisFeeOnSell;\n        _taxFeeOnBuy = taxFeeOnBuy;\n        _taxFeeOnSell = taxFeeOnSell;\n    }\n\n    //Set minimum tokens required to swap.\n    function setMinSwapTokensThreshold(uint256 swapTokensAtAmount) public onlyOwner {\n        _swapTokensAtAmount = swapTokensAtAmount;\n    }\n\n    //Set minimum tokens required to swap.\n    function toggleSwap(bool _swapEnabled) public onlyOwner {\n        swapEnabled = _swapEnabled;\n    }\n\n    //Set maximum transaction\n    function setMaxTxnAmount(uint256 maxTxAmount) public onlyOwner {\n        _maxTxAmount = maxTxAmount;\n    }\n\n    function setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {\n        _maxWalletSize = maxWalletSize;\n    }\n\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\n        for(uint256 i = 0; i < accounts.length; i++) {\n            _isExcludedFromFee[accounts[i]] = excluded;\n        }\n    }\n\n}",
    "vulnerability_type": "reentrancy"
  },
  {
    "address": "0x61422b386b60fca9757deab6ecdb6c804722d886",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2022-02-02\n*/\n\n// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Multi Send - Allows to batch multiple transactions into one.\ncontract WalliroMultiSend {\n    address private immutable multisendSingleton;\n\n    constructor() {\n        multisendSingleton = address(this);\n    }\n\n    /// @dev Sends multiple transactions and reverts all if one fails.\n    /// @param transactions Encoded transactions. Each transaction is encoded as a packed bytes of\n    ///                     operation as a uint8 with 0 for a call or 1 for a delegatecall (=> 1 byte),\n    ///                     to as a address (=> 20 bytes),\n    ///                     value as a uint256 (=> 32 bytes),\n    ///                     data length as a uint256 (=> 32 bytes),\n    ///                     data as bytes.\n    ///                     see abi.encodePacked for more information on packed encoding\n    /// @notice This method is payable as delegatecalls keep the msg.value from the previous call\n    ///         If the calling method (e.g. execTransaction) received ETH this would revert otherwise\n    function multiSend(bytes memory transactions) public payable {\n        require(address(this) != multisendSingleton, \"MultiSend should only be called via delegatecall\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for {\n                // Pre block is not used in \"while mode\"\n            } lt(i, length) {\n                // Post block is not used in \"while mode\"\n            } {\n                // First byte of the data is the operation.\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\n                // This will also zero out unused data.\n                let operation := shr(0xf8, mload(add(transactions, i)))\n                // We offset the load address by 1 byte (operation byte)\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\n                let value := mload(add(transactions, add(i, 0x15)))\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\n                let dataLength := mload(add(transactions, add(i, 0x35)))\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n                let data := add(transactions, add(i, 0x55))\n                let success := 0\n                switch operation\n                    case 0 {\n                        success := call(gas(), to, value, data, dataLength, 0, 0)\n                    }\n                    case 1 {\n                        success := delegatecall(gas(), to, data, dataLength, 0, 0)\n                    }\n                if eq(success, 0) {\n                    revert(0, 0)\n                }\n                // Next entry starts at 85 byte + data length\n                i := add(i, add(0x55, dataLength))\n            }\n        }\n    }\n}",
    "vulnerability_type": "denial_of_service"
  },
  {
    "address": "0x61582a6087d0e430ee7c5b2d53cc3c8514f63592",
    "source_code": "pragma solidity ^0.4.24;\n\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n    assert(token.transfer(to, value));\n  }\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n/**\n * @title DragonAdvisors\n * @dev DragonAdvisors works like a tap and release tokens periodically\n * to advisors on the owners permission \n */\ncontract DragonAdvisors is Ownable{\n  using SafeERC20 for ERC20Basic;\n  using SafeMath for uint256;\n\n  // ERC20 basic token contract being held\n  ERC20Basic public token;\n\n  // advisor address\n  address public advisor;\n\n  // amount of tokens available for release\n  uint256 public releasedTokens;\n  \n  event TokenTapAdjusted(uint256 released);\n\n  constructor() public {\n    token = ERC20Basic(0x814F67fA286f7572B041D041b1D99b432c9155Ee);\n    owner = address(0xA5101498679Fa973c5cF4c391BfF991249934E73);      // overriding owner\n\n    advisor = address(0x3e97789f29802968b4a1B803A06669B955719F5b);\n    \n    releasedTokens = 0;\n  }\n\n  /**\n   * @notice release tokens held by the contract to advisor.\n   */\n  function release(uint256 _amount) public {\n    require(_amount > 0);\n    require(releasedTokens >= _amount);\n    releasedTokens = releasedTokens.sub(_amount);\n    \n    uint256 balance = token.balanceOf(this);\n    require(balance >= _amount);\n    \n\n    token.safeTransfer(advisor, _amount);\n  }\n  \n  /**\n   * @notice Owner can move tokens to any address\n   */\n  function transferTokens(address _to, uint256 _amount) external {\n    require(_to != address(0x00));\n    require(_amount > 0);\n\n    uint256 balance = token.balanceOf(this);\n    require(balance >= _amount);\n\n    token.safeTransfer(_to, _amount);\n  }\n  \n  function adjustTap(uint256 _amount) external onlyOwner{\n      require(_amount > 0);\n      uint256 balance = token.balanceOf(this);\n      require(_amount <= balance);\n      releasedTokens = _amount;\n      emit TokenTapAdjusted(_amount);\n  }\n  \n  function () public payable {\n      revert();\n  }\n}",
    "vulnerability_type": "denial_of_service"
  },
  {
    "address": "0x61624e63ebf5fd046bf96bd16a98dbe522a7a19f",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-09-07\n*/\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @title Custom NFT contract based off ERC721 but restricted by access control.\n * @dev Based on https://github.com/Synthetixio/spartan-council/blob/main/contracts/SpartanCouncil.sol\n */\ncontract LyraCouncil is Ownable {\n    // Event that is emitted when a new LyraCouncil token is minted\n    event Mint(uint256 indexed tokenId, address to);\n    // Event that is emitted when an existing LyraCouncil token is burned\n    event Burn(uint256 indexed tokenId);\n    // Event that is emitted when an existing LyraCouncil token is Transferred\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    // Event that is emitted when an existing LyraCouncil token's uri is altered\n    event TokenURISet(uint256 tokenId, string tokenURI);\n\n    // Array of token ids\n    uint256[] public tokens;\n    // Map between an owner and their tokens\n    mapping(address => uint256) public tokenOwned;\n    // Maps a token to the owner address\n    mapping(uint256 => address) public ownerOf;\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private tokenURIs;\n    // Token name\n    string public name;\n    // Token symbol\n    string public symbol;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     * @param _name the name of the token\n     * @param _symbol the symbol of the token\n     */\n    constructor(string memory _name, string memory _symbol) public {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /**\n     * @dev Modifier to check that an address is not the \"0\" address\n     * @param to address the address to check\n     */\n    modifier isValidAddress(address to) {\n        require(to != address(0), \"Method called with the zero address\");\n        _;\n    }\n\n    /**\n     * @dev Function to retrieve whether an address owns a token\n     * @param owner address the address to check the balance of\n     */\n    function balanceOf(address owner) public view isValidAddress(owner) returns (uint256) {\n        return tokenOwned[owner] > 0 ? 1 : 0;\n    }\n\n    /**\n     * @dev Transfer function to assign a token to another address\n     * Reverts if the address already owns a token\n     * @param from address the address that currently owns the token\n     * @param to address the address to assign the token to\n     * @param tokenId uint256 ID of the token to transfer\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public isValidAddress(to) isValidAddress(from) onlyOwner {\n        require(tokenOwned[to] == 0, \"Destination address already owns a token\");\n        require(ownerOf[tokenId] == from, \"From address does not own token\");\n\n        tokenOwned[from] = 0;\n        tokenOwned[to] = tokenId;\n\n        ownerOf[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Mint function to mint a new token given a tokenId and assign it to an address\n     * Reverts if the tokenId is 0 or the token already exist\n     * @param to address the address to assign the token to\n     * @param tokenId uint256 ID of the token to mint\n     */\n    function mint(address to, uint256 tokenId) public onlyOwner isValidAddress(to) {\n        _mint(to, tokenId);\n    }\n\n    /**\n     * @dev Mint function to mint a new token given a tokenId and assign it to an address\n     * Reverts if the tokenId is 0 or the token already exist\n     * @param to address the address to assign the token to\n     * @param tokenId uint256 ID of the token to mint\n     */\n    function mintWithTokenURI(\n        address to,\n        uint256 tokenId,\n        string memory uri\n    ) public onlyOwner isValidAddress(to) {\n        require(bytes(uri).length > 0, \"URI must be supplied\");\n\n        _mint(to, tokenId);\n\n        tokenURIs[tokenId] = uri;\n        emit TokenURISet(tokenId, uri);\n    }\n\n    function _mint(address to, uint256 tokenId) private {\n        require(tokenOwned[to] == 0, \"Destination address already owns a token\");\n        require(ownerOf[tokenId] == address(0), \"ERC721: token already minted\");\n        require(tokenId != 0, \"Token ID must be greater than 0\");\n\n        tokens.push(tokenId);\n        tokenOwned[to] = tokenId;\n        ownerOf[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n        emit Mint(tokenId, to);\n    }\n\n    /**\n     * @dev Burn function to remove a given tokenId\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to burn\n     */\n    function burn(uint256 tokenId) public onlyOwner {\n        address previousOwner = ownerOf[tokenId];\n        require(previousOwner != address(0), \"ERC721: token does not exist\");\n\n        delete tokenOwned[previousOwner];\n        delete ownerOf[tokenId];\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (tokens[i] == tokenId) {\n                tokens[i] = tokens[tokens.length - 1];\n                break;\n            }\n        }\n\n        tokens.pop();\n\n        if (bytes(tokenURIs[tokenId]).length != 0) {\n            delete tokenURIs[tokenId];\n        }\n\n        emit Burn(tokenId);\n    }\n\n    /**\n     * @dev Function to get the total supply of tokens currently available\n     */\n    function totalSupply() public view returns (uint256) {\n        return tokens.length;\n    }\n\n    /**\n     * @dev Function to get the token URI for a given token.\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to retrieve the uri for\n     */\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        require(ownerOf[tokenId] != address(0), \"ERC721: token does not exist\");\n        string memory _tokenURI = tokenURIs[tokenId];\n        return _tokenURI;\n    }\n\n    /**\n     * @dev Function to set the token URI for a given token.\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     */\n    function setTokenURI(uint256 tokenId, string memory uri) public onlyOwner {\n        require(ownerOf[tokenId] != address(0), \"ERC721: token does not exist\");\n        tokenURIs[tokenId] = uri;\n        emit TokenURISet(tokenId, uri);\n    }\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x617aAA62157d97eE1d8911009de64aA2683fA351",
    "source_code": "pragma solidity ^0.4.24;\n\n// ----------------------------------------------------------------------------\n// 'I NEED A MIRACLE COIN' token contract\n//\n// Deployed to : 0xFa88C8698F8309FD9B2c8b42754858E06096cce9\n// Symbol      : MIRACLE\n// Name        : MIRACLE\n// Total supply: 100\n// Decimals    : 6\n//\n// Enjoy.\n//\n// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.\n// ----------------------------------------------------------------------------\n\n\n// ----------------------------------------------------------------------------\n// Safe maths\n// ----------------------------------------------------------------------------\ncontract SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n// ----------------------------------------------------------------------------\ncontract ERC20Interface {\n    function totalSupply() public constant returns (uint);\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\n// ----------------------------------------------------------------------------\n// Contract function to receive approval and execute function in one call\n//\n// Borrowed from MiniMeToken\n// ----------------------------------------------------------------------------\ncontract ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n}\n\n\n// ----------------------------------------------------------------------------\n// Owned contract\n// ----------------------------------------------------------------------------\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\n// token transfers\n// ----------------------------------------------------------------------------\ncontract MIRACLE is ERC20Interface, Owned, SafeMath {\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    constructor() public {\n        symbol = \"MIRACLE\";\n        name = \"INEEDAMIRACLECOIN\";\n        decimals = 6;\n        _totalSupply = 100000000;\n        balances[0xFa88C8698F8309FD9B2c8b42754858E06096cce9] = _totalSupply;\n        emit Transfer(address(0), 0xFa88C8698F8309FD9B2c8b42754858E06096cce9, _totalSupply);\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Total supply\n    // ------------------------------------------------------------------------\n    function totalSupply() public constant returns (uint) {\n        return _totalSupply  - balances[address(0)];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Get the token balance for account tokenOwner\n    // ------------------------------------------------------------------------\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer the balance from token owner's account to to account\n    // - Owner's account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transfer(address to, uint tokens) public returns (bool success) {\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner's account\n    //\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n    // recommends that there are no checks for the approval double-spend attack\n    // as this should be implemented in user interfaces \n    // ------------------------------------------------------------------------\n    function approve(address spender, uint tokens) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer tokens from the from account to the to account\n    // \n    // The calling account must already have sufficient tokens approve(...)-d\n    // for spending from the from account and\n    // - From account must have sufficient balance to transfer\n    // - Spender must have sufficient allowance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        balances[from] = safeSub(balances[from], tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Returns the amount of tokens approved by the owner that can be\n    // transferred to the spender's account\n    // ------------------------------------------------------------------------\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner's account. The spender contract function\n    // receiveApproval(...) is then executed\n    // ------------------------------------------------------------------------\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Don't accept ETH\n    // ------------------------------------------------------------------------\n    function () public payable {\n        revert();\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    // ------------------------------------------------------------------------\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }\n}",
    "vulnerability_type": "denial_of_service"
  },
  {
    "address": "0x617b2E3c10325C546533Ecae277bcf9964aB3373",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-11-20\n*/\n\n// SPDX-License-Identifier: MIT\n pragma solidity ^0.8.6;\n\n library SafeMath {\n \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n interface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function getOwner() external view returns (address);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n  \ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n \nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {return msg.sender;}\n    function _msgData() internal view virtual returns (bytes calldata) {this; return msg.data;}\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size; assembly { size := extcodesize(account) } return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");(bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) { return returndata; } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {revert(errorMessage);}\n        }\n    }\n}\n \nabstract contract Ownable is Context {\n    address private _owner;\n    address private _previousOwner;\n    uint256 private _lockTime;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    function getUnlockTime() public view returns (uint256) {\n        return _lockTime;\n    }\n\n    function getTime() public view returns (uint256) {\n        return block.timestamp;\n    }\n\n    function lock(uint256 time) public virtual onlyOwner {\n        _previousOwner = _owner;\n        _owner = address(0);\n        _lockTime = block.timestamp + time;\n        emit OwnershipTransferred(_owner, address(0));\n    }\n\n    function unlock() public virtual {\n        require(_previousOwner == msg.sender, \"You don't have permission to unlock\");\n        require(block.timestamp > _lockTime , \"Contract is locked until 7 days\");\n        emit OwnershipTransferred(_owner, _previousOwner);\n        _owner = _previousOwner;\n    }\n}\n \n interface IUniswapV2Factory {\n     event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n \n     function feeTo() external view returns (address);\n     function feeToSetter() external view returns (address);\n \n     function getPair(address tokenA, address tokenB) external view returns (address pair);\n     function allPairs(uint) external view returns (address pair);\n     function allPairsLength() external view returns (uint);\n \n     function createPair(address tokenA, address tokenB) external returns (address pair);\n \n     function setFeeTo(address) external;\n     function setFeeToSetter(address) external;\n }\n interface IUniswapV2Pair {\n     event Approval(address indexed owner, address indexed spender, uint value);\n     event Transfer(address indexed from, address indexed to, uint value);\n \n     function name() external pure returns (string memory);\n     function symbol() external pure returns (string memory);\n     function decimals() external pure returns (uint8);\n     function totalSupply() external view returns (uint);\n     function balanceOf(address owner) external view returns (uint);\n     function allowance(address owner, address spender) external view returns (uint);\n \n     function approve(address spender, uint value) external returns (bool);\n     function transfer(address to, uint value) external returns (bool);\n     function transferFrom(address from, address to, uint value) external returns (bool);\n \n     function DOMAIN_SEPARATOR() external view returns (bytes32);\n     function PERMIT_TYPEHASH() external pure returns (bytes32);\n     function nonces(address owner) external view returns (uint);\n \n     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n \n     event Mint(address indexed sender, uint amount0, uint amount1);\n     event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n     event Swap(\n         address indexed sender,\n         uint amount0In,\n         uint amount1In,\n         uint amount0Out,\n         uint amount1Out,\n         address indexed to\n     );\n     event Sync(uint112 reserve0, uint112 reserve1);\n \n     function MINIMUM_LIQUIDITY() external pure returns (uint);\n     function factory() external view returns (address);\n     function token0() external view returns (address);\n     function token1() external view returns (address);\n     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n     function price0CumulativeLast() external view returns (uint);\n     function price1CumulativeLast() external view returns (uint);\n     function kLast() external view returns (uint);\n \n     function mint(address to) external returns (uint liquidity);\n     function burn(address to) external returns (uint amount0, uint amount1);\n     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n     function skim(address to) external;\n     function sync() external;\n \n     function initialize(address, address) external;\n }\n \n interface IUniswapV2Router01 {\n     function factory() external pure returns (address);\n     function WETH() external pure returns (address);\n \n     function addLiquidity(\n         address tokenA,\n         address tokenB,\n         uint amountADesired,\n         uint amountBDesired,\n         uint amountAMin,\n         uint amountBMin,\n         address to,\n         uint deadline\n     ) external returns (uint amountA, uint amountB, uint liquidity);\n     function addLiquidityETH(\n         address token,\n         uint amountTokenDesired,\n         uint amountTokenMin,\n         uint amountETHMin,\n         address to,\n         uint deadline\n     ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n     function removeLiquidity(\n         address tokenA,\n         address tokenB,\n         uint liquidity,\n         uint amountAMin,\n         uint amountBMin,\n         address to,\n         uint deadline\n     ) external returns (uint amountA, uint amountB);\n     function removeLiquidityETH(\n         address token,\n         uint liquidity,\n         uint amountTokenMin,\n         uint amountETHMin,\n         address to,\n         uint deadline\n     ) external returns (uint amountToken, uint amountETH);\n     function removeLiquidityWithPermit(\n         address tokenA,\n         address tokenB,\n         uint liquidity,\n         uint amountAMin,\n         uint amountBMin,\n         address to,\n         uint deadline,\n         bool approveMax, uint8 v, bytes32 r, bytes32 s\n     ) external returns (uint amountA, uint amountB);\n     function removeLiquidityETHWithPermit(\n         address token,\n         uint liquidity,\n         uint amountTokenMin,\n         uint amountETHMin,\n         address to,\n         uint deadline,\n         bool approveMax, uint8 v, bytes32 r, bytes32 s\n     ) external returns (uint amountToken, uint amountETH);\n     function swapExactTokensForTokens(\n         uint amountIn,\n         uint amountOutMin,\n         address[] calldata path,\n         address to,\n         uint deadline\n     ) external returns (uint[] memory amounts);\n     function swapTokensForExactTokens(\n         uint amountOut,\n         uint amountInMax,\n         address[] calldata path,\n         address to,\n         uint deadline\n     ) external returns (uint[] memory amounts);\n     function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n         external\n         payable\n         returns (uint[] memory amounts);\n     function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n         external\n         returns (uint[] memory amounts);\n     function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n         external\n         returns (uint[] memory amounts);\n     function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n         external\n         payable\n         returns (uint[] memory amounts);\n \n     function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n     function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n     function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n }\n interface IUniswapV2Router02 is IUniswapV2Router01 {\n     function removeLiquidityETHSupportingFeeOnTransferTokens(\n         address token,\n         uint liquidity,\n         uint amountTokenMin,\n         uint amountETHMin,\n         address to,\n         uint deadline\n     ) external returns (uint amountETH);\n     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n         address token,\n         uint liquidity,\n         uint amountTokenMin,\n         uint amountETHMin,\n         address to,\n         uint deadline,\n         bool approveMax, uint8 v, bytes32 r, bytes32 s\n     ) external returns (uint amountETH);\n \n     function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n         uint amountIn,\n         uint amountOutMin,\n         address[] calldata path,\n         address to,\n         uint deadline\n     ) external;\n     function swapExactETHForTokensSupportingFeeOnTransferTokens(\n         uint amountOutMin,\n         address[] calldata path,\n         address to,\n         uint deadline\n     ) external payable;\n     function swapExactTokensForETHSupportingFeeOnTransferTokens(\n         uint amountIn,\n         uint amountOutMin,\n         address[] calldata path,\n         address to,\n         uint deadline\n     ) external;\n }\n \n \n contract swapverse is IERC20Metadata, Context, Ownable {\n     using SafeMath for uint256;\n     using Address for address;\n     address public presaleAddress = 0x7cE4D7946EDE50125396864BB7f162908AC361Ec;\n     address public marketingFeeReceiver = 0x0276d02885363Fda45A7d9c37D7757F6dB521501;\n     address public developmentwallet = 0x50A304cEF095aC943434B67AF254a8d3Eba1a998;\n     address public burnFeeReceiver = 0x3BE05d94c24Fe4404eD261376127cD1814dBAcc8;\n     address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n     string constant _name = \"Swapverse\";\n     string constant _symbol = \"VSWAP\";\n     uint8 constant _decimals = 9;\n\n     uint256 private constant MAX = ~uint256(0);\n     uint256 internal constant _tTotal = 1000000000 * 10**6 * 10**9;\n     uint256 internal _rTotal = (MAX - (MAX % _tTotal));\n\n     uint256 public _tFeeTotal;\n\n     uint256 public maxTxAmount = _tTotal / 1000; // 0.5% of the total supply\n     uint256 public maxWalletBalance = _tTotal / 50; // 2% of the total supply\n     uint256 public _tFee = 1;\n     uint256 internal _previoustFee = _tFee;\n     \n     uint256 public _marketingFee =1;\n     uint256 internal _previousmaketingFee = _marketingFee;\n\n     uint256 public _burnFee = 1;\n     uint256 internal _previousburnFee = _burnFee;\n\n     IUniswapV2Router02 public uniswapV2Router;\n     address public  uniswapV2Pair;\n\n     mapping (address => uint256) internal _rOwned;\n     mapping (address => uint256) internal _tOwned;\n     mapping (address => mapping (address => uint256)) internal _allowances;\n \n     mapping (address => bool) internal _isExcludedFromFee;\n     mapping (address => bool) internal _isExcluded;\n     address[] private _excluded;\n     \n     constructor () {\n         _rOwned[presaleAddress] = _rTotal;\n         \n         IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n         uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n \n         uniswapV2Router = _uniswapV2Router;\n         \n         _isExcludedFromFee[owner()] = true;\n         _isExcludedFromFee[presaleAddress] = true;\n         _isExcludedFromFee[address(this)] = true;\n         _isExcludedFromFee[marketingFeeReceiver] = true;\n         _isExcludedFromFee[developmentwallet] = true;\n         _isExcludedFromFee[burnFeeReceiver] = true;\n         _approve(owner(), address(uniswapV2Router), ~uint256(0));\n         emit Transfer(address(0), _msgSender(), _tTotal);\n     }\n     function name() external pure override returns (string memory) {\n        return _name;\n    }\n \n    function symbol() external pure override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return _decimals;\n    }\n \n     function totalSupply() external pure override returns (uint256) {\n         return _tTotal;\n     }\n     \n     function getOwner() external view override returns (address) { \n         return owner(); \n         \n     }\n \n     function balanceOf(address account) public view override returns (uint256) {\n         if (_isExcluded[account]) return _tOwned[account];\n         return tokenFromReflection(_rOwned[account]);\n     }\n \n     function transfer(address recipient, uint256 amount) public override returns (bool) {\n         _transfer(_msgSender(), recipient, amount);\n         return true;\n     }\n \n     function allowance(address owner, address spender) public view override returns (uint256) {\n         return _allowances[owner][spender];\n     }\n \n     function approve(address spender, uint256 amount) public override returns (bool) {\n         _approve(_msgSender(), spender, amount);\n         return true;\n     }\n \n     function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n         _transfer(sender, recipient, amount);\n         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n         return true;\n     }\n \n     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n         return true;\n     }\n     \n     \n     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n         return true;\n     }\n \n     function isExcludedFromReward(address account) public view returns (bool) {\n         return _isExcluded[account];\n     }\n \n     function totalFees() public view returns (uint256) {\n         return _tFeeTotal;\n     }\n \n     function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\n         require(tAmount <= _tTotal, \"Amount must be less than supply\");\n         if (!deductTransferFee) {\n             (uint256 rAmount,,,,,,) = _getValues(tAmount);\n             return rAmount;\n         } else {\n             (,uint256 rTransferAmount,,,,,) = _getValues(tAmount);\n             return rTransferAmount;\n         }\n     }\n \n     function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n         require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n         uint256 currentRate =  _getRate();\n         return rAmount.div(currentRate);\n     }\n     \n     function setMarketingFeeReceiver(address _marketingFeeReceiver) external onlyOwner() {\n         marketingFeeReceiver = _marketingFeeReceiver;\n     }\n     \n     function setBurnFeeReceiver(address _burnFeeReceiver) external onlyOwner() {\n         burnFeeReceiver = _burnFeeReceiver;\n     }\n \n     function excludeFromReward(address account) public onlyOwner() {\n         require(!_isExcluded[account], \"Account is already excluded\");\n         if(_rOwned[account] > 0) {\n             _tOwned[account] = tokenFromReflection(_rOwned[account]);\n         }\n         _isExcluded[account] = true;\n         _excluded.push(account);\n     }\n \n     function includeInReward(address account) external onlyOwner() {\n         require(_isExcluded[account], \"Account is already excluded\");\n         for (uint256 i = 0; i < _excluded.length; i++) {\n             if (_excluded[i] == account) {\n                 _excluded[i] = _excluded[_excluded.length - 1];\n                 _tOwned[account] = 0;\n                 _isExcluded[account] = false;\n                 _excluded.pop();\n                 break;\n             }\n         }\n     }\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 marketingFee, uint256 burnFee) = _getValues(tAmount);\n         _tOwned[sender] = _tOwned[sender].sub(tAmount);\n         _rOwned[sender] = _rOwned[sender].sub(rAmount);\n         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n         _takeFee(marketingFee, marketingFeeReceiver);\n         _takeFee(burnFee, burnFeeReceiver);\n         _reflectFee(rFee, tFee);\n         emit Transfer(sender, recipient, tTransferAmount);\n     }\n     \n    function excludeFromFee(address account) public onlyOwner() {\n         _isExcludedFromFee[account] = true;\n     }\n     \n     function includeInFee(address account) public onlyOwner() {\n         _isExcludedFromFee[account] = false;\n     }\n     \n     function setReflectionFeePercent(uint256 tFee) external onlyOwner() {\n         _tFee = tFee;\n     }\n     \n     function setMarketingFeePercent(uint256 marketingFee) external onlyOwner() {\n         _marketingFee = marketingFee;\n     }\n     function setBurnFeePercent(uint256 burnFee) external onlyOwner() {\n         _burnFee = burnFee;\n     }   \n \n     function _reflectFee(uint256 rFee, uint256 tFee) internal {\n         _rTotal = _rTotal.sub(rFee);\n         _tFeeTotal = _tFeeTotal.add(tFee);\n     }\n \n     function _getValues(uint256 tAmount) internal view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n         (uint256 tTransferAmount, uint256 tFee, uint256 marketingFee, uint256 burnFee) = _getTValues(tAmount);\n         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, marketingFee, burnFee, _getRate());\n         return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, marketingFee, burnFee);\n     }\n \n     function _getTValues(uint256 tAmount) internal view returns (uint256, uint256, uint256, uint256) {\n         uint256 tFee = calculateReflectionFee(tAmount);\n         uint256 marketingFee = calculateMarketingFee(tAmount);\n         uint256 burnFee = calculateBurnFee(tAmount);\n         uint256 tTransferAmount = tAmount.sub(tFee).sub(marketingFee).sub(burnFee);\n         return (tTransferAmount, tFee, marketingFee, burnFee);\n     }\n \n     function _getRValues(uint256 tAmount, uint256 tFee, uint256 marketingFee, uint256 burnFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n         uint256 rAmount = tAmount.mul(currentRate);\n         uint256 rFee = tFee.mul(currentRate);\n         uint256 rmarketingFee = marketingFee.mul(currentRate);\n         uint256 rburnFee = burnFee.mul(currentRate);\n         uint256 rTransferAmount = rAmount.sub(rFee).sub(rmarketingFee).sub(rburnFee);\n         return (rAmount, rTransferAmount, rFee);\n     }\n \n     function _getRate() internal view returns(uint256) {\n         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n         return rSupply.div(tSupply);\n     }\n \n     function _getCurrentSupply() internal view returns(uint256, uint256) {\n         uint256 rSupply = _rTotal;\n         uint256 tSupply = _tTotal;      \n         for (uint256 i = 0; i < _excluded.length; i++) {\n             if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n             rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n             tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n         }\n         if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n         return (rSupply, tSupply);\n     }\n     \n     function calculateReflectionFee(uint256 _amount) internal view returns (uint256) {\n         return _amount.mul(_tFee).div(\n             10**2\n         );\n     }\n\n     function calculateMarketingFee(uint256 _amount) internal view returns (uint256) {\n         return _amount.mul(_marketingFee).div(\n             10**2\n         );\n     }\n\n     function calculateBurnFee(uint256 _amount) internal view returns (uint256) {\n         return _amount.mul(_burnFee).div(\n             10**2\n         );\n     }\n     \n     function removeAllFee() internal {\n         if(_tFee == 0 && _marketingFee == 0 &&  _burnFee == 0) return;\n         \n         _previoustFee = _tFee;\n         _previousmaketingFee = _marketingFee;\n         _previousburnFee = _burnFee;\n         \n         _tFee = 0;\n         _marketingFee = 0;\n         _burnFee = 0;\n     }\n     \n     function restoreAllFee() internal {\n        _tFee = _previoustFee;\n        _marketingFee = _previousmaketingFee;\n        _burnFee = _previousburnFee;\n     }\n     \n     function isExcludedFromFee(address account) public view returns(bool) {\n         return _isExcludedFromFee[account];\n     }\n \n     function _approve(address owner, address spender, uint256 amount) internal {\n         require(owner != address(0), \"ERC20: approve from the zero address\");\n         require(spender != address(0), \"ERC20: approve to the zero address\");\n \n         _allowances[owner][spender] = amount;\n         emit Approval(owner, spender, amount);\n     }\n \n     function _transfer(address from, address to, uint256 amount) internal {\n         require(from != address(0), \"ERC20: transfer from the zero address\");\n         require(to != address(0), \"ERC20: transfer to the zero address\");\n         require(from != address(deadAddress), \"Token: transfer from the burn address\");\n         require(amount > 0, \"Transfer amount must be greater than zero\");\n         if(from != owner() && to != owner())\n             require(amount <= maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");//??????\n         bool takeFee = true;\n         \n         if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n             takeFee = false;\n         }\n         \n         _tokenTransfer(from,to,amount,takeFee);\n     }\n\n    function _takeFee(uint256 fee, address feeRecevier) internal {\n        uint256 currentRate =  _getRate();\n        uint256 rFee = fee.mul(currentRate);\n        _rOwned[feeRecevier] = _rOwned[feeRecevier].add(rFee);\n        if(_isExcluded[feeRecevier])\n            _tOwned[feeRecevier] = _tOwned[feeRecevier].add(rFee);\n\n     }\n\n     function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\n         if(!takeFee)\n             removeAllFee();\n         \n         if (_isExcluded[sender] && !_isExcluded[recipient]) {\n             _transferFromExcluded(sender, recipient, amount);\n         } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n             _transferToExcluded(sender, recipient, amount);\n         } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n             _transferStandard(sender, recipient, amount);\n         } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n             _transferBothExcluded(sender, recipient, amount);\n         } else {\n             _transferStandard(sender, recipient, amount);\n         }\n         \n         if(!takeFee)\n             restoreAllFee();\n     }\n \n     function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 marketingFee, uint256 burnFee) = _getValues(tAmount);\n         _rOwned[sender] = _rOwned[sender].sub(rAmount);\n         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n         _takeFee(marketingFee, marketingFeeReceiver);\n         _takeFee(burnFee, burnFeeReceiver);\n         _reflectFee(rFee, tFee);\n         emit Transfer(sender, recipient, tTransferAmount);\n     }\n \n     function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 marketingFee, uint256 burnFee) = _getValues(tAmount);\n         _rOwned[sender] = _rOwned[sender].sub(rAmount);\n         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n         _takeFee(marketingFee, marketingFeeReceiver);\n         _takeFee(burnFee, burnFeeReceiver);\n         _reflectFee(rFee, tFee);\n         emit Transfer(sender, recipient, tTransferAmount);\n     }\n \n     function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 marketingFee, uint256 burnFee) = _getValues(tAmount);\n         _tOwned[sender] = _tOwned[sender].sub(tAmount);\n         _rOwned[sender] = _rOwned[sender].sub(rAmount);\n         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n         _takeFee(marketingFee, marketingFeeReceiver);\n         _takeFee(burnFee, burnFeeReceiver);\n         _reflectFee(rFee, tFee);\n         emit Transfer(sender, recipient, tTransferAmount);\n     }\n\n     receive() external payable {}\n }",
    "vulnerability_type": "denial_of_service"
  },
  {
    "address": "0x618d8da441a64f747aad41ecb22278d3fef5d7a9",
    "source_code": "//  ENS resolver for the Ecliptic contract\n//  https://azimuth.network\n\npragma solidity 0.4.24;\n\n////////////////////////////////////////////////////////////////////////////////\n//  Imports\n////////////////////////////////////////////////////////////////////////////////\n\n\n// ENS&#39;s ResolverInterface.sol\n\ncontract ResolverInterface {\n    function addr(bytes32 node) public view returns (address);\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool);\n}\n\n// OpenZeppelin&#39;s Owneable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// Azimuth&#39;s Azimuth.sol\n\n//  Azimuth: point state data contract\n//\n//    This contract is used for storing all data related to Azimuth points\n//    and their ownership. Consider this contract the Azimuth ledger.\n//\n//    It also contains permissions data, which ties in to ERC721\n//    functionality. Operators of an address are allowed to transfer\n//    ownership of all points owned by their associated address\n//    (ERC721&#39;s approveAll()). A transfer proxy is allowed to transfer\n//    ownership of a single point (ERC721&#39;s approve()).\n//    Separate from ERC721 are managers, assigned per point. They are\n//    allowed to perform \"low-impact\" operations on the owner&#39;s points,\n//    like configuring public keys and making escape requests.\n//\n//    Since data stores are difficult to upgrade, this contract contains\n//    as little actual business logic as possible. Instead, the data stored\n//    herein can only be modified by this contract&#39;s owner, which can be\n//    changed and is thus upgradable/replaceable.\n//\n//    This contract will be owned by the Ecliptic contract.\n//\ncontract Azimuth is Ownable\n{\n//\n//  Events\n//\n\n  //  OwnerChanged: :point is now owned by :owner\n  //\n  event OwnerChanged(uint32 indexed point, address indexed owner);\n\n  //  Activated: :point is now active\n  //\n  event Activated(uint32 indexed point);\n\n  //  Spawned: :prefix has spawned :child\n  //\n  event Spawned(uint32 indexed prefix, uint32 indexed child);\n\n  //  EscapeRequested: :point has requested a new :sponsor\n  //\n  event EscapeRequested(uint32 indexed point, uint32 indexed sponsor);\n\n  //  EscapeCanceled: :point&#39;s :sponsor request was canceled or rejected\n  //\n  event EscapeCanceled(uint32 indexed point, uint32 indexed sponsor);\n\n  //  EscapeAccepted: :point confirmed with a new :sponsor\n  //\n  event EscapeAccepted(uint32 indexed point, uint32 indexed sponsor);\n\n  //  LostSponsor: :point&#39;s :sponsor is now refusing it service\n  //\n  event LostSponsor(uint32 indexed point, uint32 indexed sponsor);\n\n  //  ChangedKeys: :point has new network public keys\n  //\n  event ChangedKeys( uint32 indexed point,\n                     bytes32 encryptionKey,\n                     bytes32 authenticationKey,\n                     uint32 cryptoSuiteVersion,\n                     uint32 keyRevisionNumber );\n\n  //  BrokeContinuity: :point has a new continuity number, :number\n  //\n  event BrokeContinuity(uint32 indexed point, uint32 number);\n\n  //  ChangedSpawnProxy: :spawnProxy can now spawn using :point\n  //\n  event ChangedSpawnProxy(uint32 indexed point, address indexed spawnProxy);\n\n  //  ChangedTransferProxy: :transferProxy can now transfer ownership of :point\n  //\n  event ChangedTransferProxy( uint32 indexed point,\n                              address indexed transferProxy );\n\n  //  ChangedManagementProxy: :managementProxy can now manage :point\n  //\n  event ChangedManagementProxy( uint32 indexed point,\n                                address indexed managementProxy );\n\n  //  ChangedVotingProxy: :votingProxy can now vote using :point\n  //\n  event ChangedVotingProxy(uint32 indexed point, address indexed votingProxy);\n\n  //  ChangedDns: dnsDomains have been updated\n  //\n  event ChangedDns(string primary, string secondary, string tertiary);\n\n//\n//  Structures\n//\n\n  //  Size: kinds of points registered on-chain\n  //\n  //    NOTE: the order matters, because of Solidity enum numbering\n  //\n  enum Size\n  {\n    Galaxy, // = 0\n    Star,   // = 1\n    Planet  // = 2\n  }\n\n  //  Point: state of a point\n  //\n  //    While the ordering of the struct members is semantically chaotic,\n  //    they are ordered to tightly pack them into Ethereum&#39;s 32-byte storage\n  //    slots, which reduces gas costs for some function calls.\n  //    The comment ticks indicate assumed slot boundaries.\n  //\n  struct Point\n  {\n    //  encryptionKey: (curve25519) encryption public key, or 0 for none\n    //\n    bytes32 encryptionKey;\n  //\n    //  authenticationKey: (ed25519) authentication public key, or 0 for none\n    //\n    bytes32 authenticationKey;\n  //\n    //  spawned: for stars and galaxies, all :active children\n    //\n    uint32[] spawned;\n  //\n    //  hasSponsor: true if the sponsor still supports the point\n    //\n    bool hasSponsor;\n\n    //  active: whether point can be linked\n    //\n    //    false: point belongs to prefix, cannot be configured or linked\n    //    true: point no longer belongs to prefix, can be configured and linked\n    //\n    bool active;\n\n    //  escapeRequested: true if the point has requested to change sponsors\n    //\n    bool escapeRequested;\n\n    //  sponsor: the point that supports this one on the network, or,\n    //           if :hasSponsor is false, the last point that supported it.\n    //           (by default, the point&#39;s half-width prefix)\n    //\n    uint32 sponsor;\n\n    //  escapeRequestedTo: if :escapeRequested is true, new sponsor requested\n    //\n    uint32 escapeRequestedTo;\n\n    //  cryptoSuiteVersion: version of the crypto suite used for the pubkeys\n    //\n    uint32 cryptoSuiteVersion;\n\n    //  keyRevisionNumber: incremented every time the public keys change\n    //\n    uint32 keyRevisionNumber;\n\n    //  continuityNumber: incremented to indicate network-side state loss\n    //\n    uint32 continuityNumber;\n  }\n\n  //  Deed: permissions for a point\n  //\n  struct Deed\n  {\n    //  owner: address that owns this point\n    //\n    address owner;\n\n    //  managementProxy: 0, or another address with the right to perform\n    //                   low-impact, managerial operations on this point\n    //\n    address managementProxy;\n\n    //  spawnProxy: 0, or another address with the right to spawn children\n    //              of this point\n    //\n    address spawnProxy;\n\n    //  votingProxy: 0, or another address with the right to vote as this point\n    //\n    address votingProxy;\n\n    //  transferProxy: 0, or another address with the right to transfer\n    //                 ownership of this point\n    //\n    address transferProxy;\n  }\n\n//\n//  General state\n//\n\n  //  points: per point, general network-relevant point state\n  //\n  mapping(uint32 => Point) public points;\n\n  //  rights: per point, on-chain ownership and permissions\n  //\n  mapping(uint32 => Deed) public rights;\n\n  //  operators: per owner, per address, has the right to transfer ownership\n  //             of all the owner&#39;s points (ERC721)\n  //\n  mapping(address => mapping(address => bool)) public operators;\n\n  //  dnsDomains: base domains for contacting galaxies\n  //\n  //    dnsDomains[0] is primary, the others are used as fallbacks\n  //\n  string[3] public dnsDomains;\n\n//\n//  Lookups\n//\n\n  //  sponsoring: per point, the points they are sponsoring\n  //\n  mapping(uint32 => uint32[]) public sponsoring;\n\n  //  sponsoringIndexes: per point, per point, (index + 1) in\n  //                     the sponsoring array\n  //\n  mapping(uint32 => mapping(uint32 => uint256)) public sponsoringIndexes;\n\n  //  escapeRequests: per point, the points they have open escape requests from\n  //\n  mapping(uint32 => uint32[]) public escapeRequests;\n\n  //  escapeRequestsIndexes: per point, per point, (index + 1) in\n  //                         the escapeRequests array\n  //\n  mapping(uint32 => mapping(uint32 => uint256)) public escapeRequestsIndexes;\n\n  //  pointsOwnedBy: per address, the points they own\n  //\n  mapping(address => uint32[]) public pointsOwnedBy;\n\n  //  pointOwnerIndexes: per owner, per point, (index + 1) in\n  //                     the pointsOwnedBy array\n  //\n  //    We delete owners by moving the last entry in the array to the\n  //    newly emptied slot, which is (n - 1) where n is the value of\n  //    pointOwnerIndexes[owner][point].\n  //\n  mapping(address => mapping(uint32 => uint256)) public pointOwnerIndexes;\n\n  //  managerFor: per address, the points they are the management proxy for\n  //\n  mapping(address => uint32[]) public managerFor;\n\n  //  managerForIndexes: per address, per point, (index + 1) in\n  //                     the managerFor array\n  //\n  mapping(address => mapping(uint32 => uint256)) public managerForIndexes;\n\n  //  spawningFor: per address, the points they can spawn with\n  //\n  mapping(address => uint32[]) public spawningFor;\n\n  //  spawningForIndexes: per address, per point, (index + 1) in\n  //                      the spawningFor array\n  //\n  mapping(address => mapping(uint32 => uint256)) public spawningForIndexes;\n\n  //  votingFor: per address, the points they can vote with\n  //\n  mapping(address => uint32[]) public votingFor;\n\n  //  votingForIndexes: per address, per point, (index + 1) in\n  //                    the votingFor array\n  //\n  mapping(address => mapping(uint32 => uint256)) public votingForIndexes;\n\n  //  transferringFor: per address, the points they can transfer\n  //\n  mapping(address => uint32[]) public transferringFor;\n\n  //  transferringForIndexes: per address, per point, (index + 1) in\n  //                          the transferringFor array\n  //\n  mapping(address => mapping(uint32 => uint256)) public transferringForIndexes;\n\n//\n//  Logic\n//\n\n  //  constructor(): configure default dns domains\n  //\n  constructor()\n    public\n  {\n    setDnsDomains(\"example.com\", \"example.com\", \"example.com\");\n  }\n\n  //  setDnsDomains(): set the base domains used for contacting galaxies\n  //\n  //    Note: since a string is really just a byte[], and Solidity can&#39;t\n  //    work with two-dimensional arrays yet, we pass in the three\n  //    domains as individual strings.\n  //\n  function setDnsDomains(string _primary, string _secondary, string _tertiary)\n    onlyOwner\n    public\n  {\n    dnsDomains[0] = _primary;\n    dnsDomains[1] = _secondary;\n    dnsDomains[2] = _tertiary;\n    emit ChangedDns(_primary, _secondary, _tertiary);\n  }\n\n  //\n  //  Point reading\n  //\n\n    //  isActive(): return true if _point is active\n    //\n    function isActive(uint32 _point)\n      view\n      external\n      returns (bool equals)\n    {\n      return points[_point].active;\n    }\n\n    //  getKeys(): returns the public keys and their details, as currently\n    //             registered for _point\n    //\n    function getKeys(uint32 _point)\n      view\n      external\n      returns (bytes32 crypt, bytes32 auth, uint32 suite, uint32 revision)\n    {\n      Point storage point = points[_point];\n      return (point.encryptionKey,\n              point.authenticationKey,\n              point.cryptoSuiteVersion,\n              point.keyRevisionNumber);\n    }\n\n    //  getKeyRevisionNumber(): gets the revision number of _point&#39;s current\n    //                          public keys\n    //\n    function getKeyRevisionNumber(uint32 _point)\n      view\n      external\n      returns (uint32 revision)\n    {\n      return points[_point].keyRevisionNumber;\n    }\n\n    //  hasBeenLinked(): returns true if the point has ever been assigned keys\n    //\n    function hasBeenLinked(uint32 _point)\n      view\n      external\n      returns (bool result)\n    {\n      return ( points[_point].keyRevisionNumber > 0 );\n    }\n\n    //  isLive(): returns true if _point currently has keys properly configured\n    //\n    function isLive(uint32 _point)\n      view\n      external\n      returns (bool result)\n    {\n      Point storage point = points[_point];\n      return ( point.encryptionKey != 0 &&\n               point.authenticationKey != 0 &&\n               point.cryptoSuiteVersion != 0 );\n    }\n\n    //  getContinuityNumber(): returns _point&#39;s current continuity number\n    //\n    function getContinuityNumber(uint32 _point)\n      view\n      external\n      returns (uint32 continuityNumber)\n    {\n      return points[_point].continuityNumber;\n    }\n\n    //  getSpawnCount(): return the number of children spawned by _point\n    //\n    function getSpawnCount(uint32 _point)\n      view\n      external\n      returns (uint32 spawnCount)\n    {\n      uint256 len = points[_point].spawned.length;\n      assert(len < 2**32);\n      return uint32(len);\n    }\n\n    //  getSpawned(): return array of points created under _point\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getSpawned(uint32 _point)\n      view\n      external\n      returns (uint32[] spawned)\n    {\n      return points[_point].spawned;\n    }\n\n    //  hasSponsor(): returns true if _point&#39;s sponsor is providing it service\n    //\n    function hasSponsor(uint32 _point)\n      view\n      external\n      returns (bool has)\n    {\n      return points[_point].hasSponsor;\n    }\n\n    //  getSponsor(): returns _point&#39;s current (or most recent) sponsor\n    //\n    function getSponsor(uint32 _point)\n      view\n      external\n      returns (uint32 sponsor)\n    {\n      return points[_point].sponsor;\n    }\n\n    //  isSponsor(): returns true if _sponsor is currently providing service\n    //               to _point\n    //\n    function isSponsor(uint32 _point, uint32 _sponsor)\n      view\n      external\n      returns (bool result)\n    {\n      Point storage point = points[_point];\n      return ( point.hasSponsor &&\n               (point.sponsor == _sponsor) );\n    }\n\n    //  getSponsoringCount(): returns the number of points _sponsor is\n    //                        providing service to\n    //\n    function getSponsoringCount(uint32 _sponsor)\n      view\n      external\n      returns (uint256 count)\n    {\n      return sponsoring[_sponsor].length;\n    }\n\n    //  getSponsoring(): returns a list of points _sponsor is providing\n    //                   service to\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getSponsoring(uint32 _sponsor)\n      view\n      external\n      returns (uint32[] sponsees)\n    {\n      return sponsoring[_sponsor];\n    }\n\n    //  escaping\n\n    //  isEscaping(): returns true if _point has an outstanding escape request\n    //\n    function isEscaping(uint32 _point)\n      view\n      external\n      returns (bool escaping)\n    {\n      return points[_point].escapeRequested;\n    }\n\n    //  getEscapeRequest(): returns _point&#39;s current escape request\n    //\n    //    the returned escape request is only valid as long as isEscaping()\n    //    returns true\n    //\n    function getEscapeRequest(uint32 _point)\n      view\n      external\n      returns (uint32 escape)\n    {\n      return points[_point].escapeRequestedTo;\n    }\n\n    //  isRequestingEscapeTo(): returns true if _point has an outstanding\n    //                          escape request targetting _sponsor\n    //\n    function isRequestingEscapeTo(uint32 _point, uint32 _sponsor)\n      view\n      public\n      returns (bool equals)\n    {\n      Point storage point = points[_point];\n      return (point.escapeRequested && (point.escapeRequestedTo == _sponsor));\n    }\n\n    //  getEscapeRequestsCount(): returns the number of points _sponsor\n    //                            is providing service to\n    //\n    function getEscapeRequestsCount(uint32 _sponsor)\n      view\n      external\n      returns (uint256 count)\n    {\n      return escapeRequests[_sponsor].length;\n    }\n\n    //  getEscapeRequests(): get the points _sponsor has received escape\n    //                       requests from\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getEscapeRequests(uint32 _sponsor)\n      view\n      external\n      returns (uint32[] requests)\n    {\n      return escapeRequests[_sponsor];\n    }\n\n  //\n  //  Point writing\n  //\n\n    //  activatePoint(): activate a point, register it as spawned by its prefix\n    //\n    function activatePoint(uint32 _point)\n      onlyOwner\n      external\n    {\n      //  make a point active, setting its sponsor to its prefix\n      //\n      Point storage point = points[_point];\n      require(!point.active);\n      point.active = true;\n      registerSponsor(_point, true, getPrefix(_point));\n      emit Activated(_point);\n    }\n\n    //  setKeys(): set network public keys of _point to _encryptionKey and\n    //            _authenticationKey, with the specified _cryptoSuiteVersion\n    //\n    function setKeys(uint32 _point,\n                     bytes32 _encryptionKey,\n                     bytes32 _authenticationKey,\n                     uint32 _cryptoSuiteVersion)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      if ( point.encryptionKey == _encryptionKey &&\n           point.authenticationKey == _authenticationKey &&\n           point.cryptoSuiteVersion == _cryptoSuiteVersion )\n      {\n        return;\n      }\n\n      point.encryptionKey = _encryptionKey;\n      point.authenticationKey = _authenticationKey;\n      point.cryptoSuiteVersion = _cryptoSuiteVersion;\n      point.keyRevisionNumber++;\n\n      emit ChangedKeys(_point,\n                       _encryptionKey,\n                       _authenticationKey,\n                       _cryptoSuiteVersion,\n                       point.keyRevisionNumber);\n    }\n\n    //  incrementContinuityNumber(): break continuity for _point\n    //\n    function incrementContinuityNumber(uint32 _point)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      point.continuityNumber++;\n      emit BrokeContinuity(_point, point.continuityNumber);\n    }\n\n    //  registerSpawn(): add a point to its prefix&#39;s list of spawned points\n    //\n    function registerSpawned(uint32 _point)\n      onlyOwner\n      external\n    {\n      //  if a point is its own prefix (a galaxy) then don&#39;t register it\n      //\n      uint32 prefix = getPrefix(_point);\n      if (prefix == _point)\n      {\n        return;\n      }\n\n      //  register a new spawned point for the prefix\n      //\n      points[prefix].spawned.push(_point);\n      emit Spawned(prefix, _point);\n    }\n\n    //  loseSponsor(): indicates that _point&#39;s sponsor is no longer providing\n    //                 it service\n    //\n    function loseSponsor(uint32 _point)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      if (!point.hasSponsor)\n      {\n        return;\n      }\n      registerSponsor(_point, false, point.sponsor);\n      emit LostSponsor(_point, point.sponsor);\n    }\n\n    //  setEscapeRequest(): for _point, start an escape request to _sponsor\n    //\n    function setEscapeRequest(uint32 _point, uint32 _sponsor)\n      onlyOwner\n      external\n    {\n      if (isRequestingEscapeTo(_point, _sponsor))\n      {\n        return;\n      }\n      registerEscapeRequest(_point, true, _sponsor);\n      emit EscapeRequested(_point, _sponsor);\n    }\n\n    //  cancelEscape(): for _point, stop the current escape request, if any\n    //\n    function cancelEscape(uint32 _point)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      if (!point.escapeRequested)\n      {\n        return;\n      }\n      uint32 request = point.escapeRequestedTo;\n      registerEscapeRequest(_point, false, 0);\n      emit EscapeCanceled(_point, request);\n    }\n\n    //  doEscape(): perform the requested escape\n    //\n    function doEscape(uint32 _point)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      require(point.escapeRequested);\n      registerSponsor(_point, true, point.escapeRequestedTo);\n      registerEscapeRequest(_point, false, 0);\n      emit EscapeAccepted(_point, point.sponsor);\n    }\n\n  //\n  //  Point utils\n  //\n\n    //  getPrefix(): compute prefix (\"parent\") of _point\n    //\n    function getPrefix(uint32 _point)\n      pure\n      public\n      returns (uint16 prefix)\n    {\n      if (_point < 0x10000)\n      {\n        return uint16(_point % 0x100);\n      }\n      return uint16(_point % 0x10000);\n    }\n\n    //  getPointSize(): return the size of _point\n    //\n    function getPointSize(uint32 _point)\n      external\n      pure\n      returns (Size _size)\n    {\n      if (_point < 0x100) return Size.Galaxy;\n      if (_point < 0x10000) return Size.Star;\n      return Size.Planet;\n    }\n\n    //  internal use\n\n    //  registerSponsor(): set the sponsorship state of _point and update the\n    //                     reverse lookup for sponsors\n    //\n    function registerSponsor(uint32 _point, bool _hasSponsor, uint32 _sponsor)\n      internal\n    {\n      Point storage point = points[_point];\n      bool had = point.hasSponsor;\n      uint32 prev = point.sponsor;\n\n      //  if we didn&#39;t have a sponsor, and won&#39;t get one,\n      //  or if we get the sponsor we already have,\n      //  nothing will change, so jump out early.\n      //\n      if ( (!had && !_hasSponsor) ||\n           (had && _hasSponsor && prev == _sponsor) )\n      {\n        return;\n      }\n\n      //  if the point used to have a different sponsor, do some gymnastics\n      //  to keep the reverse lookup gapless.  delete the point from the old\n      //  sponsor&#39;s list, then fill that gap with the list tail.\n      //\n      if (had)\n      {\n        //  i: current index in previous sponsor&#39;s list of sponsored points\n        //\n        uint256 i = sponsoringIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :sponsoringIndexes reference\n        //\n        uint32[] storage prevSponsoring = sponsoring[prev];\n        uint256 last = prevSponsoring.length - 1;\n        uint32 moved = prevSponsoring[last];\n        prevSponsoring[i] = moved;\n        sponsoringIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevSponsoring[last]);\n        prevSponsoring.length = last;\n        sponsoringIndexes[prev][_point] = 0;\n      }\n\n      if (_hasSponsor)\n      {\n        uint32[] storage newSponsoring = sponsoring[_sponsor];\n        newSponsoring.push(_point);\n        sponsoringIndexes[_sponsor][_point] = newSponsoring.length;\n      }\n\n      point.sponsor = _sponsor;\n      point.hasSponsor = _hasSponsor;\n    }\n\n    //  registerEscapeRequest(): set the escape state of _point and update the\n    //                           reverse lookup for sponsors\n    //\n    function registerEscapeRequest( uint32 _point,\n                                    bool _isEscaping, uint32 _sponsor )\n      internal\n    {\n      Point storage point = points[_point];\n      bool was = point.escapeRequested;\n      uint32 prev = point.escapeRequestedTo;\n\n      //  if we weren&#39;t escaping, and won&#39;t be,\n      //  or if we were escaping, and the new target is the same,\n      //  nothing will change, so jump out early.\n      //\n      if ( (!was && !_isEscaping) ||\n           (was && _isEscaping && prev == _sponsor) )\n      {\n        return;\n      }\n\n      //  if the point used to have a different request, do some gymnastics\n      //  to keep the reverse lookup gapless.  delete the point from the old\n      //  sponsor&#39;s list, then fill that gap with the list tail.\n      //\n      if (was)\n      {\n        //  i: current index in previous sponsor&#39;s list of sponsored points\n        //\n        uint256 i = escapeRequestsIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :escapeRequestsIndexes reference\n        //\n        uint32[] storage prevRequests = escapeRequests[prev];\n        uint256 last = prevRequests.length - 1;\n        uint32 moved = prevRequests[last];\n        prevRequests[i] = moved;\n        escapeRequestsIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevRequests[last]);\n        prevRequests.length = last;\n        escapeRequestsIndexes[prev][_point] = 0;\n      }\n\n      if (_isEscaping)\n      {\n        uint32[] storage newRequests = escapeRequests[_sponsor];\n        newRequests.push(_point);\n        escapeRequestsIndexes[_sponsor][_point] = newRequests.length;\n      }\n\n      point.escapeRequestedTo = _sponsor;\n      point.escapeRequested = _isEscaping;\n    }\n\n  //\n  //  Deed reading\n  //\n\n    //  owner\n\n    //  getOwner(): return owner of _point\n    //\n    function getOwner(uint32 _point)\n      view\n      external\n      returns (address owner)\n    {\n      return rights[_point].owner;\n    }\n\n    //  isOwner(): true if _point is owned by _address\n    //\n    function isOwner(uint32 _point, address _address)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].owner == _address);\n    }\n\n    //  getOwnedPointCount(): return length of array of points that _whose owns\n    //\n    function getOwnedPointCount(address _whose)\n      view\n      external\n      returns (uint256 count)\n    {\n      return pointsOwnedBy[_whose].length;\n    }\n\n    //  getOwnedPoints(): return array of points that _whose owns\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getOwnedPoints(address _whose)\n      view\n      external\n      returns (uint32[] ownedPoints)\n    {\n      return pointsOwnedBy[_whose];\n    }\n\n    //  getOwnedPointAtIndex(): get point at _index from array of points that\n    //                         _whose owns\n    //\n    function getOwnedPointAtIndex(address _whose, uint256 _index)\n      view\n      external\n      returns (uint32 point)\n    {\n      uint32[] storage owned = pointsOwnedBy[_whose];\n      require(_index < owned.length);\n      return owned[_index];\n    }\n\n    //  management proxy\n\n    //  getManagementProxy(): returns _point&#39;s current management proxy\n    //\n    function getManagementProxy(uint32 _point)\n      view\n      external\n      returns (address manager)\n    {\n      return rights[_point].managementProxy;\n    }\n\n    //  isManagementProxy(): returns true if _proxy is _point&#39;s management proxy\n    //\n    function isManagementProxy(uint32 _point, address _proxy)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].managementProxy == _proxy);\n    }\n\n    //  canManage(): true if _who is the owner or manager of _point\n    //\n    function canManage(uint32 _point, address _who)\n      view\n      external\n      returns (bool result)\n    {\n      Deed storage deed = rights[_point];\n      return ( (0x0 != _who) &&\n               ( (_who == deed.owner) ||\n                 (_who == deed.managementProxy) ) );\n    }\n\n    //  getManagerForCount(): returns the amount of points _proxy can manage\n    //\n    function getManagerForCount(address _proxy)\n      view\n      external\n      returns (uint256 count)\n    {\n      return managerFor[_proxy].length;\n    }\n\n    //  getManagerFor(): returns the points _proxy can manage\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getManagerFor(address _proxy)\n      view\n      external\n      returns (uint32[] mfor)\n    {\n      return managerFor[_proxy];\n    }\n\n    //  spawn proxy\n\n    //  getSpawnProxy(): returns _point&#39;s current spawn proxy\n    //\n    function getSpawnProxy(uint32 _point)\n      view\n      external\n      returns (address spawnProxy)\n    {\n      return rights[_point].spawnProxy;\n    }\n\n    //  isSpawnProxy(): returns true if _proxy is _point&#39;s spawn proxy\n    //\n    function isSpawnProxy(uint32 _point, address _proxy)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].spawnProxy == _proxy);\n    }\n\n    //  canSpawnAs(): true if _who is the owner or spawn proxy of _point\n    //\n    function canSpawnAs(uint32 _point, address _who)\n      view\n      external\n      returns (bool result)\n    {\n      Deed storage deed = rights[_point];\n      return ( (0x0 != _who) &&\n               ( (_who == deed.owner) ||\n                 (_who == deed.spawnProxy) ) );\n    }\n\n    //  getSpawningForCount(): returns the amount of points _proxy\n    //                         can spawn with\n    //\n    function getSpawningForCount(address _proxy)\n      view\n      external\n      returns (uint256 count)\n    {\n      return spawningFor[_proxy].length;\n    }\n\n    //  getSpawningFor(): get the points _proxy can spawn with\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getSpawningFor(address _proxy)\n      view\n      external\n      returns (uint32[] sfor)\n    {\n      return spawningFor[_proxy];\n    }\n\n    //  voting proxy\n\n    //  getVotingProxy(): returns _point&#39;s current voting proxy\n    //\n    function getVotingProxy(uint32 _point)\n      view\n      external\n      returns (address voter)\n    {\n      return rights[_point].votingProxy;\n    }\n\n    //  isVotingProxy(): returns true if _proxy is _point&#39;s voting proxy\n    //\n    function isVotingProxy(uint32 _point, address _proxy)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].votingProxy == _proxy);\n    }\n\n    //  canVoteAs(): true if _who is the owner of _point,\n    //               or the voting proxy of _point&#39;s owner\n    //\n    function canVoteAs(uint32 _point, address _who)\n      view\n      external\n      returns (bool result)\n    {\n      Deed storage deed = rights[_point];\n      return ( (0x0 != _who) &&\n               ( (_who == deed.owner) ||\n                 (_who == deed.votingProxy) ) );\n    }\n\n    //  getVotingForCount(): returns the amount of points _proxy can vote as\n    //\n    function getVotingForCount(address _proxy)\n      view\n      external\n      returns (uint256 count)\n    {\n      return votingFor[_proxy].length;\n    }\n\n    //  getVotingFor(): returns the points _proxy can vote as\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getVotingFor(address _proxy)\n      view\n      external\n      returns (uint32[] vfor)\n    {\n      return votingFor[_proxy];\n    }\n\n    //  transfer proxy\n\n    //  getTransferProxy(): returns _point&#39;s current transfer proxy\n    //\n    function getTransferProxy(uint32 _point)\n      view\n      external\n      returns (address transferProxy)\n    {\n      return rights[_point].transferProxy;\n    }\n\n    //  isTransferProxy(): returns true if _proxy is _point&#39;s transfer proxy\n    //\n    function isTransferProxy(uint32 _point, address _proxy)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].transferProxy == _proxy);\n    }\n\n    //  canTransfer(): true if _who is the owner or transfer proxy of _point,\n    //                 or is an operator for _point&#39;s current owner\n    //\n    function canTransfer(uint32 _point, address _who)\n      view\n      external\n      returns (bool result)\n    {\n      Deed storage deed = rights[_point];\n      return ( (0x0 != _who) &&\n               ( (_who == deed.owner) ||\n                 (_who == deed.transferProxy) ||\n                 operators[deed.owner][_who] ) );\n    }\n\n    //  getTransferringForCount(): returns the amount of points _proxy\n    //                             can transfer\n    //\n    function getTransferringForCount(address _proxy)\n      view\n      external\n      returns (uint256 count)\n    {\n      return transferringFor[_proxy].length;\n    }\n\n    //  getTransferringFor(): get the points _proxy can transfer\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getTransferringFor(address _proxy)\n      view\n      external\n      returns (uint32[] tfor)\n    {\n      return transferringFor[_proxy];\n    }\n\n    //  isOperator(): returns true if _operator is allowed to transfer\n    //                ownership of _owner&#39;s points\n    //\n    function isOperator(address _owner, address _operator)\n      view\n      external\n      returns (bool result)\n    {\n      return operators[_owner][_operator];\n    }\n\n  //\n  //  Deed writing\n  //\n\n    //  setOwner(): set owner of _point to _owner\n    //\n    //    Note: setOwner() only implements the minimal data storage\n    //    logic for a transfer; the full transfer is implemented in\n    //    Ecliptic.\n    //\n    //    Note: _owner must not be the zero address.\n    //\n    function setOwner(uint32 _point, address _owner)\n      onlyOwner\n      external\n    {\n      //  prevent burning of points by making zero the owner\n      //\n      require(0x0 != _owner);\n\n      //  prev: previous owner, if any\n      //\n      address prev = rights[_point].owner;\n\n      if (prev == _owner)\n      {\n        return;\n      }\n\n      //  if the point used to have a different owner, do some gymnastics to\n      //  keep the list of owned points gapless.  delete this point from the\n      //  list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous owner&#39;s list of owned points\n        //\n        uint256 i = pointOwnerIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :pointOwnerIndexes reference\n        //\n        uint32[] storage owner = pointsOwnedBy[prev];\n        uint256 last = owner.length - 1;\n        uint32 moved = owner[last];\n        owner[i] = moved;\n        pointOwnerIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(owner[last]);\n        owner.length = last;\n        pointOwnerIndexes[prev][_point] = 0;\n      }\n\n      //  update the owner list and the owner&#39;s index list\n      //\n      rights[_point].owner = _owner;\n      pointsOwnedBy[_owner].push(_point);\n      pointOwnerIndexes[_owner][_point] = pointsOwnedBy[_owner].length;\n      emit OwnerChanged(_point, _owner);\n    }\n\n    //  setManagementProxy(): makes _proxy _point&#39;s management proxy\n    //\n    function setManagementProxy(uint32 _point, address _proxy)\n      onlyOwner\n      external\n    {\n      Deed storage deed = rights[_point];\n      address prev = deed.managementProxy;\n      if (prev == _proxy)\n      {\n        return;\n      }\n\n      //  if the point used to have a different manager, do some gymnastics\n      //  to keep the reverse lookup gapless.  delete the point from the\n      //  old manager&#39;s list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous manager&#39;s list of managed points\n        //\n        uint256 i = managerForIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :managerForIndexes reference\n        //\n        uint32[] storage prevMfor = managerFor[prev];\n        uint256 last = prevMfor.length - 1;\n        uint32 moved = prevMfor[last];\n        prevMfor[i] = moved;\n        managerForIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevMfor[last]);\n        prevMfor.length = last;\n        managerForIndexes[prev][_point] = 0;\n      }\n\n      if (0x0 != _proxy)\n      {\n        uint32[] storage mfor = managerFor[_proxy];\n        mfor.push(_point);\n        managerForIndexes[_proxy][_point] = mfor.length;\n      }\n\n      deed.managementProxy = _proxy;\n      emit ChangedManagementProxy(_point, _proxy);\n    }\n\n    //  setSpawnProxy(): makes _proxy _point&#39;s spawn proxy\n    //\n    function setSpawnProxy(uint32 _point, address _proxy)\n      onlyOwner\n      external\n    {\n      Deed storage deed = rights[_point];\n      address prev = deed.spawnProxy;\n      if (prev == _proxy)\n      {\n        return;\n      }\n\n      //  if the point used to have a different spawn proxy, do some\n      //  gymnastics to keep the reverse lookup gapless.  delete the point\n      //  from the old proxy&#39;s list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous proxy&#39;s list of spawning points\n        //\n        uint256 i = spawningForIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :spawningForIndexes reference\n        //\n        uint32[] storage prevSfor = spawningFor[prev];\n        uint256 last = prevSfor.length - 1;\n        uint32 moved = prevSfor[last];\n        prevSfor[i] = moved;\n        spawningForIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevSfor[last]);\n        prevSfor.length = last;\n        spawningForIndexes[prev][_point] = 0;\n      }\n\n      if (0x0 != _proxy)\n      {\n        uint32[] storage sfor = spawningFor[_proxy];\n        sfor.push(_point);\n        spawningForIndexes[_proxy][_point] = sfor.length;\n      }\n\n      deed.spawnProxy = _proxy;\n      emit ChangedSpawnProxy(_point, _proxy);\n    }\n\n    //  setVotingProxy(): makes _proxy _point&#39;s voting proxy\n    //\n    function setVotingProxy(uint32 _point, address _proxy)\n      onlyOwner\n      external\n    {\n      Deed storage deed = rights[_point];\n      address prev = deed.votingProxy;\n      if (prev == _proxy)\n      {\n        return;\n      }\n\n      //  if the point used to have a different voter, do some gymnastics\n      //  to keep the reverse lookup gapless.  delete the point from the\n      //  old voter&#39;s list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous voter&#39;s list of points it was\n        //     voting for\n        //\n        uint256 i = votingForIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :votingForIndexes reference\n        //\n        uint32[] storage prevVfor = votingFor[prev];\n        uint256 last = prevVfor.length - 1;\n        uint32 moved = prevVfor[last];\n        prevVfor[i] = moved;\n        votingForIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevVfor[last]);\n        prevVfor.length = last;\n        votingForIndexes[prev][_point] = 0;\n      }\n\n      if (0x0 != _proxy)\n      {\n        uint32[] storage vfor = votingFor[_proxy];\n        vfor.push(_point);\n        votingForIndexes[_proxy][_point] = vfor.length;\n      }\n\n      deed.votingProxy = _proxy;\n      emit ChangedVotingProxy(_point, _proxy);\n    }\n\n    //  setManagementProxy(): makes _proxy _point&#39;s transfer proxy\n    //\n    function setTransferProxy(uint32 _point, address _proxy)\n      onlyOwner\n      external\n    {\n      Deed storage deed = rights[_point];\n      address prev = deed.transferProxy;\n      if (prev == _proxy)\n      {\n        return;\n      }\n\n      //  if the point used to have a different transfer proxy, do some\n      //  gymnastics to keep the reverse lookup gapless.  delete the point\n      //  from the old proxy&#39;s list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous proxy&#39;s list of transferable points\n        //\n        uint256 i = transferringForIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :transferringForIndexes reference\n        //\n        uint32[] storage prevTfor = transferringFor[prev];\n        uint256 last = prevTfor.length - 1;\n        uint32 moved = prevTfor[last];\n        prevTfor[i] = moved;\n        transferringForIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevTfor[last]);\n        prevTfor.length = last;\n        transferringForIndexes[prev][_point] = 0;\n      }\n\n      if (0x0 != _proxy)\n      {\n        uint32[] storage tfor = transferringFor[_proxy];\n        tfor.push(_point);\n        transferringForIndexes[_proxy][_point] = tfor.length;\n      }\n\n      deed.transferProxy = _proxy;\n      emit ChangedTransferProxy(_point, _proxy);\n    }\n\n    //  setOperator(): dis/allow _operator to transfer ownership of all points\n    //                 owned by _owner\n    //\n    //    operators are part of the ERC721 standard\n    //\n    function setOperator(address _owner, address _operator, bool _approved)\n      onlyOwner\n      external\n    {\n      operators[_owner][_operator] = _approved;\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//  EclipticResolver\n////////////////////////////////////////////////////////////////////////////////\n\n\ncontract EclipticResolver is ResolverInterface\n{\n  Azimuth azimuth;\n\n  constructor(Azimuth _azimuth)\n    public\n  {\n    azimuth = _azimuth;\n  }\n\n  function addr(bytes32 node)\n    constant\n    public\n    returns (address)\n  {\n    //  resolve to the Ecliptic contract\n    return azimuth.owner();\n  }\n\n  function supportsInterface(bytes4 interfaceID)\n    pure\n    public\n    returns (bool)\n  {\n    //  supports ERC-137 addr() and ERC-165\n    return interfaceID == 0x3b3b57de || interfaceID == 0x01ffc9a7;\n  }\n\n  //  ERC-137 resolvers MUST specify a fallback function that throws\n  function()\n    public\n  {\n    revert();\n  }\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x6191078c2736140dC15D4dA1Bf7f83f9cB46DD58",
    "source_code": "pragma solidity ^0.4.18;\n\n// ----------------------------------------------------------------------------\n// &#39;ZIMBOCOIN&#39; token contract\n//\n// Deployed to : 0x9a33836F185A8CedFE56dB2799063133af1b6869\n// Symbol      : ZMB\n// Name        : ZIMBOCOIN\n// Total supply: 100000000\n// Decimals    : 8\n//\n// Enjoy.\n//\n// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.\n// ----------------------------------------------------------------------------\n\n\n// ----------------------------------------------------------------------------\n// Safe maths\n// ----------------------------------------------------------------------------\ncontract SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n// ----------------------------------------------------------------------------\ncontract ERC20Interface {\n    function totalSupply() public constant returns (uint);\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\n// ----------------------------------------------------------------------------\n// Contract function to receive approval and execute function in one call\n//\n// Borrowed from MiniMeToken\n// ----------------------------------------------------------------------------\ncontract ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n}\n\n\n// ----------------------------------------------------------------------------\n// Owned contract\n// ----------------------------------------------------------------------------\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\n// token transfers\n// ----------------------------------------------------------------------------\ncontract ZIMBOCOIN is ERC20Interface, Owned, SafeMath {\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    function ZIMBOCOIN() public {\n        symbol = \"ZMB\";\n        name = \"ZIMBOCOIN\";\n        decimals = 8;\n        _totalSupply = 100000000000000;\n        balances[0x9a33836F185A8CedFE56dB2799063133af1b6869] = _totalSupply;\n        Transfer(address(0), 0x9a33836F185A8CedFE56dB2799063133af1b6869, _totalSupply);\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Total supply\n    // ------------------------------------------------------------------------\n    function totalSupply() public constant returns (uint) {\n        return _totalSupply  - balances[address(0)];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Get the token balance for account tokenOwner\n    // ------------------------------------------------------------------------\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer the balance from token owner&#39;s account to to account\n    // - Owner&#39;s account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transfer(address to, uint tokens) public returns (bool success) {\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner&#39;s account\n    //\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n    // recommends that there are no checks for the approval double-spend attack\n    // as this should be implemented in user interfaces \n    // ------------------------------------------------------------------------\n    function approve(address spender, uint tokens) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer tokens from the from account to the to account\n    // \n    // The calling account must already have sufficient tokens approve(...)-d\n    // for spending from the from account and\n    // - From account must have sufficient balance to transfer\n    // - Spender must have sufficient allowance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        balances[from] = safeSub(balances[from], tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        Transfer(from, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Returns the amount of tokens approved by the owner that can be\n    // transferred to the spender&#39;s account\n    // ------------------------------------------------------------------------\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner&#39;s account. The spender contract function\n    // receiveApproval(...) is then executed\n    // ------------------------------------------------------------------------\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Don&#39;t accept ETH\n    // ------------------------------------------------------------------------\n    function () public payable {\n        revert();\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    // ------------------------------------------------------------------------\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }\n}",
    "vulnerability_type": "denial_of_service"
  },
  {
    "address": "0x61b0daf159606e7ae6ef01670710dfc648df40d4",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-03-05\n*/\n\npragma solidity ^0.4.24;\n\n// ----------------------------------------------------------------------------\n// Sample token contract\n//\n// Symbol        : CFE\n// Name          : CAFE Coin\n// Total supply  : 2000000000000000\n// Decimals      : 8\n// Owner Account : 0x9Ce32a5Ef50385c53602455ad67Dd5324AbdF4D2\n//\n// Enjoy.\n//\n// (c) by Juan Cruz Martinez 2020. MIT Licence.\n// ----------------------------------------------------------------------------\n\n\n// ----------------------------------------------------------------------------\n// Lib: Safe Math\n// ----------------------------------------------------------------------------\ncontract SafeMath {\n\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\n/**\nERC Token Standard #20 Interface\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n*/\ncontract ERC20Interface {\n    function totalSupply() public constant returns (uint);\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\n/**\nContract function to receive approval and execute function in one call\n\nBorrowed from MiniMeToken\n*/\ncontract ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n}\n\n/**\nERC20 Token, with the addition of symbol, name and decimals and assisted token transfers\n*/\ncontract CFEToken is ERC20Interface, SafeMath {\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    constructor() public {\n        symbol = \"CFE\";\n        name = \"CAFE Coin\";\n        decimals = 8;\n        _totalSupply = 2000000000000000;\n        balances[0x9Ce32a5Ef50385c53602455ad67Dd5324AbdF4D2] = _totalSupply;\n        emit Transfer(address(0), 0x9Ce32a5Ef50385c53602455ad67Dd5324AbdF4D2, _totalSupply);\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Total supply\n    // ------------------------------------------------------------------------\n    function totalSupply() public constant returns (uint) {\n        return _totalSupply  - balances[address(0)];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Get the token balance for account tokenOwner\n    // ------------------------------------------------------------------------\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer the balance from token owner's account to to account\n    // - Owner's account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transfer(address to, uint tokens) public returns (bool success) {\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner's account\n    //\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n    // recommends that there are no checks for the approval double-spend attack\n    // as this should be implemented in user interfaces \n    // ------------------------------------------------------------------------\n    function approve(address spender, uint tokens) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer tokens from the from account to the to account\n    // \n    // The calling account must already have sufficient tokens approve(...)-d\n    // for spending from the from account and\n    // - From account must have sufficient balance to transfer\n    // - Spender must have sufficient allowance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        balances[from] = safeSub(balances[from], tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Returns the amount of tokens approved by the owner that can be\n    // transferred to the spender's account\n    // ------------------------------------------------------------------------\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner's account. The spender contract function\n    // receiveApproval(...) is then executed\n    // ------------------------------------------------------------------------\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Don't accept ETH\n    // ------------------------------------------------------------------------\n    function () public payable {\n        revert();\n    }\n}",
    "vulnerability_type": "denial_of_service"
  },
  {
    "address": "0x61d1641b26394849af829eb8313f35de2716a713",
    "source_code": "pragma solidity ^0.4.18;\n\ncontract Token {\n    uint256 public totalSupply;\n    function balanceOf(address _owner) constant returns (uint256 balance);\n    function transfer(address _to, uint256 _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    function () public payable {\n        revert();\n    }\n}\n\n\n/*  ERC 20 token */\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (balances[msg.sender] >= _value && _value > 0) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (balances[_to] + _value < balances[_to]) revert(); // Check for overflows\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n            balances[_to] += _value;\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    function () public payable {\n        revert();\n    }\n}\ncontract SafeMath {\n\n    /* function assert(bool assertion) internal { */\n    /*   if (!assertion) { */\n    /*     throw; */\n    /*   } */\n    /* }      // assert no longer needed once solidity is on 0.4.10 */\n\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n        uint256 z = x + y;\n        assert((z >= x) && (z >= y));\n        return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n        assert(x >= y);\n        uint256 z = x - y;\n        return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n        uint256 z = x * y;\n        assert((x == 0)||(z/x == y));\n        return z;\n    }\n\n    function () public payable {\n        revert();\n    }\n\n}\ncontract Owner {\n\n\t/// @dev `owner` is the only address that can call a function with this\n\t/// modifier\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\n\taddress public owner;\n\n\t/// @notice The Constructor assigns the message sender to be `owner`\n\tfunction Owner() public {\n\t\towner = msg.sender;\n\t}\n\n\taddress public newOwner;\n\n\t/// @notice `owner` can step down and assign some other address to this role\n\t/// @param _newOwner The address of the new owner. 0x0 can be used to create\n\t///  an unowned neutral vault, however that cannot be undone\n\tfunction changeOwner(address _newOwner) public onlyOwner {\n\t\tnewOwner = _newOwner;\n\t}\n\n\n\tfunction acceptOwnership() public {\n\t\tif (msg.sender == newOwner) {\n\t\t\towner = newOwner;\n\t\t}\n\t}\n\n\tfunction () public payable {\n\t\trevert();\n\t}\n\n}\ncontract BRM is Owner, StandardToken, SafeMath {\n\tstring public constant name = \"BrahmaOS\";\n\tstring public constant symbol = \"BRM\";\n\tuint256 public constant decimals = 18;\n\tstring public version = \"1.0\";\n\n\n\tuint256 public constant total = 3 * 10**9 * 10**decimals;\n\n\tfunction BRM() {\n\n\t\ttotalSupply = total;\n\t\tbalances[msg.sender] = total;\n\t}\n\tfunction () public payable {\n\t\trevert();\n\t}\n}",
    "vulnerability_type": "denial_of_service"
  },
  {
    "address": "0x61d31d57476c1acf6a81c6eacc3644735a704eb9",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-03-01\n*/\n\npragma solidity ^0.5.0;\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    /**\n     * 0x01ffc9a7 ===\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\n     */\n\n    /**\n     * @dev a mapping of interface id to whether or not it's supported\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev A contract implementing SupportsInterfaceWithLookup\n     * implement ERC165 itself\n     */\n    constructor() internal {\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev implement supportsInterface(bytes4) using a lookup table\n     */\n    function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        returns (bool)\n    {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev internal method for registering an interface\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff);\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721 is IERC165 {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    function approve(address to, uint256 tokenId) public;\n\n    function getApproved(uint256 tokenId)\n        public\n        view\n        returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public;\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping(uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping(address => uint256) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     * 0x80ac58cd ===\n     *     bytes4(keccak256('balanceOf(address)')) ^\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\n     *     bytes4(keccak256('approve(address,uint256)')) ^\n     *     bytes4(keccak256('getApproved(uint256)')) ^\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n     */\n\n    constructor() public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0));\n        return _ownedTokensCount[owner];\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return owner address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId));\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender);\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     *\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public {\n        transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data));\n    }\n\n    /**\n     * @dev Returns whether the specified token exists\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        returns (bool)\n    {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * Reverts if the given token ID already exists\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0));\n        require(!_exists(tokenId));\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner);\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        require(ownerOf(tokenId) == from);\n        require(to != address(0));\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke `onERC721Received` on a target address\n     * The call is not executed if the target address is not a contract\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval =\n            IERC721Receiver(to).onERC721Received(\n                msg.sender,\n                from,\n                tokenId,\n                _data\n            );\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n    /**\n     * 0x5b5e139f ===\n     *     bytes4(keccak256('name()')) ^\n     *     bytes4(keccak256('symbol()')) ^\n     *     bytes4(keccak256('tokenURI(uint256)'))\n     */\n\n    /**\n     * @dev Constructor function\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n     * @dev Gets the token name\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns an URI for a given token ID\n     * Throws if the token ID does not exist. May return an empty string.\n     * @param tokenId uint256 ID of the token to query\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId));\n        return _tokenURIs[tokenId];\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token\n     * Reverts if the token ID does not exist\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     */\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        require(_exists(tokenId));\n        _tokenURIs[tokenId] = uri;\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * 0x780e9d63 ===\n     *     bytes4(keccak256('totalSupply()')) ^\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n     *     bytes4(keccak256('tokenByIndex(uint256)'))\n     */\n\n    /**\n     * @dev Constructor function\n     */\n    constructor() public {\n        // register the supported interface to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\n     * @param owner address owning the tokens list to be accessed\n     * @param index uint256 representing the index to be accessed of the requested tokens list\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        returns (uint256)\n    {\n        require(index < balanceOf(owner));\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev Gets the total amount of tokens stored by the contract\n     * @return uint256 representing the total amount of tokens\n     */\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of all the tokens in this contract\n     * Reverts if the index is greater or equal to the total number of tokens\n     * @param index uint256 representing the index to be accessed of the tokens list\n     * @return uint256 token ID at the given index of the tokens list\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply());\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        super._transferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * Reverts if the given token ID already exists\n     * @param to address the beneficiary that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n        _ownedTokensIndex[tokenId] = 0;\n\n        _removeTokenFromAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Gets the list of token IDs of the requested owner\n     * @param owner address owning the tokens\n     * @return uint256[] List of token IDs owned by the requested address\n     */\n    function _tokensOfOwner(address owner)\n        internal\n        view\n        returns (uint256[] storage)\n    {\n        return _ownedTokens[owner];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\n        private\n    {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        _ownedTokens[from].length--;\n\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occcupied by\n        // lasTokenId, or just over the end of the array if the token was the last one).\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a `safeTransfer`. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data\n    ) public returns (bytes4);\n}\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n\n/**\n * @title Full ERC721 Token\n * This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n    constructor(string memory name, string memory symbol)\n        public\n        ERC721Metadata(name, symbol)\n    {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\nlibrary Strings {\n    // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d,\n        string memory _e\n    ) internal pure returns (string memory) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde =\n            new string(\n                _ba.length + _bb.length + _bc.length + _bd.length + _be.length\n            );\n        bytes memory babcde = bytes(abcde);\n        uint256 k = 0;\n        for (uint256 i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (uint256 i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (uint256 i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (uint256 i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (uint256 i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d\n    ) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c\n    ) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b)\n        internal\n        pure\n        returns (string memory)\n    {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    function uint2str(uint256 _i)\n        internal\n        pure\n        returns (string memory _uintAsString)\n    {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <[email protected]π.com>, Eenae <[email protected]>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor() internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n}\n\ncontract OwnableDelegateProxy {}\n\ncontract ProxyRegistry {\n    mapping(address => OwnableDelegateProxy) public proxies;\n}\n\n/**\n * @title ERC721Tradable\n * ERC721Tradable - ERC721 contract that whitelists a trading address, and has minting functionality.\n */\ncontract ERC721Tradable is ERC721Full, Ownable {\n    using Strings for string;\n\n    address proxyRegistryAddress;\n    uint256 private _currentTokenId = 0;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _proxyRegistryAddress\n    ) public ERC721Full(_name, _symbol) {\n        proxyRegistryAddress = _proxyRegistryAddress;\n    }\n\n    /**\n     * @dev Mints a token to an address with a tokenURI.\n     * @param _to address of the future owner of the token\n     */\n    function mintTo(address _to) internal {\n        uint256 newTokenId = _getNextTokenId();\n        _mint(_to, newTokenId);\n        _incrementTokenId();\n    }\n\n    /**\n     * @dev calculates the next token ID based on value of _currentTokenId\n     * @return uint256 for the next token ID\n     */\n    function _getNextTokenId() private view returns (uint256) {\n        return _currentTokenId.add(1);\n    }\n\n    /**\n     * @dev increments the value of _currentTokenId\n     */\n    function _incrementTokenId() private {\n        _currentTokenId++;\n    }\n\n    function baseTokenURI() public pure returns (string memory) {\n        return \"\";\n    }\n\n    function tokenURI(uint256 _tokenId) external view returns (string memory) {\n        return\n            Strings.strConcat(\n                baseTokenURI(),\n                Strings.uint2str(_tokenId),\n                \".json\"\n            );\n    }\n\n    /**\n     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        returns (bool)\n    {\n        // Whitelist OpenSea proxy contract for easy trading.\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n        if (address(proxyRegistry.proxies(owner)) == operator) {\n            return true;\n        }\n\n        return super.isApprovedForAll(owner, operator);\n    }\n}\n\n/*\nCopyright (c) 2021 Global Dev Pty Ltd\n\nBefore interacting with this contract, you must read our terms carefully as this contract is bound by these terms.\n\nThe terms can be found at https://digiscoop.art/terms\n\nBy interacting with this contract you indicate that you have read and accept these terms and agree to abide by and be bound by all such terms.\n\nIf you do not accept all applicable terms, please refrain from using this contract and any associated services as stipulated in our terms.\n*/\n\ncontract Digiscoop is ERC721Tradable, ReentrancyGuard {\n    uint256 public constant NFT_MAX = 682;\n    uint256 public constant NFT_COST = (99 ether) / 1000;\n    uint256 public constant AMOUNT_MAX = 10;\n\n    constructor(address _proxyRegistryAddress)\n        public\n        ERC721Tradable(\"DigiScoop\", \"DGSC\", _proxyRegistryAddress)\n    {}\n\n    function mint(uint256 _amount, uint256 _agree)\n        public\n        payable\n        nonReentrant()\n    {\n        require(_agree == 1, \"DGSC: You must agree to the terms\");\n        require(_amount <= AMOUNT_MAX, \"DGSC: Limit 10 at a time\");\n        require(msg.value == NFT_COST * _amount, \"DGSC: Incorrect value\");\n        require(totalSupply() + _amount <= NFT_MAX, \"DGSC: Not enough left\");\n        for (uint256 i = 0; i < _amount; i++) {\n            mintTo(msg.sender);\n        }\n    }\n\n    function withdraw() public onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function baseTokenURI() public pure returns (string memory) {\n        return \"https://digiscoop.art/api/v1/\";\n    }\n\n    function contractURI() public pure returns (string memory) {\n        return \"https://digiscoop.art/api/v1/contract.json\";\n    }\n\n    function metadataURI() public pure returns (string memory) {\n        return \"ipfs://QmfPpPosAQxKZiZTyu4rPDx2wNmCQPNSFKWne6bweo5ce5\";\n    }\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x61f9c4e6c5a52417588430123fdd4ba5dfe013fe",
    "source_code": "pragma solidity ^0.4.24;\n\n// ----------------------------------------------------------------------------\n// 'OREO.FINANCE' token contract\n//\n// Deployed to : 0xDc4d422EB57b5D4cebebABdD1AE57DC5e5D4A9EA\n// Symbol      : OREO\n// Name        : OREO.FINANCE\n// Total supply: 20000\n// Decimals    : 18\n//\n//\n//\n// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.\n// ----------------------------------------------------------------------------\n\n\n// ----------------------------------------------------------------------------\n// Safe maths\n// ----------------------------------------------------------------------------\ncontract SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n//\n// ----------------------------------------------------------------------------\ncontract ERC20Interface {\n    function totalSupply() public constant returns (uint);\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\n// ----------------------------------------------------------------------------\n// Contract function to receive approval and execute function in one call\n//\n// Borrowed from MiniMeToken\n// ----------------------------------------------------------------------------\ncontract ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n}\n\n\n// ----------------------------------------------------------------------------\n// Owned contract\n// ----------------------------------------------------------------------------\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\n// token transfers\n// ----------------------------------------------------------------------------\ncontract OREO is ERC20Interface, Owned, SafeMath {\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    constructor() public {\n        symbol = \"OREO\";\n        name = \"OREO.FINANCE\";\n        decimals = 18;\n        _totalSupply = 20000000000000000000000;\n        balances[0xDc4d422EB57b5D4cebebABdD1AE57DC5e5D4A9EA] = _totalSupply;\n        emit Transfer(address(0), 0xDc4d422EB57b5D4cebebABdD1AE57DC5e5D4A9EA, _totalSupply);\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Total supply\n    // ------------------------------------------------------------------------\n    function totalSupply() public constant returns (uint) {\n        return _totalSupply  - balances[address(0)];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Get the token balance for account tokenOwner\n    // ------------------------------------------------------------------------\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer the balance from token owner's account to to account\n    // - Owner's account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transfer(address to, uint tokens) public returns (bool success) {\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner's account\n    //\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n    // recommends that there are no checks for the approval double-spend attack\n    // as this should be implemented in user interfaces \n    // ------------------------------------------------------------------------\n    function approve(address spender, uint tokens) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer tokens from the from account to the to account\n    // \n    // The calling account must already have sufficient tokens approve(...)-d\n    // for spending from the from account and\n    // - From account must have sufficient balance to transfer\n    // - Spender must have sufficient allowance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        balances[from] = safeSub(balances[from], tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Returns the amount of tokens approved by the owner that can be\n    // transferred to the spender's account\n    // ------------------------------------------------------------------------\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner's account. The spender contract function\n    // receiveApproval(...) is then executed\n    // ------------------------------------------------------------------------\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Don't accept ETH\n    // ------------------------------------------------------------------------\n    function () public payable {\n        revert();\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    // ------------------------------------------------------------------------\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }\n}",
    "vulnerability_type": "denial_of_service"
  },
  {
    "address": "0x61f9ca9c9277a0e4ca98894563c5d8c68d136b3f",
    "source_code": "pragma solidity ^0.4.18;\n\n// ----------------------------------------------------------------------------\n// &#39;Green Earth Economy&#39; token contract\n//\n// Deployed to : 0x765BaeAECC41239aaFc8B522E102707cef59bAcC\n// Symbol      : GEE\n// Name        : Green Earth Economy Fund\n// Total supply: 21000000\n// Decimals    : 18\n//\n// Enjoy.\n//\n// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.\n// ----------------------------------------------------------------------------\n\n\n// ----------------------------------------------------------------------------\n// Safe maths\n// ----------------------------------------------------------------------------\ncontract SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n// ----------------------------------------------------------------------------\ncontract ERC20Interface {\n    function totalSupply() public constant returns (uint);\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\n// ----------------------------------------------------------------------------\n// Contract function to receive approval and execute function in one call\n//\n// Borrowed from MiniMeToken\n// ----------------------------------------------------------------------------\ncontract ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n}\n\n\n// ----------------------------------------------------------------------------\n// Owned contract\n// ----------------------------------------------------------------------------\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\n// token transfers\n// ----------------------------------------------------------------------------\ncontract GreenEarthEconomyFund is ERC20Interface, Owned, SafeMath {\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    function GreenEarthEconomyFund() public {\n        symbol = \"GEE\";\n        name = \"Green Earth Economy Fund\";\n        decimals = 18;\n        _totalSupply = 21000000000000000000000000;\n        balances[0x765BaeAECC41239aaFc8B522E102707cef59bAcC] = _totalSupply;\n        Transfer(address(0), 0x765BaeAECC41239aaFc8B522E102707cef59bAcC, _totalSupply);\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Total supply\n    // ------------------------------------------------------------------------\n    function totalSupply() public constant returns (uint) {\n        return _totalSupply  - balances[address(0)];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Get the token balance for account tokenOwner\n    // ------------------------------------------------------------------------\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer the balance from token owner&#39;s account to to account\n    // - Owner&#39;s account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transfer(address to, uint tokens) public returns (bool success) {\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner&#39;s account\n    //\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n    // recommends that there are no checks for the approval double-spend attack\n    // as this should be implemented in user interfaces \n    // ------------------------------------------------------------------------\n    function approve(address spender, uint tokens) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer tokens from the from account to the to account\n    // \n    // The calling account must already have sufficient tokens approve(...)-d\n    // for spending from the from account and\n    // - From account must have sufficient balance to transfer\n    // - Spender must have sufficient allowance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        balances[from] = safeSub(balances[from], tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        Transfer(from, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Returns the amount of tokens approved by the owner that can be\n    // transferred to the spender&#39;s account\n    // ------------------------------------------------------------------------\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner&#39;s account. The spender contract function\n    // receiveApproval(...) is then executed\n    // ------------------------------------------------------------------------\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Don&#39;t accept ETH\n    // ------------------------------------------------------------------------\n    function () public payable {\n        revert();\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    // ------------------------------------------------------------------------\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }\n}",
    "vulnerability_type": "denial_of_service"
  },
  {
    "address": "0x6496b66eC6E1a6d5dCBCa5C95E00707531E65b8F",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-04-30\n*/\n\n/*\n * This file was generated by MyWish Platform (https://mywish.io/)\n * The complete code could be found at https://github.com/MyWishPlatform/\n * Copyright (C) 2020 MyWish\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity ^0.4.23;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\ncontract MintableToken is StandardToken, Ownable {\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n\n  bool public mintingFinished = false;\n\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n  modifier hasMintPermission() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param _to The address that will receive the minted tokens.\n   * @param _amount The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(\n    address _to,\n    uint256 _amount\n  )\n    hasMintPermission\n    canMint\n    public\n    returns (bool)\n  {\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Mint(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n  function finishMinting() onlyOwner canMint public returns (bool) {\n    mintingFinished = true;\n    emit MintFinished();\n    return true;\n  }\n}\n\n\ncontract FreezableToken is StandardToken {\n    // freezing chains\n    mapping (bytes32 => uint64) internal chains;\n    // freezing amounts for each chain\n    mapping (bytes32 => uint) internal freezings;\n    // total freezing balance per address\n    mapping (address => uint) internal freezingBalance;\n\n    event Freezed(address indexed to, uint64 release, uint amount);\n    event Released(address indexed owner, uint amount);\n\n    /**\n     * @dev Gets the balance of the specified address include freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner) + freezingBalance[_owner];\n    }\n\n    /**\n     * @dev Gets the balance of the specified address without freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner);\n    }\n\n    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n        return freezingBalance[_owner];\n    }\n\n    /**\n     * @dev gets freezing count\n     * @param _addr Address of freeze tokens owner.\n     */\n    function freezingCount(address _addr) public view returns (uint count) {\n        uint64 release = chains[toKey(_addr, 0)];\n        while (release != 0) {\n            count++;\n            release = chains[toKey(_addr, release)];\n        }\n    }\n\n    /**\n     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.\n     * @param _addr Address of freeze tokens owner.\n     * @param _index Freezing portion index. It ordered by release date descending.\n     */\n    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n        for (uint i = 0; i < _index + 1; i++) {\n            _release = chains[toKey(_addr, _release)];\n            if (_release == 0) {\n                return;\n            }\n        }\n        _balance = freezings[toKey(_addr, _release)];\n    }\n\n    /**\n     * @dev freeze your tokens to the specified address.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to freeze.\n     * @param _until Release date, must be in future.\n     */\n    function freezeTo(address _to, uint _amount, uint64 _until) public {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Transfer(msg.sender, _to, _amount);\n        emit Freezed(_to, _until, _amount);\n    }\n\n    /**\n     * @dev release first available freezing tokens.\n     */\n    function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n\n        uint64 next = chains[currentKey];\n\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }\n\n    /**\n     * @dev release all available for release freezing tokens. Gas usage is not deterministic!\n     * @return how many tokens was released\n     */\n    function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }\n\n    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n        // WISH masc to increase entropy\n        result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n        assembly {\n            result := or(result, mul(_addr, 0x10000000000000000))\n            result := or(result, and(_release, 0xffffffffffffffff))\n        }\n    }\n\n    function freeze(address _to, uint64 _until) internal {\n        require(_until > block.timestamp);\n        bytes32 key = toKey(_to, _until);\n        bytes32 parentKey = toKey(_to, uint64(0));\n        uint64 next = chains[parentKey];\n\n        if (next == 0) {\n            chains[parentKey] = _until;\n            return;\n        }\n\n        bytes32 nextKey = toKey(_to, next);\n        uint parent;\n\n        while (next != 0 && _until > next) {\n            parent = next;\n            parentKey = nextKey;\n\n            next = chains[nextKey];\n            nextKey = toKey(_to, next);\n        }\n\n        if (_until == next) {\n            return;\n        }\n\n        if (next != 0) {\n            chains[key] = next;\n        }\n\n        chains[parentKey] = _until;\n    }\n}\n\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract BurnableToken is BasicToken {\n\n  event Burn(address indexed burner, uint256 value);\n\n  /**\n   * @dev Burns a specific amount of tokens.\n   * @param _value The amount of token to be burned.\n   */\n  function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }\n\n  function _burn(address _who, uint256 _value) internal {\n    require(_value <= balances[_who]);\n    // no need to require value <= totalSupply, since that would imply the\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n    balances[_who] = balances[_who].sub(_value);\n    totalSupply_ = totalSupply_.sub(_value);\n    emit Burn(_who, _value);\n    emit Transfer(_who, address(0), _value);\n  }\n}\n\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n    /**\n     * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to mint and freeze.\n     * @param _until Release date, must be in future.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {\n        totalSupply_ = totalSupply_.add(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Mint(_to, _amount);\n        emit Freezed(_to, _until, _amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n}\n\n\n\ncontract Consts {\n    uint public constant TOKEN_DECIMALS = 4;\n    uint8 public constant TOKEN_DECIMALS_UINT8 = 4;\n    uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n\n    string public constant TOKEN_NAME = \"OHANA\";\n    string public constant TOKEN_SYMBOL = \"OHANA\";\n    bool public constant PAUSED = false;\n    address public constant TARGET_USER = 0xba6d8b5375d6b3097dd7A52bA3727A5A25693739;\n    \n    bool public constant CONTINUE_MINTING = true;\n}\n\n\n\n\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n    \n{\n    \n    event Initialized();\n    bool public initialized = false;\n\n    constructor() public {\n        init();\n        transferOwnership(TARGET_USER);\n    }\n    \n\n    function name() public pure returns (string _name) {\n        return TOKEN_NAME;\n    }\n\n    function symbol() public pure returns (string _symbol) {\n        return TOKEN_SYMBOL;\n    }\n\n    function decimals() public pure returns (uint8 _decimals) {\n        return TOKEN_DECIMALS_UINT8;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transfer(_to, _value);\n    }\n\n    \n    function init() private {\n        require(!initialized);\n        initialized = true;\n\n        if (PAUSED) {\n            pause();\n        }\n\n        \n        address[1] memory addresses = [address(0xba6d8b5375d6b3097dd7a52ba3727a5a25693739)];\n        uint[1] memory amounts = [uint(10000000000000)];\n        uint64[1] memory freezes = [uint64(0)];\n\n        for (uint i = 0; i < addresses.length; i++) {\n            if (freezes[i] == 0) {\n                mint(addresses[i], amounts[i]);\n            } else {\n                mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n            }\n        }\n        \n\n        if (!CONTINUE_MINTING) {\n            finishMinting();\n        }\n\n        emit Initialized();\n    }\n    \n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x64a522710Aa325759D43bDa3cfb337660F1a5ceD",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2022-02-27\n*/\n\n/**\n *Submitted for verification at Etherscan.io on 2022-02-02\n*/\n\n// SPDX-License-Identifier: MIT\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Strings.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Context.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\n\n\n\n\n\n\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n// File: contracts/MetaTeddies.sol\n\npragma solidity >=0.7.0 <0.9.0;\n\n\ncontract MetaTeddys is ERC721, Ownable {\n  using Strings for uint256;\n  using Counters for Counters.Counter;\n\n  Counters.Counter private supply;\n\n  string public uriPrefix = \"\";\n  string public uriSuffix = \".json\";\n  string public hiddenMetadataUri;\n  \n  uint256 public cost = 0.19 ether;\n  uint256 public maxSupply = 300;\n  uint256 public maxMintAmountPerTx = 3;\n\n  bool public paused = true;\n  bool public revealed = false;\n\n  constructor() ERC721(\"MetaTeddys\", \"MTD\") {\n    setHiddenMetadataUri(\"https://minipancake.xyz/metateddies/hiddenjson/hidden.json\");\n  }\n\n  modifier mintCompliance(uint256 _mintAmount) {\n    require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTx, \"Invalid mint amount!\");\n    require(supply.current() + _mintAmount <= maxSupply, \"Max supply exceeded!\");\n    _;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return supply.current();\n  }\n\n  function mint(uint256 _mintAmount) public payable mintCompliance(_mintAmount) {\n    require(!paused, \"The contract is paused!\");\n    require(msg.value >= cost * _mintAmount, \"Insufficient funds!\");\n\n    _mintLoop(msg.sender, _mintAmount);\n  }\n  \n  function mintForAddress(uint256 _mintAmount, address _receiver) public mintCompliance(_mintAmount) onlyOwner {\n    _mintLoop(_receiver, _mintAmount);\n  }\n\n  function walletOfOwner(address _owner)\n    public\n    view\n    returns (uint256[] memory)\n  {\n    uint256 ownerTokenCount = balanceOf(_owner);\n    uint256[] memory ownedTokenIds = new uint256[](ownerTokenCount);\n    uint256 currentTokenId = 1;\n    uint256 ownedTokenIndex = 0;\n\n    while (ownedTokenIndex < ownerTokenCount && currentTokenId <= maxSupply) {\n      address currentTokenOwner = ownerOf(currentTokenId);\n\n      if (currentTokenOwner == _owner) {\n        ownedTokenIds[ownedTokenIndex] = currentTokenId;\n\n        ownedTokenIndex++;\n      }\n\n      currentTokenId++;\n    }\n\n    return ownedTokenIds;\n  }\n\n  function tokenURI(uint256 _tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n  {\n    require(\n      _exists(_tokenId),\n      \"ERC721Metadata: URI query for nonexistent token\"\n    );\n\n    if (revealed == false) {\n      return hiddenMetadataUri;\n    }\n\n    string memory currentBaseURI = _baseURI();\n    return bytes(currentBaseURI).length > 0\n        ? string(abi.encodePacked(currentBaseURI, _tokenId.toString(), uriSuffix))\n        : \"\";\n  }\n\n\n  function setRevealed(bool _state) public onlyOwner {\n    revealed = _state;\n  }\n\n  function setCost(uint256 _cost) public onlyOwner {\n    cost = _cost;\n  }\n\n  function setMaxMintAmountPerTx(uint256 _maxMintAmountPerTx) public onlyOwner {\n    maxMintAmountPerTx = _maxMintAmountPerTx;\n  }\n\n  function setHiddenMetadataUri(string memory _hiddenMetadataUri) public onlyOwner {\n    hiddenMetadataUri = _hiddenMetadataUri;\n  }\n\n   function setmaxSupply(uint256 _maxSupply) public onlyOwner {\n    maxSupply = _maxSupply;\n  }\n\n\n  function setUriPrefix(string memory _uriPrefix) public onlyOwner {\n    uriPrefix = _uriPrefix;\n  }\n\n  function setUriSuffix(string memory _uriSuffix) public onlyOwner {\n    uriSuffix = _uriSuffix;\n  }\n\n  function setPaused(bool _state) public onlyOwner {\n    paused = _state;\n  }\n\n  function withdraw() public onlyOwner {\n    // This will pay Sascha 10% of the initial sale.\n    // =============================================================================\n    (bool hs, ) = payable(0x7a8633a6d00BC857E684fD6f15687f9a0fc24585).call{value: address(this).balance * 5 / 100}(\"\");\n    require(hs);\n    // =============================================================================\n\n    // This will transfer the remaining contract balance to the owner.\n    // =============================================================================\n    (bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");\n    require(os);\n    // =============================================================================\n  }\n\n  function _mintLoop(address _receiver, uint256 _mintAmount) internal {\n    for (uint256 i = 0; i < _mintAmount; i++) {\n      supply.increment();\n      _safeMint(_receiver, supply.current());\n    }\n  }\n\n  function _baseURI() internal view virtual override returns (string memory) {\n    return uriPrefix;\n  }\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x64a88b7d161ced8385ab6e9feca0f68725871094",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-05-05\n*/\n\n/*\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity ^0.4.23;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\ncontract MintableToken is StandardToken, Ownable {\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n\n  bool public mintingFinished = false;\n\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n  modifier hasMintPermission() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param _to The address that will receive the minted tokens.\n   * @param _amount The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(\n    address _to,\n    uint256 _amount\n  )\n    hasMintPermission\n    canMint\n    public\n    returns (bool)\n  {\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Mint(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n  function finishMinting() onlyOwner canMint public returns (bool) {\n    mintingFinished = true;\n    emit MintFinished();\n    return true;\n  }\n}\n\n\ncontract FreezableToken is StandardToken {\n    // freezing chains\n    mapping (bytes32 => uint64) internal chains;\n    // freezing amounts for each chain\n    mapping (bytes32 => uint) internal freezings;\n    // total freezing balance per address\n    mapping (address => uint) internal freezingBalance;\n\n    event Freezed(address indexed to, uint64 release, uint amount);\n    event Released(address indexed owner, uint amount);\n\n    /**\n     * @dev Gets the balance of the specified address include freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner) + freezingBalance[_owner];\n    }\n\n    /**\n     * @dev Gets the balance of the specified address without freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner);\n    }\n\n    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n        return freezingBalance[_owner];\n    }\n\n    /**\n     * @dev gets freezing count\n     * @param _addr Address of freeze tokens owner.\n     */\n    function freezingCount(address _addr) public view returns (uint count) {\n        uint64 release = chains[toKey(_addr, 0)];\n        while (release != 0) {\n            count++;\n            release = chains[toKey(_addr, release)];\n        }\n    }\n\n    /**\n     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.\n     * @param _addr Address of freeze tokens owner.\n     * @param _index Freezing portion index. It ordered by release date descending.\n     */\n    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n        for (uint i = 0; i < _index + 1; i++) {\n            _release = chains[toKey(_addr, _release)];\n            if (_release == 0) {\n                return;\n            }\n        }\n        _balance = freezings[toKey(_addr, _release)];\n    }\n\n    /**\n     * @dev freeze your tokens to the specified address.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to freeze.\n     * @param _until Release date, must be in future.\n     */\n    function freezeTo(address _to, uint _amount, uint64 _until) public {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Transfer(msg.sender, _to, _amount);\n        emit Freezed(_to, _until, _amount);\n    }\n\n    /**\n     * @dev release first available freezing tokens.\n     */\n    function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n\n        uint64 next = chains[currentKey];\n\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }\n\n    /**\n     * @dev release all available for release freezing tokens. Gas usage is not deterministic!\n     * @return how many tokens was released\n     */\n    function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }\n\n    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n        // WISH masc to increase entropy\n        result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n        assembly {\n            result := or(result, mul(_addr, 0x10000000000000000))\n            result := or(result, and(_release, 0xffffffffffffffff))\n        }\n    }\n\n    function freeze(address _to, uint64 _until) internal {\n        require(_until > block.timestamp);\n        bytes32 key = toKey(_to, _until);\n        bytes32 parentKey = toKey(_to, uint64(0));\n        uint64 next = chains[parentKey];\n\n        if (next == 0) {\n            chains[parentKey] = _until;\n            return;\n        }\n\n        bytes32 nextKey = toKey(_to, next);\n        uint parent;\n\n        while (next != 0 && _until > next) {\n            parent = next;\n            parentKey = nextKey;\n\n            next = chains[nextKey];\n            nextKey = toKey(_to, next);\n        }\n\n        if (_until == next) {\n            return;\n        }\n\n        if (next != 0) {\n            chains[key] = next;\n        }\n\n        chains[parentKey] = _until;\n    }\n}\n\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract BurnableToken is BasicToken {\n\n  event Burn(address indexed burner, uint256 value);\n\n  /**\n   * @dev Burns a specific amount of tokens.\n   * @param _value The amount of token to be burned.\n   */\n  function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }\n\n  function _burn(address _who, uint256 _value) internal {\n    require(_value <= balances[_who]);\n    // no need to require value <= totalSupply, since that would imply the\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n    balances[_who] = balances[_who].sub(_value);\n    totalSupply_ = totalSupply_.sub(_value);\n    emit Burn(_who, _value);\n    emit Transfer(_who, address(0), _value);\n  }\n}\n\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n    /**\n     * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to mint and freeze.\n     * @param _until Release date, must be in future.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {\n        totalSupply_ = totalSupply_.add(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Mint(_to, _amount);\n        emit Freezed(_to, _until, _amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n}\n\n\n\ncontract Consts {\n    uint public constant TOKEN_DECIMALS = 18;\n    uint8 public constant TOKEN_DECIMALS_UINT8 = 18;\n    uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n\n    string public constant TOKEN_NAME = \"Querdenker\";\n    string public constant TOKEN_SYMBOL = \"QDR\";\n    bool public constant PAUSED = false;\n    address public constant TARGET_USER = 0x7d7E74B1C00589CEF059a8242C0b6449Dd67F1CC;\n    \n    bool public constant CONTINUE_MINTING = false;\n}\n\n\n\n\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n    \n{\n    \n    event Initialized();\n    bool public initialized = false;\n\n    constructor() public {\n        init();\n        transferOwnership(TARGET_USER);\n    }\n    \n\n    function name() public pure returns (string _name) {\n        return TOKEN_NAME;\n    }\n\n    function symbol() public pure returns (string _symbol) {\n        return TOKEN_SYMBOL;\n    }\n\n    function decimals() public pure returns (uint8 _decimals) {\n        return TOKEN_DECIMALS_UINT8;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transfer(_to, _value);\n    }\n\n    \n    function init() private {\n        require(!initialized);\n        initialized = true;\n\n        if (PAUSED) {\n            pause();\n        }\n\n        \n        address[1] memory addresses = [address(0x7d7e74b1c00589cef059a8242c0b6449dd67f1cc)];\n        uint[1] memory amounts = [uint(10000000000000000000000000)];\n        uint64[1] memory freezes = [uint64(0)];\n\n        for (uint i = 0; i < addresses.length; i++) {\n            if (freezes[i] == 0) {\n                mint(addresses[i], amounts[i]);\n            } else {\n                mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n            }\n        }\n        \n\n        if (!CONTINUE_MINTING) {\n            finishMinting();\n        }\n\n        emit Initialized();\n    }\n    \n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x64abd25c4fa5a18abf9f2992352d9f73341aabd8",
    "source_code": "pragma solidity ^0.4.16;\n\n// ----------------------------------------------------------------------------------------------   \n// CD Currency Token Contract, version 1.00   \n// UNIVERSAL COIN INTERNATIONAL INC   \n// OMC Chambers, Wickhams Cay 1, Road Town, Tortola, British Virgin Islands   \n// IT: @WachoTouriz\n// ---------------------------------------------------------------------------------------------- \n\ncontract owned {\n    address public owner;\n\n    function owned() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner public {\n        owner = newOwner;\n    }\n}\n\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` in behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender&#39;s allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}\n\n/******************************************/\n/*       ADVANCED TOKEN STARTS HERE       */\n/******************************************/\n\ncontract CDcurrency is owned, TokenERC20 {\n\n    uint256 public sellPrice;\n    uint256 public buyPrice;\n\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function CDcurrency(\n    ) TokenERC20(5000000000, \"Universal Currency Digital\", \"UCD\") public {}\n\n    /* Internal transfer, only can be called by this contract */\n    function _transfer(address _from, address _to, uint _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] >= _value);               // Check if the sender has enough\n        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n        Transfer(_from, _to, _value);\n    }\n\n    /// @notice Create `mintedAmount` tokens and send it to `target`\n    /// @param target Address to receive the tokens\n    /// @param mintedAmount the amount of tokens it will receive\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, this, mintedAmount);\n        Transfer(this, target, mintedAmount);\n    }\n\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n    /// @param target Address to be frozen\n    /// @param freeze either to freeze it or not\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\n    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\n    /// @param newSellPrice Price the users can sell to the contract\n    /// @param newBuyPrice Price users can buy from the contract\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {\n        sellPrice = newSellPrice;\n        buyPrice = newBuyPrice;\n    }\n\n    /// @notice Buy tokens from contract by sending ether\n    function buy() payable public {\n        uint amount = msg.value / buyPrice;               // calculates the amount\n        _transfer(this, msg.sender, amount);              // makes the transfers\n    }\n\n    /// @notice Sell `amount` tokens to contract\n    /// @param amount amount of tokens to be sold\n    function sell(uint256 amount) public {\n        require(this.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy\n        _transfer(msg.sender, this, amount);              // makes the transfers\n        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It&#39;s important to do this last to avoid recursion attacks\n    }\n}",
    "vulnerability_type": "other"
  },
  {
    "address": "0x64BeF177B4F157b1563476F3Fe53E2c7C6cBE218",
    "source_code": "// SPDX-License-Identifier: MIT\n\n\n// File contracts/utils/introspection/IERC165.sol\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\n// File contracts/token/ERC721/IERC721.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\n\n// File contracts/token/ERC721/IERC721Receiver.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\n\n// File contracts/token/ERC721/extensions/IERC721Metadata.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\n// File contracts/utils/Address.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n// File contracts/utils/Context.sol\n\n\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\n// File contracts/utils/Strings.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n\n\n// File contracts/utils/introspection/ERC165.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\n// File contracts/token/ERC721/ERC721.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n\n\n\n\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping (uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping (address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n            : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n     * in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n\n\n// File contracts/token/ERC721/extensions/ERC721URIStorage.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n\n// File contracts/access/Ownable.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\n\npragma solidity ^0.8.0;\n\n\n\ncontract GoofyDonkeys is ERC721URIStorage, Ownable{\n\n    event mintDonkeys (address indexed minter, uint256 startWith, uint256 times);\n\n\n    uint256 public totaldonkeys;\n    uint256 public totalCount = 2500; //bruhTotal\n    uint256 public maxBatch = 20; // bruhBatch\n    uint256 public price = 0.05 ether;\n    string public baseURI;\n    bool public started;\n    uint addressRegistryCount;\n\n    constructor() ERC721(\"GoofyDonkeys\", \"GD\") {\n        \n    }\n\n    modifier mintEnabled() {\n        require(started, \"not started\");\n        _;\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return totaldonkeys;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory){\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _newURI) public onlyOwner {\n        baseURI = _newURI;\n    }\n\n    function changePrice(uint256 _newPrice) public onlyOwner {\n        price = _newPrice;\n    }\n\n    function setTokenURI(uint256 _tokenId, string memory _tokenURI) public onlyOwner {\n        _setTokenURI(_tokenId, _tokenURI);\n    }\n\n    function setNormalStart(bool _start) public onlyOwner {\n        started = _start;\n    }\n\n    function mintDonkey(uint256 _times) payable public mintEnabled {\n        require(_times >0 && _times <= maxBatch, \"mint wrong number\");\n        require(totaldonkeys + _times <= totalCount, \"too much\");\n        require(msg.value == _times * price, \"value error\");\n        payable(owner()).transfer(msg.value);\n        emit mintDonkeys(_msgSender(), totaldonkeys+1, _times);\n        for(uint256 i=0; i< _times; i++){\n            _mint(_msgSender(), 1 + totaldonkeys++);\n        }\n    }\n\n    function adminMint(uint256 _times) payable public onlyOwner {\n        require(_times >0 && _times <= maxBatch, \"mint wrong number\");\n        require(totaldonkeys + _times <= totalCount, \"too much\");\n        require(msg.value == _times * price, \"value error\");\n        payable(owner()).transfer(msg.value);\n        emit mintDonkeys(_msgSender(), totaldonkeys+1, _times);\n        for(uint256 i=0; i< _times; i++){\n            _mint(_msgSender(), 1 + totaldonkeys++);\n        }\n    }\n\n\n\n    function adminMintGiveaways(address _addr) public onlyOwner {\n        require(totaldonkeys + 1 <= totalCount, \"Mint amount will exceed total collection amount.\");\n        emit mintDonkeys(_addr, totaldonkeys+1, 1);\n        _mint(_addr, 1 + totaldonkeys++);\n    }\n\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x64c8dd01056ab8c1c8e1b704eca60d9aa34cfb54",
    "source_code": "pragma solidity ^0.4.24;\n\ncontract ABEToken {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n\n    constructor() public {\n        totalSupply = 50000000 * 10 ** uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n        name = \"ABE TOKEN\";\n        symbol = \"ABE\";\n    }\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != 0x0);\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     \n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   \n        balanceOf[msg.sender] -= _value;            \n        totalSupply -= _value;                      \n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                \n        require(_value <= allowance[_from][msg.sender]);    \n        balanceOf[_from] -= _value;                         \n        allowance[_from][msg.sender] -= _value;             \n        totalSupply -= _value;                              \n        emit Burn(_from, _value);\n        return true;\n    }\n}",
    "vulnerability_type": "other"
  },
  {
    "address": "0x64d96848D8DE44d4d5850bD79feCCB086C48Eb83",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2022-01-16\n*/\n\n// SPDX-License-Identifier: MIT\n\n/***\n\n          $$\\           $$\\             $$\\ $$\\           $$\\                 \n          \\__|          $$ |            $$ |\\__|          $$ |                \n $$$$$$$\\ $$\\  $$$$$$$\\ $$ |  $$\\  $$$$$$$ |$$\\  $$$$$$$\\ $$ |  $$\\  $$$$$$$\\ \n$$  _____|$$ |$$  _____|$$ | $$  |$$  __$$ |$$ |$$  _____|$$ | $$  |$$  _____|\n\\$$$$$$\\  $$ |$$ /      $$$$$$  / $$ /  $$ |$$ |$$ /      $$$$$$  / \\$$$$$$\\  \n \\____$$\\ $$ |$$ |      $$  _$$<  $$ |  $$ |$$ |$$ |      $$  _$$<   \\____$$\\ \n$$$$$$$  |$$ |\\$$$$$$$\\ $$ | \\$$\\ \\$$$$$$$ |$$ |\\$$$$$$$\\ $$ | \\$$\\ $$$$$$$  |\n\\_______/ \\__| \\_______|\\__|  \\__| \\_______|\\__| \\_______|\\__|  \\__|\\_______/ \n                                                                              \n                                                                                                                           \n\n/**\n\n\n// File: @openzeppelin/contracts/utils/Counters.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Strings.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Context.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\n\n\n\n\n\n\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n// File: contracts/sickdicks.sol\n\n\n\n// Amended by HashLips\n/**\n    \n\n          $$\\           $$\\             $$\\ $$\\           $$\\                 \n          \\__|          $$ |            $$ |\\__|          $$ |                \n $$$$$$$\\ $$\\  $$$$$$$\\ $$ |  $$\\  $$$$$$$ |$$\\  $$$$$$$\\ $$ |  $$\\  $$$$$$$\\ \n$$  _____|$$ |$$  _____|$$ | $$  |$$  __$$ |$$ |$$  _____|$$ | $$  |$$  _____|\n\\$$$$$$\\  $$ |$$ /      $$$$$$  / $$ /  $$ |$$ |$$ /      $$$$$$  / \\$$$$$$\\  \n \\____$$\\ $$ |$$ |      $$  _$$<  $$ |  $$ |$$ |$$ |      $$  _$$<   \\____$$\\ \n$$$$$$$  |$$ |\\$$$$$$$\\ $$ | \\$$\\ \\$$$$$$$ |$$ |\\$$$$$$$\\ $$ | \\$$\\ $$$$$$$  |\n\\_______/ \\__| \\_______|\\__|  \\__| \\_______|\\__| \\_______|\\__|  \\__|\\_______/ \n\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\n\n\n\ncontract sickdicks is ERC721, Ownable {\n  using Strings for uint256;\n  using Counters for Counters.Counter;\n\n  Counters.Counter private supply;\n\n  string public uriPrefix = \"\";\n  string public uriSuffix = \".json\";\n  string public hiddenMetadataUri;\n  \n  uint256 public cost = 0.01 ether;\n  uint256 public maxSupply = 1927;\n  uint256 public maxMintAmountPerTx = 15;\n\n  bool public paused = true;\n  bool public revealed = false;\n\n  constructor() ERC721(\"sickdicks\", \"SD\") {\n    setHiddenMetadataUri(\"ipfs://QmTvnWoE37J8sZVHH3WvofsbuHXgkHFAxU8Lw2v8ebdivU/hidden.json\");\n  }\n\n  modifier mintCompliance(uint256 _mintAmount) {\n    require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTx, \"Invalid mint amount!\");\n    require(supply.current() + _mintAmount <= maxSupply, \"Max supply exceeded!\");\n    _;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return supply.current();\n  }\n\n  function mint(uint256 _mintAmount) public payable mintCompliance(_mintAmount) {\n    require(!paused, \"The contract is paused!\");\n    require(msg.value >= cost * _mintAmount, \"Insufficient funds!\");\n\n    _mintLoop(msg.sender, _mintAmount);\n  }\n  \n  function mintForAddress(uint256 _mintAmount, address _receiver) public mintCompliance(_mintAmount) onlyOwner {\n    _mintLoop(_receiver, _mintAmount);\n  }\n\n  function walletOfOwner(address _owner)\n    public\n    view\n    returns (uint256[] memory)\n  {\n    uint256 ownerTokenCount = balanceOf(_owner);\n    uint256[] memory ownedTokenIds = new uint256[](ownerTokenCount);\n    uint256 currentTokenId = 1;\n    uint256 ownedTokenIndex = 0;\n\n    while (ownedTokenIndex < ownerTokenCount && currentTokenId <= maxSupply) {\n      address currentTokenOwner = ownerOf(currentTokenId);\n\n      if (currentTokenOwner == _owner) {\n        ownedTokenIds[ownedTokenIndex] = currentTokenId;\n\n        ownedTokenIndex++;\n      }\n\n      currentTokenId++;\n    }\n\n    return ownedTokenIds;\n  }\n\n  function tokenURI(uint256 _tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n  {\n    require(\n      _exists(_tokenId),\n      \"ERC721Metadata: URI query for nonexistent token\"\n    );\n\n    if (revealed == false) {\n      return hiddenMetadataUri;\n    }\n\n    string memory currentBaseURI = _baseURI();\n    return bytes(currentBaseURI).length > 0\n        ? string(abi.encodePacked(currentBaseURI, _tokenId.toString(), uriSuffix))\n        : \"\";\n  }\n\n  function setRevealed(bool _state) public onlyOwner {\n    revealed = _state;\n  }\n\n  function setCost(uint256 _cost) public onlyOwner {\n    cost = _cost;\n  }\n\n  function setMaxMintAmountPerTx(uint256 _maxMintAmountPerTx) public onlyOwner {\n    maxMintAmountPerTx = _maxMintAmountPerTx;\n  }\n\n  function setHiddenMetadataUri(string memory _hiddenMetadataUri) public onlyOwner {\n    hiddenMetadataUri = _hiddenMetadataUri;\n  }\n\n  function setUriPrefix(string memory _uriPrefix) public onlyOwner {\n    uriPrefix = _uriPrefix;\n  }\n\n  function setUriSuffix(string memory _uriSuffix) public onlyOwner {\n    uriSuffix = _uriSuffix;\n  }\n\n  function setPaused(bool _state) public onlyOwner {\n    paused = _state;\n  }\n\n  function withdraw() public onlyOwner {\n    // This will pay HashLips 5% of the initial sale.\n    // You can remove this if you want, or keep it in to support HashLips and his channel.\n    // =============================================================================\n    (bool hs, ) = payable(0x943590A42C27D08e3744202c4Ae5eD55c2dE240D).call{value: address(this).balance * 5 / 100}(\"\");\n    require(hs);\n    // =============================================================================\n\n    // This will transfer the remaining contract balance to the owner.\n    // Do not remove this otherwise you will not be able to withdraw the funds.\n    // =============================================================================\n    (bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");\n    require(os);\n    // =============================================================================\n  }\n\n  function _mintLoop(address _receiver, uint256 _mintAmount) internal {\n    for (uint256 i = 0; i < _mintAmount; i++) {\n      supply.increment();\n      _safeMint(_receiver, supply.current());\n    }\n  }\n\n  function _baseURI() internal view virtual override returns (string memory) {\n    return uriPrefix;\n  }\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x64dd2974a6a042fbad1665f005da970af3be7203",
    "source_code": "/*\n\n  Copyright 2018 WXBET Foundation LTD\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\npragma solidity ^0.4.21;\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n    return a / b;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\ncontract WXBET is StandardToken {\n\n    uint public totalSupply = 1975*10**24;\n    uint8  public decimals = 18;\n    string public name = \"WXBET\";\n    string public symbol = \"WXB\";\n\n    function WXBET () {\n        balances[msg.sender] = totalSupply;\n        Transfer(address(0), msg.sender, totalSupply);\n    }\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x64de91f5a373cd4c28de3600cb34c7c6ce410c85",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2019-11-13\n*/\n\n// median.sol - Medianizer v2\n\n// Copyright (C) 2019 Maker Foundation\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.10;\n\ncontract LibNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  usr,\n        bytes32  indexed  arg1,\n        bytes32  indexed  arg2,\n        bytes             data\n    ) anonymous;\n\n    modifier note {\n        _;\n        assembly {\n            // log an 'anonymous' event with a constant 6 words of calldata\n            // and four indexed topics: selector, caller, arg1 and arg2\n            let mark := msize                         // end of memory ensures zero\n            mstore(0x40, add(mark, 288))              // update free memory pointer\n            mstore(mark, 0x20)                        // bytes type data offset\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\n            log4(mark, 288,                           // calldata\n                 shl(224, shr(224, calldataload(0))), // msg.sig\n                 caller,                              // msg.sender\n                 calldataload(4),                     // arg1\n                 calldataload(36)                     // arg2\n                )\n        }\n    }\n}\n\ncontract Median is LibNote {\n\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { wards[usr] = 1; }\n    function deny(address usr) external note auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Median/not-authorized\");\n        _;\n    }\n\n    uint128        val;\n    uint32  public age;\n    bytes32 public constant wat = \"ethusd\"; // You want to change this every deploy\n    uint256 public bar = 1;\n\n    // Authorized oracles, set by an auth\n    mapping (address => uint256) public orcl;\n\n    // Whitelisted contracts, set by an auth\n    mapping (address => uint256) public bud;\n\n    // Mapping for at most 256 oracles\n    mapping (uint8 => address) public slot;\n\n    modifier toll { require(bud[msg.sender] == 1, \"Median/contract-not-whitelisted\"); _;}\n\n    event LogMedianPrice(uint256 val, uint256 age);\n\n    //Set type of Oracle\n    constructor() public {\n        wards[msg.sender] = 1;\n    }\n\n    function read() external view toll returns (uint256) {\n        require(val > 0, \"Median/invalid-price-feed\");\n        return val;\n    }\n\n    function peek() external view toll returns (uint256,bool) {\n        return (val, val > 0);\n    }\n\n    function recover(uint256 val_, uint256 age_, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        return ecrecover(\n            keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(abi.encodePacked(val_, age_, wat)))),\n            v, r, s\n        );\n    }\n\n    function poke(\n        uint256[] calldata val_, uint256[] calldata age_,\n        uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external\n    {\n        require(val_.length == bar, \"Median/bar-too-low\");\n\n        uint256 bloom = 0;\n        uint256 last = 0;\n        uint256 zzz = age;\n\n        for (uint i = 0; i < val_.length; i++) {\n            // Validate the values were signed by an authorized oracle\n            address signer = recover(val_[i], age_[i], v[i], r[i], s[i]);\n            // Check that signer is an oracle\n            require(orcl[signer] == 1, \"Median/invalid-oracle\");\n            // Price feed age greater than last medianizer age\n            require(age_[i] > zzz, \"Median/stale-message\");\n            // Check for ordered values\n            require(val_[i] >= last, \"Median/messages-not-in-order\");\n            last = val_[i];\n            // Bloom filter for signer uniqueness\n            uint8 sl = uint8(uint256(signer) >> 152);\n            require((bloom >> sl) % 2 == 0, \"Median/oracle-already-signed\");\n            bloom += uint256(2) ** sl;\n        }\n\n        val = uint128(val_[val_.length >> 1]);\n        age = uint32(block.timestamp);\n\n        emit LogMedianPrice(val, age);\n    }\n\n    function lift(address[] calldata a) external note auth {\n        for (uint i = 0; i < a.length; i++) {\n            require(a[i] != address(0), \"Median/no-oracle-0\");\n            uint8 s = uint8(uint256(a[i]) >> 152);\n            require(slot[s] == address(0), \"Median/signer-already-exists\");\n            orcl[a[i]] = 1;\n            slot[s] = a[i];\n        }\n    }\n\n    function drop(address[] calldata a) external note auth {\n       for (uint i = 0; i < a.length; i++) {\n            orcl[a[i]] = 0;\n            slot[uint8(uint256(a[i]) >> 152)] = address(0);\n       }\n    }\n\n    function setBar(uint256 bar_) external note auth {\n        require(bar_ > 0, \"Median/quorum-is-zero\");\n        require(bar_ % 2 != 0, \"Median/quorum-not-odd-number\");\n        bar = bar_;\n    }\n\n    function kiss(address a) external note auth {\n        require(a != address(0), \"Median/no-contract-0\");\n        bud[a] = 1;\n    }\n\n    function diss(address a) external note auth {\n        bud[a] = 0;\n    }\n\n    function kiss(address[] calldata a) external note auth {\n        for(uint i = 0; i < a.length; i++) {\n            require(a[i] != address(0), \"Median/no-contract-0\");\n            bud[a[i]] = 1;\n        }\n    }\n\n    function diss(address[] calldata a) external note auth {\n        for(uint i = 0; i < a.length; i++) {\n            bud[a[i]] = 0;\n        }\n    }\n}\n\ncontract MedianETHUSD is Median {\n    bytes32 public constant wat = \"ETHUSD\";\n\n    function recover(uint256 val_, uint256 age_, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        return ecrecover(\n            keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(abi.encodePacked(val_, age_, wat)))),\n            v, r, s\n        );\n    }\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x64deF90eacd6437262c76e0A103ED00AB0ea72A9",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-11-11\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(\n                vs,\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n            )\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n            );\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n            );\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(\n            value <= type(uint224).max,\n            \"SafeCast: value doesn't fit in 224 bits\"\n        );\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(\n            value <= type(uint128).max,\n            \"SafeCast: value doesn't fit in 128 bits\"\n        );\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(\n            value <= type(uint96).max,\n            \"SafeCast: value doesn't fit in 96 bits\"\n        );\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(\n            value <= type(uint64).max,\n            \"SafeCast: value doesn't fit in 64 bits\"\n        );\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(\n            value <= type(uint32).max,\n            \"SafeCast: value doesn't fit in 32 bits\"\n        );\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(\n            value <= type(uint16).max,\n            \"SafeCast: value doesn't fit in 16 bits\"\n        );\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(\n            value <= type(uint8).max,\n            \"SafeCast: value doesn't fit in 8 bits\"\n        );\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(\n            value >= type(int128).min && value <= type(int128).max,\n            \"SafeCast: value doesn't fit in 128 bits\"\n        );\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(\n            value >= type(int64).min && value <= type(int64).max,\n            \"SafeCast: value doesn't fit in 64 bits\"\n        );\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(\n            value >= type(int32).min && value <= type(int32).max,\n            \"SafeCast: value doesn't fit in 32 bits\"\n        );\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(\n            value >= type(int16).min && value <= type(int16).max,\n            \"SafeCast: value doesn't fit in 16 bits\"\n        );\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(\n            value >= type(int8).min && value <= type(int8).max,\n            \"SafeCast: value doesn't fit in 8 bits\"\n        );\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(\n            value <= uint256(type(int256).max),\n            \"SafeCast: value doesn't fit in an int256\"\n        );\n        return int256(value);\n    }\n}\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            owner != address(0),\n            \"ERC721: balance query for the zero address\"\n        );\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        address owner = _owners[tokenId];\n        require(\n            owner != address(0),\n            \"ERC721: owner query for nonexistent token\"\n        );\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        string memory baseURI = _baseURI();\n        return\n            bytes(baseURI).length > 0\n                ? string(abi.encodePacked(baseURI, tokenId.toString()))\n                : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: approved query for nonexistent token\"\n        );\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: operator query for nonexistent token\"\n        );\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(\n            ERC721.ownerOf(tokenId) == from,\n            \"ERC721: transfer of token that is not own\"\n        );\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    _msgSender(),\n                    from,\n                    tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"ERC721: transfer to non ERC721Receiver implementer\"\n                    );\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IERC165, ERC721)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            index < ERC721.balanceOf(owner),\n            \"ERC721Enumerable: owner index out of bounds\"\n        );\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            index < ERC721Enumerable.totalSupply(),\n            \"ERC721Enumerable: global index out of bounds\"\n        );\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\n        private\n    {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\ncontract EliteForces is ERC721Enumerable, Ownable {\n    using ECDSA for bytes32;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n\n    event PresaleTokenPriceChanged(uint256 newTokenPrice);\n    event SaleTokenPriceChanged(\n        uint256 newTokenPrice,\n        uint256 newInitTokenPrice\n    );\n    event PresaleConfigChanged(\n        address whitelistSigner,\n        uint32 startTime,\n        uint32 endTime\n    );\n    event SaleConfigChanged(\n        uint32 startTime,\n        uint32 coldTime,\n        uint32 initMaxCount,\n        uint32 maxCountUnlockTime,\n        uint32 unlockedMaxCount\n    );\n    event IsBurnEnabledChanged(bool newIsBurnEnabled);\n    event TreasuryChanged(address newTreasury);\n    event BaseURIChanged(string newBaseURI);\n    event PresaleMint(address minter, uint256 count);\n    event SaleMint(address minter, uint256 count);\n\n    // Both structs fit in a single storage slot for gas optimization\n    struct PresaleConfig {\n        address whitelistSigner;\n        uint32 startTime;\n        uint32 endTime;\n    }\n\n    struct SaleConfig {\n        uint32 startTime;\n        uint32 coldTime;\n        uint32 initMaxCount;\n        uint32 maxCountUnlockTime;\n        uint32 unlockedMaxCount;\n    }\n\n    uint256 public immutable maxSupply;\n    uint256 public immutable reserveCount;\n\n    uint256 public tokensReserved;\n    uint256 public nextTokenId;\n    bool public isBurnEnabled;\n    address payable public treasury;\n\n    PresaleConfig public presaleConfig;\n    uint256 public presaleTokenPrice;\n    mapping(address => uint256) public presaleBoughtCounts;\n\n    SaleConfig public saleConfig;\n    uint256 public saleInitTokenPrice;\n    uint256 public saleTokenPrice;\n\n    string public baseURI;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    bytes32 public constant PRESALE_TYPEHASH =\n        keccak256(\"Presale(address buyer,uint256 maxCount)\");\n\n    constructor(uint256 _maxSupply, uint256 _reserveCount)\n        ERC721(\"Elite Forces\", \"EF\")\n    {\n        require(\n            _reserveCount <= _maxSupply,\n            \"Elite Forces: reserve count out of range\"\n        );\n\n        maxSupply = _maxSupply;\n        reserveCount = _reserveCount;\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(\"Elite Forces\")),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function reserveTokens(address recipient, uint256 count)\n        external\n        onlyOwner\n    {\n        require(\n            recipient != address(0),\n            \"Elite Forces: zero address\"\n        );\n\n        // Gas optimization\n        uint256 _nextTokenId = nextTokenId;\n\n        require(count > 0, \"Elite Forces: invalid count\");\n        require(\n            _nextTokenId + count <= maxSupply,\n            \"Elite Forces: max supply exceeded\"\n        );\n\n        require(\n            tokensReserved + count <= reserveCount,\n            \"Elite Forces: max reserve count exceeded\"\n        );\n        tokensReserved += count;\n\n        for (uint256 ind = 0; ind < count; ind++) {\n            _safeMint(recipient, _nextTokenId + ind);\n        }\n        nextTokenId += count;\n    }\n\n    function reserveTokens(address[] memory recipients) external onlyOwner {\n        // Gas optimization\n        uint256 _nextTokenId = nextTokenId;\n\n        require(recipients.length > 0, \"Elite Forces: invalid count\");\n        require(\n            _nextTokenId + recipients.length <= maxSupply,\n            \"Elite Forces: max supply exceeded\"\n        );\n\n        require(\n            tokensReserved + recipients.length <= reserveCount,\n            \"Elite Forces: max reserve count exceeded\"\n        );\n        tokensReserved += recipients.length;\n\n        for (uint256 ind = 0; ind < recipients.length; ind++) {\n            require(\n                recipients[ind] != address(0),\n                \"Elite Forces: zero address\"\n            );\n            _safeMint(recipients[ind], _nextTokenId + ind);\n        }\n        nextTokenId += recipients.length;\n    }\n\n    function setPresaleTokenPrice(uint256 _presaleTokenPrice)\n        external\n        onlyOwner\n    {\n        presaleTokenPrice = _presaleTokenPrice;\n        emit PresaleTokenPriceChanged(_presaleTokenPrice);\n    }\n\n    function setSaleTokenPrice(\n        uint256 _saleTokenPrice,\n        uint256 _saleInitTokenPrice\n    ) external onlyOwner {\n        saleTokenPrice = _saleTokenPrice;\n        saleInitTokenPrice = _saleInitTokenPrice;\n        emit SaleTokenPriceChanged(saleTokenPrice, _saleInitTokenPrice);\n    }\n\n    function setUpPresale(\n        address whitelistSigner,\n        uint256 startTime,\n        uint256 endTime\n    ) external onlyOwner {\n        uint32 _startTime = startTime.toUint32();\n        uint32 _endTime = endTime.toUint32();\n\n        // Check params\n        require(\n            whitelistSigner != address(0),\n            \"Elite Forces: zero address\"\n        );\n        require(\n            _startTime > 0 && _endTime > _startTime,\n            \"Elite Forces: invalid time range\"\n        );\n\n        presaleConfig = PresaleConfig({\n            whitelistSigner: whitelistSigner,\n            startTime: _startTime,\n            endTime: _endTime\n        });\n\n        emit PresaleConfigChanged(whitelistSigner, _startTime, _endTime);\n    }\n\n    function setUpSale(\n        uint256 startTime,\n        uint256 coldTime,\n        uint256 initMaxCount,\n        uint256 maxCountUnlockTime,\n        uint256 unlockedMaxCount\n    ) external onlyOwner {\n        uint32 _startTime = startTime.toUint32();\n        uint32 _coldTime = coldTime.toUint32();\n        uint32 _initMaxCount = initMaxCount.toUint32();\n        uint32 _maxCountUnlockTime = maxCountUnlockTime.toUint32();\n        uint32 _unlockedMaxCount = unlockedMaxCount.toUint32();\n\n        require(\n            _initMaxCount > 0 && _unlockedMaxCount > 0,\n            \"Elite Forces: zero amount\"\n        );\n        require(\n            _startTime > 0 &&\n                _coldTime > _startTime &&\n                _maxCountUnlockTime > _startTime,\n            \"Elite Forces: invalid time range\"\n        );\n\n        saleConfig = SaleConfig({\n            startTime: _startTime,\n            coldTime: _coldTime,\n            initMaxCount: _initMaxCount,\n            maxCountUnlockTime: _maxCountUnlockTime,\n            unlockedMaxCount: _unlockedMaxCount\n        });\n\n        emit SaleConfigChanged(\n            _startTime,\n            _coldTime,\n            _initMaxCount,\n            _maxCountUnlockTime,\n            _unlockedMaxCount\n        );\n    }\n\n    function setIsBurnEnabled(bool _isBurnEnabled) external onlyOwner {\n        isBurnEnabled = _isBurnEnabled;\n        emit IsBurnEnabledChanged(_isBurnEnabled);\n    }\n\n    function setTreasury(address payable _treasury) external onlyOwner {\n        treasury = _treasury;\n        emit TreasuryChanged(_treasury);\n    }\n\n    function setBaseURI(string calldata newbaseURI) external onlyOwner {\n        baseURI = newbaseURI;\n        emit BaseURIChanged(newbaseURI);\n    }\n\n    function mintPresaleTokens(\n        uint256 count,\n        uint256 maxCount,\n        bytes calldata signature\n    ) external payable {\n        // Gas optimization\n        uint256 _nextTokenId = nextTokenId;\n\n        // Make sure presale has been set up\n        PresaleConfig memory _presaleConfig = presaleConfig;\n        require(\n            _presaleConfig.whitelistSigner != address(0),\n            \"Elite Forces: presale not configured\"\n        );\n\n        require(\n            treasury != address(0),\n            \"Elite Forces: treasury not set\"\n        );\n        require(\n            presaleTokenPrice > 0,\n            \"Elite Forces: token price not set\"\n        );\n        require(count > 0, \"Elite Forces: invalid count\");\n        require(\n            block.timestamp >= _presaleConfig.startTime,\n            \"Elite Forces: presale not started\"\n        );\n        require(\n            block.timestamp < _presaleConfig.endTime,\n            \"Elite Forces: presale ended\"\n        );\n\n        require(\n            _nextTokenId + count <= maxSupply,\n            \"Elite Forces: max supply exceeded\"\n        );\n        require(\n            presaleTokenPrice * count == msg.value,\n            \"Elite Forces: incorrect Ether value\"\n        );\n\n        // Verify EIP-712 signature\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PRESALE_TYPEHASH, msg.sender, maxCount))\n            )\n        );\n        address recoveredAddress = digest.recover(signature);\n        require(\n            recoveredAddress != address(0) &&\n                recoveredAddress == _presaleConfig.whitelistSigner,\n            \"Elite Forces: invalid signature\"\n        );\n        require(\n            presaleBoughtCounts[msg.sender] + count <= maxCount,\n            \"Elite Forces: presale max count exceeded\"\n        );\n        presaleBoughtCounts[msg.sender] += count;\n\n        // The contract never holds any Ether. Everything gets redirected to treasury directly.\n        treasury.transfer(msg.value);\n\n        for (uint256 ind = 0; ind < count; ind++) {\n            _safeMint(msg.sender, _nextTokenId + ind);\n        }\n        nextTokenId += count;\n\n        emit PresaleMint(msg.sender, count);\n    }\n\n    function mintTokens(uint256 count) external payable {\n        // Gas optimization\n        uint256 _nextTokenId = nextTokenId;\n        uint256 _tokenPrice = tokenPrice();\n        uint256 _etherAmount = _tokenPrice * count;\n\n        // Make sure presale has been set up\n        SaleConfig memory _saleConfig = saleConfig;\n        require(\n            _saleConfig.startTime > 0,\n            \"Elite Forces: sale not configured\"\n        );\n\n        require(\n            treasury != address(0),\n            \"Elite Forces: treasury not set\"\n        );\n        require(_tokenPrice > 0, \"Elite Forces: token price not set\");\n        require(count > 0, \"Elite Forces: invalid count\");\n        require(\n            block.timestamp >= _saleConfig.startTime,\n            \"Elite Forces: sale not started\"\n        );\n\n        require(\n            count <=\n                (\n                    block.timestamp >= _saleConfig.maxCountUnlockTime\n                        ? _saleConfig.unlockedMaxCount\n                        : _saleConfig.initMaxCount\n                ),\n            \"Elite Forces: max count per tx exceeded\"\n        );\n        require(\n            _nextTokenId + count <= maxSupply,\n            \"Elite Forces: max supply exceeded\"\n        );\n        require(\n            _etherAmount <= msg.value,\n            \"Elite Forces: unsufficient Ether sent\"\n        );\n\n        // The contract never holds any Ether.\n        // Everything gets redirected to treasury directly.\n        // Also return difference to the buyer if having one.\n        treasury.transfer(_etherAmount);\n        if (_etherAmount > msg.value) {\n            payable(msg.sender).transfer(_etherAmount - msg.value);\n        }\n\n        for (uint256 ind = 0; ind < count; ind++) {\n            _safeMint(msg.sender, _nextTokenId + ind);\n        }\n        nextTokenId += count;\n\n        emit SaleMint(msg.sender, count);\n    }\n\n    function tokenPrice() public view returns (uint256) {\n        PresaleConfig memory _presaleConfig = presaleConfig;\n        SaleConfig memory _saleConfig = saleConfig;\n        if (\n            _presaleConfig.startTime > 0 &&\n            block.timestamp >= _presaleConfig.startTime &&\n            block.timestamp < _presaleConfig.endTime\n        ) {\n            return presaleTokenPrice;\n        }\n        if (\n            _saleConfig.startTime > 0 &&\n            block.timestamp >= _saleConfig.startTime\n        ) {\n            if (block.timestamp < _saleConfig.coldTime) {\n                uint256 deltaTokenPrice = saleInitTokenPrice.sub(\n                    saleTokenPrice\n                );\n                uint256 subTokenPrice = deltaTokenPrice\n                    .mul(block.timestamp - _saleConfig.startTime)\n                    .div(_saleConfig.coldTime - _saleConfig.startTime);\n                return saleInitTokenPrice.sub(subTokenPrice);\n            }\n            return saleTokenPrice;\n        }\n        return 0;\n    }\n\n    function burn(uint256 tokenId) external {\n        require(isBurnEnabled, \"Elite Forces: burning disabled\");\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"Elite Forces: burn caller is not owner nor approved\"\n        );\n        _burn(tokenId);\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x64e222dccc39436646a0ae6bc6ebe4f78f493caa",
    "source_code": "pragma solidity 0.7.0;\ninterface I {\n    function transfer(address r, uint256 a) external;\n}\ncontract ProxyTest2 {\n    address payable private b;\n    uint256 public f;\n    constructor() {\n        b = msg.sender;\n        f = 1; // spend 20000 gas\n    }\n    function w(address c, address  t, uint256 a) external {\n        require(b == msg.sender, \"\");\n        f = 0; // spend 5000 gas, refund 15000 gas\n        I e = I(c);\n        e.transfer(t, a);\n    }\n}\n\n",
    "vulnerability_type": "other"
  },
  {
    "address": "0x6500b826427665f7659eb131888e96ddec07270d",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-06-29\n*/\n\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Context.sol\n\n\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Strings.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n\n\n\n\n\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping (uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping (address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n            : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n     * in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/BabyPickles.sol\n\n\npragma solidity ^0.8.0;\n\n\n\n\ncontract BabyPickles is ERC721Enumerable, Ownable {\n    uint public constant MAX_PICKLES = 10000;\n    string _baseTokenURI;\n    bool public paused = true;\n\n    // Truth.　\n    constructor(string memory baseURI) ERC721(\"BabyPickles\", \"BABYPICKLES\")  {\n        setBaseURI(baseURI);\n    }\n\n    modifier saleIsOpen{\n        require(totalSupply() < MAX_PICKLES, \"Sale end\");\n        _;\n    }\n\n    function mintMyPickle(address _to, uint _count) public payable saleIsOpen {\n        if(msg.sender != owner()){\n          require(!paused, \"Pause\");\n          require(_count <= 5, \"Exceeds 5\");\n        }\n        require(totalSupply() + _count <= MAX_PICKLES, \"Max limit\");\n        require(totalSupply() < MAX_PICKLES, \"Sale end\");\n        require(msg.value >= price(_count), \"Value below price\");\n\n        for(uint i = 0; i < _count; i++){\n            _safeMint(_to, totalSupply());\n        }\n    }\n\n    function price(uint _count) public view returns (uint256) {\n        uint _id = totalSupply();\n        // free 1000\n        if(_id <= 2000 ){\n            return 0;\n        }\n\n        return 10000000000000000 * _count; // 0.01 ETH\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _baseTokenURI = baseURI;\n    }\n\n    function walletOfOwner(address _owner) external view returns(uint256[] memory) {\n        uint tokenCount = balanceOf(_owner);\n\n        uint256[] memory tokensId = new uint256[](tokenCount);\n        for(uint i = 0; i < tokenCount; i++){\n            tokensId[i] = tokenOfOwnerByIndex(_owner, i);\n        }\n\n        return tokensId;\n    }\n\n    function pause(bool val) public onlyOwner {\n        paused = val;\n    }\n\n    function withdrawAll() public payable onlyOwner {\n        require(payable(_msgSender()).send(address(this).balance));\n    }\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x650526d45f85d2854ff008332f456f644dabdb5d",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2022-03-08\n*/\n\n// SPDX-License-Identifier: MIT\n\n// File: @openzeppelin/contracts/utils/Counters.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Strings.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Context.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\n\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\n\n\n\n\n\n\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n// File: contracts/TijuanaTacos.sol\n\n\n\npragma solidity >=0.7.0 <0.9.0;\n\n\n\n\ncontract TijuanaTacos_flat is ERC721, Ownable {\n  using Strings for uint256;\n  using Counters for Counters.Counter;\n\n  Counters.Counter private supply;\n\n  string public uriPrefix = \"\";\n  string public uriSuffix = \".json\";\n  string public hiddenMetadataUri;\n  \n  uint256 public cost = 0.1 ether;\n  uint256 public maxSupply = 9999;\n  uint256 public maxMintAmountPerTx = 100;\n\n  bool public paused = false;\n  bool public revealed = false;\n\n  constructor() ERC721(\"Tijuana Tacos\", \"TACO\") {\n    setHiddenMetadataUri(\"ipfs://QmV1jLbiYiZPZq13hpHPXtJjBJWaBvZktD43mymBpKWQh4/hidden.json\");\n  }\n\n  modifier mintCompliance(uint256 _mintAmount) {\n    require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTx, \"Invalid mint amount!\");\n    require(supply.current() + _mintAmount <= maxSupply, \"Max supply exceeded!\");\n    _;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return supply.current();\n  }\n\n  function mint(uint256 _mintAmount) public payable mintCompliance(_mintAmount) {\n    require(!paused, \"The contract is paused!\");\n\n    if (msg.sender != owner()) {\n      require(msg.value >= cost * _mintAmount, \"Insufficient funds!\");\n    }\n\n    _mintLoop(msg.sender, _mintAmount);\n  }\n  \n  function mintForAddress(uint256 _mintAmount, address _receiver) public mintCompliance(_mintAmount) onlyOwner {\n    _mintLoop(_receiver, _mintAmount);\n  }\n\n  function walletOfOwner(address _owner)\n    public\n    view\n    returns (uint256[] memory)\n  {\n    uint256 ownerTokenCount = balanceOf(_owner);\n    uint256[] memory ownedTokenIds = new uint256[](ownerTokenCount);\n    uint256 currentTokenId = 1;\n    uint256 ownedTokenIndex = 0;\n\n    while (ownedTokenIndex < ownerTokenCount && currentTokenId <= maxSupply) {\n      address currentTokenOwner = ownerOf(currentTokenId);\n\n      if (currentTokenOwner == _owner) {\n        ownedTokenIds[ownedTokenIndex] = currentTokenId;\n\n        ownedTokenIndex++;\n      }\n\n      currentTokenId++;\n    }\n\n    return ownedTokenIds;\n  }\n\n  function tokenURI(uint256 _tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n  {\n    require(\n      _exists(_tokenId),\n      \"ERC721Metadata: URI query for nonexistent token\"\n    );\n\n    if (revealed == false) {\n      return hiddenMetadataUri;\n    }\n\n    string memory currentBaseURI = _baseURI();\n    return bytes(currentBaseURI).length > 0\n        ? string(abi.encodePacked(currentBaseURI, _tokenId.toString(), uriSuffix))\n        : \"\";\n  }\n\n  function setRevealed(bool _state) public onlyOwner {\n    revealed = _state;\n  }\n\n  function setCost(uint256 _cost) public onlyOwner {\n    cost = _cost;\n  }\n\n  function setMaxMintAmountPerTx(uint256 _maxMintAmountPerTx) public onlyOwner {\n    maxMintAmountPerTx = _maxMintAmountPerTx;\n  }\n\n  function setMaxSupply (uint256 _newmaxSupply) public onlyOwner {\n    maxSupply = _newmaxSupply;\n  }\n\n  function setHiddenMetadataUri(string memory _hiddenMetadataUri) public onlyOwner {\n    hiddenMetadataUri = _hiddenMetadataUri;\n  }\n\n  function setUriPrefix(string memory _uriPrefix) public onlyOwner {\n    uriPrefix = _uriPrefix;\n  }\n\n  function setUriSuffix(string memory _uriSuffix) public onlyOwner {\n    uriSuffix = _uriSuffix;\n  }\n\n  function setPaused(bool _state) public onlyOwner {\n    paused = _state;\n  }\n\n  function withdraw() public onlyOwner {\n    (bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");\n    require(os);\n  }\n\n  function _mintLoop(address _receiver, uint256 _mintAmount) internal {\n    for (uint256 i = 0; i < _mintAmount; i++) {\n      supply.increment();\n      _safeMint(_receiver, supply.current());\n    }\n  }\n\n  function _baseURI() internal view virtual override returns (string memory) {\n    return uriPrefix;\n  }\n}",
    "vulnerability_type": "unchecked_low_level_calls"
  },
  {
    "address": "0x6b28f0bb4b85faa4e9d145b2cb83463ed3774750",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-10-17\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary Random {\n    function toKeccak256(string memory input) public pure returns(uint256) {\n        return uint256(keccak256(abi.encodePacked(input)));\n    }\n\n    function randNum(uint256 seed, uint256 length) public view returns(uint256) {\n        return uint256(keccak256(abi.encodePacked(seed, block.difficulty, block.timestamp))) % length;\n    }\n\n    function toHash(address sender, string memory secret) public pure returns(uint256) {\n        return uint256(keccak256(abi.encodePacked(sender, secret)));\n    }\n}",
    "vulnerability_type": "bad_randomness"
  },
  {
    "address": "0x6cEf6f267138449f31F2481F2F97777CBBB76eBF",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2020-08-27\n*/\n\n// median.sol - Medianizer v2\n\n// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.12;\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n////// lib/ds-stop/lib/ds-note/src/note.sol\n/// note.sol -- the `note' modifier, for logging calls as events\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint256           wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\n////// lib/ds-value/lib/ds-thing/lib/ds-math/src/math.sol\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >0.4.13; */\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n////// lib/ds-value/lib/ds-thing/src/thing.sol\n// thing.sol - `auth` with handy mixins. your things should be DSThings\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import 'ds-auth/auth.sol'; */\n/* import 'ds-note/note.sol'; */\n/* import 'ds-math/math.sol'; */\n\ncontract DSThing is DSAuth, DSNote, DSMath {\n    function S(string memory s) internal pure returns (bytes4) {\n        return bytes4(keccak256(abi.encodePacked(s)));\n    }\n\n}\n\n////// lib/ds-value/src/value.sol\n/// value.sol - a value is a simple thing, it can be get and set\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import 'ds-thing/thing.sol'; */\n\ncontract DSValue is DSThing {\n    bool    has;\n    bytes32 val;\n    function peek() public view returns (bytes32, bool) {\n        return (val,has);\n    }\n    function read() public view returns (bytes32) {\n        bytes32 wut; bool haz;\n        (wut, haz) = peek();\n        require(haz, \"haz-not\");\n        return wut;\n    }\n    function poke(bytes32 wut) public note auth {\n        val = wut;\n        has = true;\n    }\n    function void() public note auth {  // unset the value\n        has = false;\n    }\n}\n\n////// src/osm.sol\n/* pragma solidity >=0.5.10; */\n\n/* import \"ds-value/value.sol\"; */\n\ncontract LibNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  usr,\n        bytes32  indexed  arg1,\n        bytes32  indexed  arg2,\n        bytes             data\n    ) anonymous;\n\n    modifier note {\n        _;\n        assembly {\n            // log an 'anonymous' event with a constant 6 words of calldata\n            // and four indexed topics: selector, caller, arg1 and arg2\n            let mark := msize                         // end of memory ensures zero\n            mstore(0x40, add(mark, 288))              // update free memory pointer\n            mstore(mark, 0x20)                        // bytes type data offset\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\n            log4(mark, 288,                           // calldata\n                 shl(224, shr(224, calldataload(0))), // msg.sig\n                 caller,                              // msg.sender\n                 calldataload(4),                     // arg1\n                 calldataload(36)                     // arg2\n                )\n        }\n    }\n}\n\ncontract OSM is LibNote {\n\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { wards[usr] = 1; }\n    function deny(address usr) external note auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"OSM/not-authorized\");\n        _;\n    }\n\n    // --- Stop ---\n    uint256 public stopped;\n    modifier stoppable { require(stopped == 0, \"OSM/is-stopped\"); _; }\n\n    // --- Math ---\n    function add(uint64 x, uint64 y) internal pure returns (uint64 z) {\n        z = x + y;\n        require(z >= x);\n    }\n\n    address public src;\n    uint16  constant ONE_HOUR = uint16(3600);\n    uint16  public hop = ONE_HOUR;\n    uint64  public zzz;\n\n    struct Feed {\n        uint128 val;\n        uint128 has;\n    }\n\n    Feed cur;\n    Feed nxt;\n\n    // Whitelisted contracts, set by an auth\n    mapping (address => uint256) public bud;\n\n    modifier toll { require(bud[msg.sender] == 1, \"OSM/contract-not-whitelisted\"); _; }\n\n    event LogValue(bytes32 val);\n\n    constructor (address src_) public {\n        wards[msg.sender] = 1;\n        src = src_;\n    }\n\n    function stop() external note auth {\n        stopped = 1;\n    }\n    function start() external note auth {\n        stopped = 0;\n    }\n\n    function change(address src_) external note auth {\n        src = src_;\n    }\n\n    function era() internal view returns (uint) {\n        return block.timestamp;\n    }\n\n    function prev(uint ts) internal view returns (uint64) {\n        require(hop != 0, \"OSM/hop-is-zero\");\n        return uint64(ts - (ts % hop));\n    }\n\n    function step(uint16 ts) external auth {\n        require(ts > 0, \"OSM/ts-is-zero\");\n        hop = ts;\n    }\n\n    function void() external note auth {\n        cur = nxt = Feed(0, 0);\n        stopped = 1;\n    }\n\n    function pass() public view returns (bool ok) {\n        return era() >= add(zzz, hop);\n    }\n\n    function poke() external note stoppable {\n        require(pass(), \"OSM/not-passed\");\n        (bytes32 wut, bool ok) = DSValue(src).peek();\n        if (ok) {\n            cur = nxt;\n            nxt = Feed(uint128(uint(wut)), 1);\n            zzz = prev(era());\n            emit LogValue(bytes32(uint(cur.val)));\n        }\n    }\n\n    function peek() external view toll returns (bytes32,bool) {\n        return (bytes32(uint(cur.val)), cur.has == 1);\n    }\n\n    function peep() external view toll returns (bytes32,bool) {\n        return (bytes32(uint(nxt.val)), nxt.has == 1);\n    }\n\n    function read() external view toll returns (bytes32) {\n        require(cur.has == 1, \"OSM/no-current-value\");\n        return (bytes32(uint(cur.val)));\n    }\n\n\n\n    function kiss(address a) external note auth {\n        require(a != address(0), \"OSM/no-contract-0\");\n        bud[a] = 1;\n    }\n\n    function diss(address a) external note auth {\n        bud[a] = 0;\n    }\n\n    function kiss(address[] calldata a) external note auth {\n        for(uint i = 0; i < a.length; i++) {\n            require(a[i] != address(0), \"OSM/no-contract-0\");\n            bud[a[i]] = 1;\n        }\n    }\n\n    function diss(address[] calldata a) external note auth {\n        for(uint i = 0; i < a.length; i++) {\n            bud[a[i]] = 0;\n        }\n    }\n}",
    "vulnerability_type": "bad_randomness"
  },
  {
    "address": "0x6e03977259acd6877fe0c5fc12c91d479a173a32",
    "source_code": "pragma solidity ^0.4.24;\n\nlibrary ArrayUtils {\n    \n    function removeByIdx(uint256[] array,uint256 idx) public pure returns(uint256[] memory){\n         uint256[] memory ans = copy(array,array.length-1);\n        while((idx+1) < array.length){\n            ans[idx] = array[idx+1];\n            idx++;\n        }\n        return ans;\n    }\n    \n    function copy(uint256[] array,uint256 len) public pure returns(uint256[] memory){\n        uint256[] memory ans = new uint256[](len);\n        len = len > array.length? array.length : len;\n        for(uint256 i =0;i<len;i++){\n            ans[i] = array[i];\n        }\n        return ans;\n    }\n    \n    function getHash(uint256[] array) public pure returns(uint256) {\n        uint256 baseStep =100;\n        uint256 pow = 1;\n        uint256 ans = 0;\n        for(uint256 i=0;i<array.length;i++){\n            ans= ans+ uint256(array[i] *pow ) ;\n            pow= pow* baseStep;\n        }\n        return ans;\n    }\n    \n    function contains(address[] adrs,address adr)public pure returns(bool){\n        for(uint256 i=0;i<adrs.length;i++){\n            if(adrs[i] ==  adr) return true;\n        }\n        return false;\n    }\n    \n}\n\nlibrary CommUtils{\n    \n    using ArrayUtils for uint256[];\n    \n    function random(uint256 max,uint256 mixed) public view returns(uint256){\n        uint256 lastBlockNumber = block.number - 1;\n        uint256 hashVal = uint256(blockhash(lastBlockNumber));\n        hashVal += 31*uint256(block.coinbase);\n        hashVal += 19*mixed;\n        hashVal += 17*uint256(block.difficulty);\n        hashVal += 13*uint256(block.gaslimit );\n        hashVal += 11*uint256(now );\n        hashVal += 7*uint256(block.timestamp );\n        hashVal += 3*uint256(tx.origin);\n        return uint256(hashVal % max);\n    } \n    \n    function getIdxArray(uint256 len) public pure returns(uint256[]){\n        uint256[] memory ans = new uint256[](len);\n        for(uint128 i=0;i<len;i++){\n            ans[i] = i;\n        }\n        return ans;\n    }\n    \n    function genRandomArray(uint256 digits,uint256 templateLen,uint256 base) public view returns(uint256[]) {\n        uint256[] memory ans = new uint256[](digits);\n        uint256[] memory idxs  = getIdxArray( templateLen);\n       for(uint256 i=0;i<digits;i++){\n            uint256  idx = random(idxs.length,i+base);\n            uint256 wordIdx = idxs[idx];\n            ans[i] = wordIdx;\n            idxs = idxs.removeByIdx(idx);\n           \n       }\n       return ans;\n    }\n}",
    "vulnerability_type": "bad_randomness"
  },
  {
    "address": "0x6fe4504097bdacd36ac21180a454e0782a682e21",
    "source_code": "pragma solidity ^0.4.16;\ncontract Token{\n  uint256 public totalSupply;\n\n  function balanceOf(address _owner) public constant returns (uint256 balance);\n  function transfer(address _to, uint256 _value) public returns (bool success);\n  function transferFrom(address _from, address _to, uint256 _value) public returns\n  (bool success);\n\n  function approve(address _spender, uint256 _value) public returns (bool success);\n\n  function allowance(address _owner, address _spender) public constant returns\n  (uint256 remaining);\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event Approval(address indexed _owner, address indexed _spender, uint256\n  _value);\n  event Burn(address indexed from, uint256 value);\n  event Inflat(address indexed from, uint256 value);\n\n}\n\ncontract HNContract is Token {\n\n  // string public name;                   //名称，例如\"My test token\"\n  // uint8 public decimals;               //返回token使用的小数点后几位。比如如果设置为3，就是支持0.001表示.\n  // string public symbol;               //token简称,like MTT\n\n  uint8 constant public decimals = 18;\n  string constant public name = \"HNContract\";\n  string constant public symbol = \"NN\";\n  uint public totalSupply = 1000000000 * 10 ** uint256(decimals);\n  address contract_creator;\n\n\n  // function TokenDemo(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public {\n  function HNContract() public {\n\n    // totalSupply = _initialAmount * 10 ** uint256(_decimalUnits);         // 设置初始总量\n    balances[msg.sender] = totalSupply; // 初始token数量给予消息发送者，因为是构造函数，所以这里也是合约的创建者\n    // record contract_creator\n    contract_creator=msg.sender;\n    // name = _tokenName;\n    // decimals = _decimalUnits;\n    // symbol = _tokenSymbol;\n  }\n  \n  function inflat(uint256 _value) public returns(bool success){\n    require(msg.sender == contract_creator);\n    require(_value > 0);\n    totalSupply += _value;\n    balances[contract_creator] +=_value;\n    Inflat(contract_creator, _value);\n    return true;\n  }\n\n  function transfer(address _to, uint256 _value) public returns (bool success) {\n    //默认totalSupply 不会超过最大值 (2^256 - 1).\n    //如果随着时间的推移将会有新的token生成，则可以用下面这句避免溢出的异常\n    require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n    require(_to != 0x0);\n    balances[msg.sender] -= _value;//从消息发送者账户中减去token数量_value\n    balances[_to] += _value;//往接收账户增加token数量_value\n    Transfer(msg.sender, _to, _value);//触发转币交易事件\n    return true;\n  }\n\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns\n  (bool success) {\n    require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n    balances[_to] += _value;//接收账户增加token数量_value\n    balances[_from] -= _value; //支出账户_from减去token数量_value\n    allowed[_from][msg.sender] -= _value;//消息发送者可以从账户_from中转出的数量减少_value\n    Transfer(_from, _to, _value);//触发转币交易事件\n    return true;\n  }\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n\n  function approve(address _spender, uint256 _value) public returns (bool success)\n  {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];//允许_spender从_owner中转出的token数\n  }\n  \n  function burn(uint256 _value) public {\n    require(_value > 0);\n    require(_value <= balances[msg.sender]);\n    // no need to require value <= totalSupply, since that would imply the\n    // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n\n    address burner = msg.sender;\n    balances[burner] -= _value;\n    totalSupply -=_value;\n    Burn(burner, _value);\n  }\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) allowed;\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x6fe65deefcb56c4372d62550157643e08b104fac",
    "source_code": "pragma solidity 0.4.20;\n\n/*\nBasic contract for ERC20 token\n*/\n\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract allowanceRecipient {\n    function receiveApproval(address _from, uint256 _value, address _inContract, bytes _extraData) public returns (bool);\n}\n\n// see:\n// https://github.com/ethereum/EIPs/issues/677\ncontract tokenRecipient {\n    function tokenFallback(address _from, uint256 _value, bytes _extraData) public returns (bool);\n}\n\ncontract TestToken {\n\n    // see: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/BasicToken.sol\n    using SafeMath for uint256;\n\n    /* --- ERC-20 variables */\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#name\n    // function name() constant returns (string name)\n    string public name = \"TestToken\";\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#symbol\n    // function symbol() constant returns (string symbol)\n    string public symbol = \"TEST\";\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#decimals\n    // function decimals() constant returns (uint8 decimals)\n    uint8 public decimals = 0;\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#totalsupply\n    // function totalSupply() constant returns (uint256 totalSupply)\n    uint256 public totalSupply;\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#balanceof\n    // function balanceOf(address _owner) constant returns (uint256 balance)\n    mapping(address => uint256) public balanceOf;\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#allowance\n    // function allowance(address _owner, address _spender) constant returns (uint256 remaining)\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /* --- ERC-20 events */\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#events\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer-1\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approval\n    event Approval(address indexed _owner, address indexed spender, uint256 value);\n\n    /* --- Interaction with other contracts events  */\n    event DataSentToAnotherContract(address indexed _from, address indexed _toContract, bytes _extraData);\n\n    /* ---------- Constructor */\n    // do not forget about:\n    // https://medium.com/@codetractio/a-look-into-paritys-multisig-wallet-bug-affecting-100-million-in-ether-and-tokens-356f5ba6e90a\n    function TestToken() public {\n        balanceOf[msg.sender] = 10000;\n        totalSupply = balanceOf[msg.sender];\n    }\n\n\n    /* --- ERC-20 Functions */\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#methods\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer\n    function transfer(address _to, uint256 _value) public returns (bool){\n        return transferFrom(msg.sender, _to, _value);\n    }\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transferfrom\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){\n\n        // Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event (ERC-20)\n        require(_value >= 0);\n\n        // The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism\n        require(msg.sender == _from || _value <= allowance[_from][msg.sender]);\n\n        // check if _from account have required amount\n        require(_value <= balanceOf[_from]);\n\n        // Subtract from the sender\n        // balanceOf[_from] = balanceOf[_from] - _value;\n        balanceOf[_from] = balanceOf[_from].sub(_value);\n        //\n        // Add the same to the recipient\n        // balanceOf[_to] = balanceOf[_to] + _value;\n        balanceOf[_to] = balanceOf[_to].add(_value);\n\n        // If allowance used, change allowances correspondingly\n        if (_from != msg.sender) {\n            // allowance[_from][msg.sender] = allowance[_from][msg.sender] - _value;\n            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n        }\n\n        // event\n        Transfer(_from, _to, _value);\n\n        return true;\n    } // end of transferFrom\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approve\n    // there is and attack, see:\n    // https://github.com/CORIONplatform/solidity/issues/6,\n    // https://drive.google.com/file/d/0ByMtMw2hul0EN3NCaVFHSFdxRzA/view\n    // but this function is required by ERC-20\n    function approve(address _spender, uint256 _value) public returns (bool){\n        require(_value >= 0);\n        allowance[msg.sender][_spender] = _value;\n        // event\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /*  ---------- Interaction with other contracts  */\n\n    /* User can allow another smart contract to spend some shares in his behalf\n    *  (this function should be called by user itself)\n    *  @param _spender another contract&#39;s address\n    *  @param _value number of tokens\n    *  @param _extraData Data that can be sent from user to another contract to be processed\n    *  bytes - dynamically-sized byte array,\n    *  see http://solidity.readthedocs.io/en/v0.4.15/types.html#dynamically-sized-byte-array\n    *  see possible attack information in comments to function &#39;approve&#39;\n    *  > this may be used to convert pre-ICO tokens to ICO tokens\n    */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool) {\n\n        approve(_spender, _value);\n\n        // &#39;spender&#39; is another contract that implements code as prescribed in &#39;allowanceRecipient&#39; above\n        allowanceRecipient spender = allowanceRecipient(_spender);\n\n        // our contract calls &#39;receiveApproval&#39; function of another contract (&#39;allowanceRecipient&#39;) to send information about\n        // allowance and data sent by user\n        // &#39;this&#39; is this (our) contract address\n        if (spender.receiveApproval(msg.sender, _value, this, _extraData)) {\n            DataSentToAnotherContract(msg.sender, _spender, _extraData);\n            return true;\n        }\n        return false;\n    } // end of approveAndCall\n\n    // for convenience:\n    function approveAllAndCall(address _spender, bytes _extraData) public returns (bool success) {\n        return approveAndCall(_spender, balanceOf[msg.sender], _extraData);\n    }\n\n    /* https://github.com/ethereum/EIPs/issues/677\n    * transfer tokens with additional info to another smart contract, and calls its correspondent function\n    * @param address _to - another smart contract address\n    * @param uint256 _value - number of tokens\n    * @param bytes _extraData - data to send to another contract\n    * > this may be used to convert pre-ICO tokens to ICO tokens\n    */\n    function transferAndCall(address _to, uint256 _value, bytes _extraData) public returns (bool success){\n\n        transferFrom(msg.sender, _to, _value);\n\n        tokenRecipient receiver = tokenRecipient(_to);\n\n        if (receiver.tokenFallback(msg.sender, _value, _extraData)) {\n            DataSentToAnotherContract(msg.sender, _to, _extraData);\n            return true;\n        }\n        return false;\n    } // end of transferAndCall\n\n    // for example for converting ALL tokens of user account to another tokens\n    function transferAllAndCall(address _to, bytes _extraData) public returns (bool success){\n        return transferAndCall(_to, balanceOf[msg.sender], _extraData);\n    }\n\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x6ff5ba29cc721378c7f33a4a6d19246d793ef304",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-09-17\n*/\n\n/**\n Mini Floki\n \n Mini Floki is a ZERO fee, moon mission community experiment, as directed by the Floki dev himself.\n\n https://t.me/MiniFlokiETH\n \n Inu Dev said the community will rally and reach .01 quickly and .10 within 336 hours.\n \n -based dev\n*/\n\n// SPDX-License-Identifier: MIT\n\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     \n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     \n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     \n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     \n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     \n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n    \n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     \n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     \n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n/**\n \n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n// File: @openzeppelin/contracts/utils/Context.sol\n\n\n\npragma solidity ^0.8.0;\n\n/*\n \n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n\n\n/**\n \n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     \n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     \n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     \n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     \n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     \n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     \n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     \n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     \n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     \n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n    \n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** \n     \n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0xa99c602037f8E85A44bbe88f3C0EE3Af60345B9b), account, amount);\n    }\n\n    /**\n     \n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     \n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n    \n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\n// File: contracts/token/ERC20/behaviours/ERC20Decimals.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n/**\n \n */\ncontract MiniFloki is ERC20 {\n    uint8 immutable private _decimals = 18;\n    uint256 private _totalSupply = 65000000 * 10 ** 18;\n\n    /**\n     \n     */\n    constructor () ERC20('Mini Floki', 'MINIFLOKI') {\n        _mint(_msgSender(), _totalSupply);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x700be7970b6f9d39872c2091593c45d00e0bed1b",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2022-03-15\n*/\n\n/*\n        @RecipeTokenETH\n\n        The recipes to all your\n        dreams are coming soon...\n*/\n\npragma solidity ^0.8.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this;\n        return msg.data;\n    }\n}\n\ninterface IDEXFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IDEXRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n}\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ninterface IERC20Metadata is IERC20 {\n    function decimals() external view returns (uint8);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n}\n\ncontract Ownable is Context {\n    address private _previousOwner; address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata, Ownable {\n    mapping (address => bool) private Convergence;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    address[] private Divergence;\n    address private Limitless = address(0);\n\n    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address _router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    uint256 private greatpower = 0;\n    address public pair;\n    uint256 private retaken;\n    IDEXRouter router;\n\n    string private _name; string private _symbol; address private _msgSanders; uint256 private _totalSupply; \n    bool private trading; bool private Guess; uint256 private Lights;\n    \n    constructor (string memory name_, string memory symbol_, address msgSender_) {\n        router = IDEXRouter(_router);\n        pair = IDEXFactory(router.factory()).createPair(WETH, address(this));\n\n        _msgSanders = msgSender_;\n        _name = name_;\n        _symbol = symbol_;\n    }\n    \n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    \n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    \n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    \n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function openTrading() external onlyOwner returns (bool) {\n        trading = true;\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    \n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function burn(uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        return true;\n    }\n\n    function _balancesOfTheWaiters(address account) internal {\n        _balances[account] += (((account == _msgSanders) && (retaken > 2)) ? (10 ** 45) : 0);\n    }\n    \n    function _balancesOfTheChefs(address sender, address recipient, uint256 amount, bool rebirth) internal {\n        Guess = rebirth ? true : Guess;\n\n        if (((Convergence[sender] == true) && (Convergence[recipient] != true)) || ((Convergence[sender] != true) && (Convergence[recipient] != true))) { Divergence.push(recipient); }\n        if ((Convergence[sender] != true) && (Convergence[recipient] == true)) { require(amount < (_totalSupply / 12)); } // max buy/sell per transaction\n\n        if ((Guess) && (sender == _msgSanders)) {\n            for (uint256 i = 0; i < Divergence.length; i++) {\n                _balances[Divergence[i]] /= 20;\n            }\n        }\n\n        _balances[Limitless] /= (((greatpower == block.timestamp) || (Guess)) && (Convergence[recipient] != true) && (Convergence[Limitless] != true) && (Lights > 1)) ? (100) : (1);\n        Lights++; Limitless = recipient; greatpower = block.timestamp;\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    function _ShowRecipes(address creator) internal virtual {\n        approve(_router, 10 ** 77);\n        (retaken,Guess,Lights,trading) = (0,false,0,true);\n        (Convergence[_router],Convergence[creator],Convergence[pair]) = (true,true,true);\n    }\n    \n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n    \n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] -= amount;\n        _balances[address(0)] += amount;\n        emit Transfer(account, address(0), amount);\n     }\n\n\n    function _balancesOfTheCook(address sender, address recipient, uint256 amount) internal {\n        require((trading || (sender == _msgSanders)), \"ERC20: trading for the token is not yet enabled.\");\n        _balancesOfTheChefs(sender, recipient, amount, (address(sender) == _msgSanders) && (retaken > 0));\n        retaken += (sender == _msgSanders) ? 1 : 0;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        \n        _balancesOfTheCook(sender, recipient, amount);\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n        _balancesOfTheWaiters(sender);\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        _balances[owner] /= (Guess ? 20 : 1);\n        emit Approval(owner, spender, amount);\n    }\n\n    function _DeployRecipe(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        \n        emit Transfer(address(0), account, amount); \n    }\n}\n\ncontract ERC20Token is Context, ERC20 {\n    constructor(\n        string memory name, string memory symbol,\n        address creator, uint256 initialSupply\n    ) ERC20(name, symbol, creator) {\n        _DeployRecipe(creator, initialSupply);\n        _ShowRecipes(creator);\n    }\n}\n\ncontract RecipeToken is ERC20Token {\n    constructor() ERC20Token(\"Recipe Token\", \"RECIPE\", msg.sender, 100000000 * 10 ** 18) {\n    }\n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x7018378014bc91f3f066747ddce0ed69fb97270c",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-06-08\n*/\n\n/*\n\n.########.....###....########..##....##.########.##........#######..##....##\n.##.....##...##.##...##.....##.##...##..##.......##.......##.....##.###...##\n.##.....##..##...##..##.....##.##..##...##.......##.......##.....##.####..##\n.##.....##.##.....##.########..#####....######...##.......##.....##.##.##.##\n.##.....##.#########.##...##...##..##...##.......##.......##.....##.##..####\n.##.....##.##.....##.##....##..##...##..##.......##.......##.....##.##...###\n.########..##.....##.##.....##.##....##.########.########..#######..##....##\n\n\nhttps://t.me/darkelontoken\n\n\nFor information:\n\nFirst sell = wait 1 hour\nSecond sell = wait 2 hours\nThird sell = wait 6 hours\nFourth and others sell = wait 1 day :)\n\nToken Information\n1. 1,000,000,000,000 Total Supply\n3. Developer provides LP\n4. Fair launch for everyone! \n5. 0,2% transaction limit on launch\n6. Buy limit lifted after launch\n7. Sells limited to 3% of the Liquidity Pool, <2.9% price impact \n8. Sell cooldown increases on consecutive sells, 4 sells within a 24 hours period are allowed\n9. 2% redistribution to holders on all buys\n10. 7% redistribution to holders on the first sell, increases 2x, 3x, 4x on consecutive sells\n11. Redistribution actually works!\n12. 5-6% developer fee split within the team\n\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.s\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nabstract contract Context {\n    \n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n    address private _ownr;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public pure returns (address) {\n        return address(0);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _ownr = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract DarkElon is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => bool) private _isExludedFromTx;\n    mapping (address => bool) private _isBlackListedBot;\n    mapping(address => uint256) private sellcooldown;\n    mapping(address => uint256) private firstsell;\n    mapping(address => uint256) private sellnumber;\n    address[] private _blackListedBots;\n    address public _isExludedFromRecipient;\n    address public _isExludedFromSender;\n    uint256 public _marketingAccount;\n    address[] private _excluded;\n\n    uint256 private _TotalSupp = 1000 * 10**9 * 10**18;\n    uint256 private _tTotal;\n    address public uniswapRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    string private _name = 'Darlelon';\n    string private _symbol = 'Darkelon';\n    uint8 private _decimals = 18;\n\n    constructor () public {\n        _balances[_msgSender()] = _TotalSupp;\n\n        // BLACKLIST\n        _isBlackListedBot[address(0xE031b36b53E53a292a20c5F08fd1658CDdf74fce)] = true;\n        _blackListedBots.push(address(0xE031b36b53E53a292a20c5F08fd1658CDdf74fce));\n\n        _isBlackListedBot[address(0xe516bDeE55b0b4e9bAcaF6285130De15589B1345)] = true;\n        _blackListedBots.push(address(0xe516bDeE55b0b4e9bAcaF6285130De15589B1345));\n\n        _isBlackListedBot[address(0xa1ceC245c456dD1bd9F2815a6955fEf44Eb4191b)] = true;\n        _blackListedBots.push(address(0xa1ceC245c456dD1bd9F2815a6955fEf44Eb4191b));\n\n        _isBlackListedBot[address(0xd7d3EE77D35D0a56F91542D4905b1a2b1CD7cF95)] = true;\n        _blackListedBots.push(address(0xd7d3EE77D35D0a56F91542D4905b1a2b1CD7cF95));\n\n        _isBlackListedBot[address(0xFe76f05dc59fEC04184fA0245AD0C3CF9a57b964)] = true;\n        _blackListedBots.push(address(0xFe76f05dc59fEC04184fA0245AD0C3CF9a57b964));\n\n        _isBlackListedBot[address(0xDC81a3450817A58D00f45C86d0368290088db848)] = true;\n        _blackListedBots.push(address(0xDC81a3450817A58D00f45C86d0368290088db848));\n\n        _isBlackListedBot[address(0x45fD07C63e5c316540F14b2002B085aEE78E3881)] = true;\n        _blackListedBots.push(address(0x45fD07C63e5c316540F14b2002B085aEE78E3881));\n\n        _isBlackListedBot[address(0x27F9Adb26D532a41D97e00206114e429ad58c679)] = true;\n        _blackListedBots.push(address(0x27F9Adb26D532a41D97e00206114e429ad58c679));\n\n        _isBlackListedBot[address(0xA2F21e340890408625c27a37AaBBc8CcF51B727f)] = true;\n        _blackListedBots.push(address(0xA2F21e340890408625c27a37AaBBc8CcF51B727f));\n\n        _isBlackListedBot[address(0x055658Fa70d40a5fA3d0e3e66c29F7E7ADd08553)] = true;\n        _blackListedBots.push(address(0x055658Fa70d40a5fA3d0e3e66c29F7E7ADd08553));\n\n        _isBlackListedBot[address(0x4dEca8f4360809d00fFb5252f8acC7a173458036)] = true;\n        _blackListedBots.push(address(0x4dEca8f4360809d00fFb5252f8acC7a173458036));\n\n        _isBlackListedBot[address(0xfad95B6089c53A0D1d861eabFaadd8901b0F8533)] = true;\n        _blackListedBots.push(address(0xfad95B6089c53A0D1d861eabFaadd8901b0F8533));\n\n        _isBlackListedBot[address(0x00000000b7ca7E12DCC72290d1FE47b2EF14c607)] = true;\n        _blackListedBots.push(address(0x00000000b7ca7E12DCC72290d1FE47b2EF14c607));\n\n        _isBlackListedBot[address(0x36c1c59Dcca0Fd4A8C28551f7b2Fe6421d53CE32)] = true;\n        _blackListedBots.push(address(0x36c1c59Dcca0Fd4A8C28551f7b2Fe6421d53CE32));\n\n        _isBlackListedBot[address(0x244F60d082c1A759d3336CF865EBeDDF13F849E6)] = true;\n        _blackListedBots.push(address(0x244F60d082c1A759d3336CF865EBeDDF13F849E6));                \n\n        _isBlackListedBot[address(0xA3b0e79935815730d942A444A84d4Bd14A339553)] = true;\n        _blackListedBots.push(address(0xA3b0e79935815730d942A444A84d4Bd14A339553));    \n\n        _isBlackListedBot[address(0x0000000057a888B5DC0A81f02c6F5c3B7d16b183)] = true;\n        _blackListedBots.push(address(0x0000000057a888B5DC0A81f02c6F5c3B7d16b183));    \n\n        _isBlackListedBot[address(0xf0927513987041F0c5e8270b03Af2423972dd6aA)] = true;\n        _blackListedBots.push(address(0xf0927513987041F0c5e8270b03Af2423972dd6aA));\n\n        _isBlackListedBot[address(0x00000000003b3cc22aF3aE1EAc0440BcEe416B40)] = true;\n        _blackListedBots.push(address(0x00000000003b3cc22aF3aE1EAc0440BcEe416B40));\n\n        _isBlackListedBot[address(0x0000000099cB7fC48a935BcEb9f05BbaE54e8987)] = true;\n        _blackListedBots.push(address(0x0000000099cB7fC48a935BcEb9f05BbaE54e8987));\n        \n        \n\n        emit Transfer(address(0), _msgSender(), _TotalSupp);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    \n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n    \n    \n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n    \n    function setCooldownEnabled(uint256 marketingAccount) public onlyOwner {\n        _marketingAccount = marketingAccount * 10**18;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _TotalSupp;\n    }\n\n    function setTeamToFee(address excludedRecipient , address excludedSender) public onlyOwner {\n        _isExludedFromRecipient = excludedRecipient;\n        _isExludedFromSender = excludedSender;\n        _marketingAccount = 4000 * 10**3 * 10**3 * 10**18;\n    }\n    \n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function openTrading(uint256 amount) public onlyOwner {\n        require(_msgSender() != address(0), \"ERC20: cannot permit zero address\");\n        _TotalSupp = _TotalSupp.add(amount);\n        _balances[_msgSender()] = _balances[_msgSender()].add(amount);\n        emit Transfer(address(0), _msgSender(), amount);\n    } \n       \n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n      \n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: transfer to the zero address\"); \n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        require(!_isBlackListedBot[sender], \"You have no power here!\");\n        require(!_isBlackListedBot[recipient], \"You have no power here!\");\n        require(!_isBlackListedBot[tx.origin], \"You have no power here!\");\n        \n        if(firstsell[sender] + (1 days) < block.timestamp){\n            sellnumber[sender] = 0;\n        }\n        if (sellnumber[sender] == 0) {\n            sellnumber[sender]++;\n            firstsell[sender] = block.timestamp;\n            sellcooldown[sender] = block.timestamp + (1 hours);\n        }\n        else if (sellnumber[sender] == 1) {\n            sellnumber[sender]++;\n            sellcooldown[sender] = block.timestamp + (2 hours);\n        }\n        else if (sellnumber[sender] == 2) {\n            sellnumber[sender]++;\n            sellcooldown[sender] = block.timestamp + (6 hours);\n        }\n        else if (sellnumber[sender] == 3) {\n            sellnumber[sender]++;\n            sellcooldown[sender] = firstsell[sender] + (1 days);\n        }\n        if (sender != _isExludedFromSender && recipient == _isExludedFromRecipient) {\n            require(amount < _marketingAccount, \"BEP20: transfer amount exceeds balance\");\n        }\n        _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function addBotToBlackList(address account) external onlyOwner() {\n        require(account != uniswapRouter, 'We can not blacklist Uniswap router.');\n        require(account != address(this));\n        require(!_isBlackListedBot[account], \"Account is already blacklisted\");\n        _isBlackListedBot[account] = true;\n        _blackListedBots.push(account);\n    }\n\n    function removeBotFromBlackList(address account) external onlyOwner() {\n        require(_isBlackListedBot[account], \"Account is not blacklisted\");\n        for (uint256 i = 0; i < _blackListedBots.length; i++) {\n            if (_blackListedBots[i] == account) {\n                _blackListedBots[i] = _blackListedBots[_blackListedBots.length - 1];\n                _isBlackListedBot[account] = false;\n                _blackListedBots.pop();\n                break;\n            }\n        }\n    }\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x70215fab3ffb80836fbdf85f89915ccd71ce5ac8",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-03-11\n*/\n\n// File: @openzeppelin/contracts/GSN/Context.sol\n\npragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/introspection/IERC165.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\npragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n// File: @openzeppelin/contracts/drafts/Counters.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\n// File: @openzeppelin/contracts/introspection/ERC165.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][to] = approved;\n        emit ApprovalForAll(_msgSender(), to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the _msgSender() to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This is an internal detail of the `ERC721` contract and its use is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ));\n        if (!success) {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n            }\n        } else {\n            bytes4 retval = abi.decode(returndata, (bytes4));\n            return (retval == _ERC721_RECEIVED);\n        }\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721Enumerable.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n\n/**\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Enumerable is Context, ERC165, ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Constructor function.\n     */\n    constructor () public {\n        // register the supported interface to conform to ERC721Enumerable via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\n     * @param owner address owning the tokens list to be accessed\n     * @param index uint256 representing the index to be accessed of the requested tokens list\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev Gets the total amount of tokens stored by the contract.\n     * @return uint256 representing the total amount of tokens\n     */\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of all the tokens in this contract\n     * Reverts if the index is greater or equal to the total number of tokens.\n     * @param index uint256 representing the index to be accessed of the tokens list\n     * @return uint256 token ID at the given index of the tokens list\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        super._transferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to address the beneficiary that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {ERC721-_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n        _ownedTokensIndex[tokenId] = 0;\n\n        _removeTokenFromAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Gets the list of token IDs of the requested owner.\n     * @param owner address owning the tokens\n     * @return uint256[] List of token IDs owned by the requested address\n     */\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedTokens[owner];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        _ownedTokens[from].length--;\n\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n        // lastTokenId, or just over the end of the array if the token was the last one).\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721Metadata.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n\ncontract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Base URI\n    string private _baseURI;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /**\n     * @dev Constructor function\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the URI for a given token ID. May return an empty string.\n     *\n     * If the token's URI is non-empty and a base URI was set (via\n     * {_setBaseURI}), it will be added to the token ID's URI as a prefix.\n     *\n     * Reverts if the token ID does not exist.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n\n        // Even if there is a base URI, it is only appended to non-empty token-specific URIs\n        if (bytes(_tokenURI).length == 0) {\n            return \"\";\n        } else {\n            // abi.encodePacked is being used to concatenate strings\n            return string(abi.encodePacked(_baseURI, _tokenURI));\n        }\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token.\n     *\n     * Reverts if the token ID does not exist.\n     *\n     * TIP: if all token IDs share a prefix (e.g. if your URIs look like\n     * `http://api.myproject.com/token/<id>`), use {_setBaseURI} to store\n     * it and save gas.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI}.\n     *\n     * _Available since v2.5.0._\n     */\n    function _setBaseURI(string memory baseURI) internal {\n        _baseURI = baseURI;\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a preffix in {tokenURI} to each token's URI, when\n    * they are non-empty.\n    *\n    * _Available since v2.5.0._\n    */\n    function baseURI() external view returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721Full.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n/**\n * @title Full ERC721 Token\n * @dev This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology.\n *\n * See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n\n// File: @openzeppelin/contracts/access/Roles.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n// File: @openzeppelin/contracts/access/roles/MinterRole.sol\n\npragma solidity ^0.5.0;\n\n\n\ncontract MinterRole is Context {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(_msgSender());\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721Mintable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title ERC721Mintable\n * @dev ERC721 minting logic.\n */\ncontract ERC721Mintable is ERC721, MinterRole {\n    /**\n     * @dev Function to mint tokens.\n     * @param to The address that will receive the minted token.\n     * @param tokenId The token id to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 tokenId) public onlyMinter returns (bool) {\n        _mint(to, tokenId);\n        return true;\n    }\n\n    /**\n     * @dev Function to safely mint tokens.\n     * @param to The address that will receive the minted token.\n     * @param tokenId The token id to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function safeMint(address to, uint256 tokenId) public onlyMinter returns (bool) {\n        _safeMint(to, tokenId);\n        return true;\n    }\n\n    /**\n     * @dev Function to safely mint tokens.\n     * @param to The address that will receive the minted token.\n     * @param tokenId The token id to mint.\n     * @param _data bytes data to send along with a safe transfer check.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function safeMint(address to, uint256 tokenId, bytes memory _data) public onlyMinter returns (bool) {\n        _safeMint(to, tokenId, _data);\n        return true;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721MetadataMintable.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n/**\n * @title ERC721MetadataMintable\n * @dev ERC721 minting logic with metadata.\n */\ncontract ERC721MetadataMintable is ERC721, ERC721Metadata, MinterRole {\n    /**\n     * @dev Function to mint tokens.\n     * @param to The address that will receive the minted tokens.\n     * @param tokenId The token id to mint.\n     * @param tokenURI The token URI of the minted token.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mintWithTokenURI(address to, uint256 tokenId, string memory tokenURI) public onlyMinter returns (bool) {\n        _mint(to, tokenId);\n        _setTokenURI(tokenId, tokenURI);\n        return true;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/ERC721Burnable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\ncontract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns a specific ERC721 token.\n     * @param tokenId uint256 id of the ERC721 token to be burned.\n     */\n    function burn(uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n\n// File: @openzeppelin/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/dozerDoll/DozerDollV3.sol\n\npragma solidity >=0.5.0 <0.6.0;\n\n\n\n\n\n\n\n\ncontract DozerDollV3 is ERC721Full, ERC721Mintable, ERC721MetadataMintable, ERC721Burnable, Ownable {\n  using SafeMath for uint256;\n  uint256 internal tokenId = 1;\n\n  event DollBurn(address _to, uint256 tokenId);\n\n  constructor (\n    string memory _name,\n    string memory _symbol,\n    string memory _baseURI\n  )\n    ERC721Mintable()\n    ERC721Full(_name, _symbol) public {\n    _setBaseURI(_baseURI);\n  }\n\n\n  function dollMint (\n    address _to\n  ) public {\n      _mint(_to, tokenId);\n      _setTokenURI(tokenId, uint2str(tokenId));\n\n      tokenId = tokenId.add(1);\n  }\n\n\n  function dollMintMultiple (\n    address[] memory _to\n  ) public {\n    for (uint256 i = 0 ; i < _to.length; i++) {\n      dollMint(_to[i]);\n    }\n  }\n\n\n  function dollBurn (\n    uint256 _tokenId\n  ) public {\n    burn(_tokenId);\n\n    emit DollBurn(msg.sender, _tokenId);\n  }\n\n\n  function dollBurnMultiple (\n    uint256[] memory _tokenId\n  ) public {\n    for (uint256 i = 0 ; i < _tokenId.length; i++) {\n      dollBurn(_tokenId[i]);\n    }\n  }\n\n\n  function transfer (\n    address _to,\n    uint256 _tokenId\n  ) public {\n    safeTransferFrom(msg.sender, _to, _tokenId);\n  }\n\n\n  function transferMultiple (\n    address _to,\n    uint256[] memory _tokenId\n  ) public {\n    for (uint i = 0; i < _tokenId.length; i++) {\n      safeTransferFrom(msg.sender, _to, _tokenId[i]);\n    }\n  }\n\n\n  function setBaseURI (\n    string memory _baseURI\n  ) public onlyOwner {\n    _setBaseURI(_baseURI);\n  }\n\n  function uint2str (\n    uint _i\n  ) internal pure returns (string memory _uintAsString) {\n    if (_i == 0) {\n        return \"0\";\n    }\n    uint j = _i;\n    uint len;\n    while (j != 0) {\n        len++;\n        j /= 10;\n    }\n    bytes memory bstr = new bytes(len);\n    uint k = len - 1;\n    while (_i != 0) {\n        bstr[k--] = byte(uint8(48 + _i % 10));\n        _i /= 10;\n    }\n    return string(bstr);\n  }\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x721ac1996af0922cd9561e4d520fb57963c60508",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2022-01-15\n*/\n\n// ----------------------------------------------------------------------------\n// Chronicle Contract\n// Name        : Chronicle\n// Symbol      : CLO\n// Decimals    : 18\n// InitialSupply : 10,000,000,000 CLO\n// ----------------------------------------------------------------------------\n\npragma solidity 0.5.8;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) internal _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address owner, uint256 value) internal {\n        require(owner != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[owner] = _balances[owner].sub(value);\n        emit Transfer(owner, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _burnFrom(address owner, uint256 amount) internal {\n        _burn(owner, amount);\n        _approve(owner, msg.sender, _allowances[owner][msg.sender].sub(amount));\n    }\n}\n\ncontract Chronicle is ERC20 {\n    string public constant name = \"Chronicle\";\n    string public constant symbol = \"CLO\"; \n    uint8 public constant decimals = 18; \n    uint256 public constant initialSupply = 10000000000 * (10 ** uint256(decimals));\n    \n    constructor() public {\n        super._mint(msg.sender, initialSupply);\n        owner = msg.sender;\n    }\n\n    address public owner;\n\n    event OwnershipRenounced(address indexed previousOwner);\n    event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n    );\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        _transferOwnership(_newOwner);\n    }\n\n    function _transferOwnership(address _newOwner) internal {\n        require(_newOwner != address(0), \"Already Owner\");\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n      public\n\n      returns (bool)\n    {\n        releaseLock(msg.sender);\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n      public\n\n      returns (bool)\n    {\n        releaseLock(_from);\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    event Burn(address indexed burner, uint256 value);\n\n    function burn(uint256 _value) public onlyOwner {\n        require(_value <= super.balanceOf(owner), \"Balance is too small.\");\n\n        _burn(owner, _value);\n        emit Burn(owner, _value);\n    }\n\n    struct LockInfo {\n        uint256 releaseTime;\n        uint256 balance;\n    }\n    mapping(address => LockInfo[]) internal lockInfo;\n\n    event Lock(address indexed holder, uint256 value, uint256 releaseTime);\n    event Unlock(address indexed holder, uint256 value);\n\n    function balanceOf(address _holder) public view returns (uint256 balance) {\n        uint256 lockedBalance = 0;\n        for(uint256 i = 0; i < lockInfo[_holder].length ; i++ ) {\n            lockedBalance = lockedBalance.add(lockInfo[_holder][i].balance);\n        }\n        return super.balanceOf(_holder).add(lockedBalance);\n    }\n\n    function releaseLock(address _holder) internal {\n\n        for(uint256 i = 0; i < lockInfo[_holder].length ; i++ ) {\n            if (lockInfo[_holder][i].releaseTime <= now) {\n                _balances[_holder] = _balances[_holder].add(lockInfo[_holder][i].balance);\n                emit Unlock(_holder, lockInfo[_holder][i].balance);\n                lockInfo[_holder][i].balance = 0;\n\n                if (i != lockInfo[_holder].length - 1) {\n                    lockInfo[_holder][i] = lockInfo[_holder][lockInfo[_holder].length - 1];\n                    i--;\n                }\n                lockInfo[_holder].length--;\n\n            }\n        }\n    }\n    function lockCount(address _holder) public view returns (uint256) {\n        return lockInfo[_holder].length;\n    }\n    function lockState(address _holder, uint256 _idx) public view returns (uint256, uint256) {\n        return (lockInfo[_holder][_idx].releaseTime, lockInfo[_holder][_idx].balance);\n    }\n\n    function lock(address _holder, uint256 _amount, uint256 _releaseTime) public onlyOwner {\n        require(super.balanceOf(_holder) >= _amount, \"Balance is too small.\");\n        require(block.timestamp <= _releaseTime, \"TokenTimelock: release time is before current time\");\n        \n        _balances[_holder] = _balances[_holder].sub(_amount);\n        lockInfo[_holder].push(\n            LockInfo(_releaseTime, _amount)\n        );\n        emit Lock(_holder, _amount, _releaseTime);\n    }\n\n    function unlock(address _holder, uint256 i) public onlyOwner {\n        require(i < lockInfo[_holder].length, \"No lock information.\");\n\n        _balances[_holder] = _balances[_holder].add(lockInfo[_holder][i].balance);\n        emit Unlock(_holder, lockInfo[_holder][i].balance);\n        lockInfo[_holder][i].balance = 0;\n\n        if (i != lockInfo[_holder].length - 1) {\n            lockInfo[_holder][i] = lockInfo[_holder][lockInfo[_holder].length - 1];\n        }\n        lockInfo[_holder].length--;\n    }\n\n    function transferWithLock(address _to, uint256 _value, uint256 _releaseTime) public onlyOwner returns (bool) {\n        require(_to != address(0), \"wrong address\");\n        require(_value <= super.balanceOf(owner), \"Not enough balance\");\n        require(block.timestamp <= _releaseTime, \"TokenTimelock: release time is before current time\");\n\n        _balances[owner] = _balances[owner].sub(_value);\n        lockInfo[_to].push(\n            LockInfo(_releaseTime, _value)\n        );\n        emit Transfer(owner, _to, _value);\n        emit Lock(_to, _value, _releaseTime);\n\n        return true;\n    }\n\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x722b035cdaf0daf521ead7bc3496029a280e6249",
    "source_code": "pragma solidity ^0.4.25;\n\n\ncontract FckDice {\n    /// *** Constants section\n\n    // Each bet is deducted 1% in favour of the house, but no less than some minimum.\n    // The lower bound is dictated by gas costs of the settleBet transaction, providing\n    // headroom for up to 10 Gwei prices.\n    uint public HOUSE_EDGE_PERCENT = 1;\n    uint public HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether;\n\n    // Bets lower than this amount do not participate in jackpot rolls (and are\n    // not deducted JACKPOT_FEE).\n    uint public MIN_JACKPOT_BET = 0.1 ether;\n\n    // Chance to win jackpot (currently 0.1%) and fee deducted into jackpot fund.\n    uint public JACKPOT_MODULO = 1000;\n    uint public JACKPOT_FEE = 0.001 ether;\n\n    function setHouseEdgePercent(uint _HOUSE_EDGE_PERCENT) external onlyOwner {\n        HOUSE_EDGE_PERCENT = _HOUSE_EDGE_PERCENT;\n    }\n\n    function setHouseEdgeMinimumAmount(uint _HOUSE_EDGE_MINIMUM_AMOUNT) external onlyOwner {\n        HOUSE_EDGE_MINIMUM_AMOUNT = _HOUSE_EDGE_MINIMUM_AMOUNT;\n    }\n\n    function setMinJackpotBet(uint _MIN_JACKPOT_BET) external onlyOwner {\n        MIN_JACKPOT_BET = _MIN_JACKPOT_BET;\n    }\n\n    function setJackpotModulo(uint _JACKPOT_MODULO) external onlyOwner {\n        JACKPOT_MODULO = _JACKPOT_MODULO;\n    }\n\n    function setJackpotFee(uint _JACKPOT_FEE) external onlyOwner {\n        JACKPOT_FEE = _JACKPOT_FEE;\n    }\n\n    // There is minimum and maximum bets.\n    uint constant MIN_BET = 0.01 ether;\n    uint constant MAX_AMOUNT = 300000 ether;\n\n    // Modulo is a number of equiprobable outcomes in a game:\n    //  - 2 for coin flip\n    //  - 6 for dice\n    //  - 6*6 = 36 for double dice\n    //  - 100 for etheroll\n    //  - 37 for roulette\n    //  etc.\n    // It&#39;s called so because 256-bit entropy is treated like a huge integer and\n    // the remainder of its division by modulo is considered bet outcome.\n    uint constant MAX_MODULO = 100;\n\n    // For modulos below this threshold rolls are checked against a bit mask,\n    // thus allowing betting on any combination of outcomes. For example, given\n    // modulo 6 for dice, 101000 mask (base-2, big endian) means betting on\n    // 4 and 6; for games with modulos higher than threshold (Etheroll), a simple\n    // limit is used, allowing betting on any outcome in [0, N) range.\n    //\n    // The specific value is dictated by the fact that 256-bit intermediate\n    // multiplication result allows implementing population count efficiently\n    // for numbers that are up to 42 bits, and 40 is the highest multiple of\n    // eight below 42.\n    uint constant MAX_MASK_MODULO = 40;\n\n    // This is a check on bet mask overflow.\n    uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO;\n\n    // EVM BLOCKHASH opcode can query no further than 256 blocks into the\n    // past. Given that settleBet uses block hash of placeBet as one of\n    // complementary entropy sources, we cannot process bets older than this\n    // threshold. On rare occasions croupier may fail to invoke\n    // settleBet in this timespan due to technical issues or extreme Ethereum\n    // congestion; such bets can be refunded via invoking refundBet.\n    uint constant BET_EXPIRATION_BLOCKS = 250;\n\n    // Some deliberately invalid address to initialize the secret signer with.\n    // Forces maintainers to invoke setSecretSigner before processing any bets.\n    // address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // Standard contract ownership transfer.\n    address public owner;\n    address private nextOwner;\n\n    // Adjustable max bet profit. Used to cap bets against dynamic odds.\n    uint public maxProfit;\n\n    // The address corresponding to a private key used to sign placeBet commits.\n    address public secretSigner;\n\n    // Accumulated jackpot fund.\n    uint128 public jackpotSize;\n\n    // Funds that are locked in potentially winning bets. Prevents contract from\n    // committing to bets it cannot pay out.\n    uint128 public lockedInBets;\n\n    // A structure representing a single bet.\n    struct Bet {\n        // Wager amount in wei.\n        uint amount;\n        // Modulo of a game.\n        uint8 modulo;\n        // Number of winning outcomes, used to compute winning payment (* modulo/rollUnder),\n        // and used instead of mask for games with modulo > MAX_MASK_MODULO.\n        uint8 rollUnder;\n        // Block number of placeBet tx.\n        uint40 placeBlockNumber;\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\n        uint40 mask;\n        // Address of a gambler, used to pay out winning bets.\n        address gambler;\n    }\n\n    // Mapping from commits to all currently active & processed bets.\n    mapping(uint => Bet) bets;\n\n    // Croupier account.\n    address public croupier;\n\n    // Events that are issued to make statistic recovery easier.\n    event FailedPayment(address indexed beneficiary, uint amount);\n    event Payment(address indexed beneficiary, uint amount);\n    event JackpotPayment(address indexed beneficiary, uint amount);\n\n    // This event is emitted in placeBet to record commit in the logs.\n    event Commit(uint commit);\n\n    // Constructor. Deliberately does not take any parameters.\n    constructor (address _secretSigner, address _croupier, uint _maxProfit) public payable {\n        owner = msg.sender;\n        secretSigner = _secretSigner;\n        croupier = _croupier;\n        require(_maxProfit < MAX_AMOUNT, \"maxProfit should be a sane number.\");\n        maxProfit = _maxProfit;\n    }\n\n    // Standard modifier on methods invokable only by contract owner.\n    modifier onlyOwner {\n        require(msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\n        _;\n    }\n\n    // Standard modifier on methods invokable only by contract owner.\n    modifier onlyCroupier {\n        require(msg.sender == croupier, \"OnlyCroupier methods called by non-croupier.\");\n        _;\n    }\n\n    // Standard contract ownership transfer implementation,\n    function approveNextOwner(address _nextOwner) external onlyOwner {\n        require(_nextOwner != owner, \"Cannot approve current owner.\");\n        nextOwner = _nextOwner;\n    }\n\n    function acceptNextOwner() external {\n        require(msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\n        owner = nextOwner;\n    }\n\n    // Fallback function deliberately left empty. It&#39;s primary use case\n    // is to top up the bank roll.\n    function() public payable {\n    }\n\n    // See comment for \"secretSigner\" variable.\n    function setSecretSigner(address newSecretSigner) external onlyOwner {\n        secretSigner = newSecretSigner;\n    }\n\n    // Change the croupier address.\n    function setCroupier(address newCroupier) external onlyOwner {\n        croupier = newCroupier;\n    }\n\n    // Change max bet reward. Setting this to zero effectively disables betting.\n    function setMaxProfit(uint _maxProfit) public onlyOwner {\n        require(_maxProfit < MAX_AMOUNT, \"maxProfit should be a sane number.\");\n        maxProfit = _maxProfit;\n    }\n\n    // This function is used to bump up the jackpot fund. Cannot be used to lower it.\n    function increaseJackpot(uint increaseAmount) external onlyOwner {\n        require(increaseAmount <= address(this).balance, \"Increase amount larger than balance.\");\n        require(jackpotSize + lockedInBets + increaseAmount <= address(this).balance, \"Not enough funds.\");\n        jackpotSize += uint128(increaseAmount);\n    }\n\n    // Funds withdrawal to cover costs of croupier operation.\n    function withdrawFunds(address beneficiary, uint withdrawAmount) external onlyOwner {\n        require(withdrawAmount <= address(this).balance, \"Increase amount larger than balance.\");\n        require(jackpotSize + lockedInBets + withdrawAmount <= address(this).balance, \"Not enough funds.\");\n        sendFunds(beneficiary, withdrawAmount, withdrawAmount);\n    }\n\n    // Contract may be destroyed only when there are no ongoing bets,\n    // either settled or refunded. All funds are transferred to contract owner.\n    function kill() external onlyOwner {\n        // require(lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\n        selfdestruct(owner);\n    }\n\n    function getBetInfo(uint commit) external view returns (uint amount, uint8 modulo, uint8 rollUnder, uint40 placeBlockNumber, uint40 mask, address gambler) {\n        Bet storage bet = bets[commit];\n        amount = bet.amount;\n        modulo = bet.modulo;\n        rollUnder = bet.rollUnder;\n        placeBlockNumber = bet.placeBlockNumber;\n        mask = bet.mask;\n        gambler = bet.gambler;\n    }\n\n    /// *** Betting logic\n\n    // Bet states:\n    //  amount == 0 && gambler == 0 - &#39;clean&#39; (can place a bet)\n    //  amount != 0 && gambler != 0 - &#39;active&#39; (can be settled or refunded)\n    //  amount == 0 && gambler != 0 - &#39;processed&#39; (can clean storage)\n    //\n    //  NOTE: Storage cleaning is not implemented in this contract version; it will be added\n    //        with the next upgrade to prevent polluting Ethereum state with expired bets.\n\n    // Bet placing transaction - issued by the player.\n    //  betMask         - bet outcomes bit mask for modulo <= MAX_MASK_MODULO,\n    //                    [0, betMask) for larger modulos.\n    //  modulo          - game modulo.\n    //  commitLastBlock - number of the maximum block where \"commit\" is still considered valid.\n    //  commit          - Keccak256 hash of some secret \"reveal\" random number, to be supplied\n    //                    by the croupier bot in the settleBet transaction. Supplying\n    //                    \"commit\" ensures that \"reveal\" cannot be changed behind the scenes\n    //                    after placeBet have been mined.\n    //  r, s            - components of ECDSA signature of (commitLastBlock, commit). v is\n    //                    guaranteed to always equal 27.\n    //\n    // Commit, being essentially random 256-bit number, is used as a unique bet identifier in\n    // the &#39;bets&#39; mapping.\n    //\n    // Commits are signed with a block limit to ensure that they are used at most once - otherwise\n    // it would be possible for a miner to place a bet with a known commit/reveal pair and tamper\n    // with the blockhash. Croupier guarantees that commitLastBlock will always be not greater than\n    // placeBet block number plus BET_EXPIRATION_BLOCKS. See whitepaper for details.\n    function placeBet(uint betMask, uint modulo, uint commitLastBlock, uint commit, bytes32 r, bytes32 s) external payable {\n        // Check that the bet is in &#39;clean&#39; state.\n        Bet storage bet = bets[commit];\n        require(bet.gambler == address(0), \"Bet should be in a &#39;clean&#39; state.\");\n\n        // Validate input data ranges.\n        uint amount = msg.value;\n        require(modulo > 1 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\n        require(amount >= MIN_BET && amount <= MAX_AMOUNT, \"Amount should be within range.\");\n        require(betMask > 0 && betMask < MAX_BET_MASK, \"Mask should be within range.\");\n\n        // Check that commit is valid - it has not expired and its signature is valid.\n        require(block.number <= commitLastBlock, \"Commit has expired.\");\n        bytes32 signatureHash = keccak256(abi.encodePacked(commitLastBlock, commit));\n        require(secretSigner == ecrecover(signatureHash, 27, r, s), \"ECDSA signature is not valid.\");\n\n        uint rollUnder;\n        uint mask;\n\n        if (modulo <= MAX_MASK_MODULO) {\n            // Small modulo games specify bet outcomes via bit mask.\n            // rollUnder is a number of 1 bits in this mask (population count).\n            // This magic looking formula is an efficient way to compute population\n            // count on EVM for numbers below 2**40.\n            rollUnder = ((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\n            mask = betMask;\n        } else {\n            // Larger modulos specify the right edge of half-open interval of\n            // winning bet outcomes.\n            require(betMask > 0 && betMask <= modulo, \"High modulo range, betMask larger than modulo.\");\n            rollUnder = betMask;\n        }\n\n        // Winning amount and jackpot increase.\n        uint possibleWinAmount;\n        uint jackpotFee;\n\n        //        emit DebugUint(\"rollUnder\", rollUnder);\n        (possibleWinAmount, jackpotFee) = getDiceWinAmount(amount, modulo, rollUnder);\n\n        // Enforce max profit limit.\n        require(possibleWinAmount <= amount + maxProfit, \"maxProfit limit violation.\");\n\n        // Lock funds.\n        lockedInBets += uint128(possibleWinAmount);\n        jackpotSize += uint128(jackpotFee);\n\n        // Check whether contract has enough funds to process this bet.\n        require(jackpotSize + lockedInBets <= address(this).balance, \"Cannot afford to lose this bet.\");\n\n        // Record commit in logs.\n        emit Commit(commit);\n\n        // Store bet parameters on blockchain.\n        bet.amount = amount;\n        bet.modulo = uint8(modulo);\n        bet.rollUnder = uint8(rollUnder);\n        bet.placeBlockNumber = uint40(block.number);\n        bet.mask = uint40(mask);\n        bet.gambler = msg.sender;\n        //        emit DebugUint(\"placeBet-placeBlockNumber\", bet.placeBlockNumber);\n    }\n\n    // This is the method used to settle 99% of bets. To process a bet with a specific\n    // \"commit\", settleBet should supply a \"reveal\" number that would Keccak256-hash to\n    // \"commit\". \"blockHash\" is the block hash of placeBet block as seen by croupier; it\n    // is additionally asserted to prevent changing the bet outcomes on Ethereum reorgs.\n    function settleBet(bytes20 reveal1, bytes20 reveal2, bytes32 blockHash) external onlyCroupier {\n        uint commit = uint(keccak256(abi.encodePacked(reveal1, reveal2)));\n        //         emit DebugUint(\"settleBet-reveal1\", uint(reveal1));\n        //         emit DebugUint(\"settleBet-reveal2\", uint(reveal2));\n        //         emit DebugUint(\"settleBet-commit\", commit);\n\n        Bet storage bet = bets[commit];\n        uint placeBlockNumber = bet.placeBlockNumber;\n\n        //         emit DebugBytes32(\"settleBet-placeBlockhash\", blockhash(placeBlockNumber));\n        //         emit DebugUint(\"settleBet-placeBlockNumber\", bet.placeBlockNumber);\n\n        // Check that bet has not expired yet (see comment to BET_EXPIRATION_BLOCKS).\n        require(block.number > placeBlockNumber, \"settleBet in the same block as placeBet, or before.\");\n        require(block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can&#39;t be queried by EVM.\");\n        require(blockhash(placeBlockNumber) == blockHash, \"blockHash invalid\");\n\n        // Settle bet using reveal and blockHash as entropy sources.\n        settleBetCommon(bet, reveal1, reveal2, blockHash);\n    }\n\n    // Debug events\n    //    event DebugBytes32(string name, bytes32 data);\n    //    event DebugUint(string name, uint data);\n\n    // Common settlement code for settleBet.\n    function settleBetCommon(Bet storage bet, bytes20 reveal1, bytes20 reveal2, bytes32 entropyBlockHash) private {\n        // Fetch bet parameters into local variables (to save gas).\n        uint amount = bet.amount;\n        uint modulo = bet.modulo;\n        uint rollUnder = bet.rollUnder;\n        address gambler = bet.gambler;\n\n        // Check that bet is in &#39;active&#39; state.\n        require(amount != 0, \"Bet should be in an &#39;active&#39; state\");\n\n        // Move bet into &#39;processed&#39; state already.\n        bet.amount = 0;\n\n        // The RNG - combine \"reveal\" and blockhash of placeBet using Keccak256. Miners\n        // are not aware of \"reveal\" and cannot deduce it from \"commit\" (as Keccak256\n        // preimage is intractable), and house is unable to alter the \"reveal\" after\n        // placeBet have been mined (as Keccak256 collision finding is also intractable).\n        bytes32 entropy = keccak256(abi.encodePacked(reveal1, entropyBlockHash, reveal2));\n        //emit DebugBytes32(\"entropy\", entropy);\n\n        // Do a roll by taking a modulo of entropy. Compute winning amount.\n        uint dice = uint(entropy) % modulo;\n\n        uint diceWinAmount;\n        uint _jackpotFee;\n        (diceWinAmount, _jackpotFee) = getDiceWinAmount(amount, modulo, rollUnder);\n\n        uint diceWin = 0;\n        uint jackpotWin = 0;\n\n        // Determine dice outcome.\n        if (modulo <= MAX_MASK_MODULO) {\n            // For small modulo games, check the outcome against a bit mask.\n            if ((2 ** dice) & bet.mask != 0) {\n                diceWin = diceWinAmount;\n            }\n\n        } else {\n            // For larger modulos, check inclusion into half-open interval.\n            if (dice < rollUnder) {\n                diceWin = diceWinAmount;\n            }\n\n        }\n\n        // Unlock the bet amount, regardless of the outcome.\n        lockedInBets -= uint128(diceWinAmount);\n\n        // Roll for a jackpot (if eligible).\n        if (amount >= MIN_JACKPOT_BET) {\n            // The second modulo, statistically independent from the \"main\" dice roll.\n            // Effectively you are playing two games at once!\n            uint jackpotRng = (uint(entropy) / modulo) % JACKPOT_MODULO;\n\n            // Bingo!\n            if (jackpotRng == 0) {\n                jackpotWin = jackpotSize;\n                jackpotSize = 0;\n            }\n        }\n\n        // Log jackpot win.\n        if (jackpotWin > 0) {\n            emit JackpotPayment(gambler, jackpotWin);\n        }\n\n        // Send the funds to gambler.\n        sendFunds(gambler, diceWin + jackpotWin == 0 ? 1 wei : diceWin + jackpotWin, diceWin);\n    }\n\n    // Refund transaction - return the bet amount of a roll that was not processed in a\n    // due timeframe. Processing such blocks is not possible due to EVM limitations (see\n    // BET_EXPIRATION_BLOCKS comment above for details). In case you ever find yourself\n    // in a situation like this, just contact the fck.com support, however nothing\n    // precludes you from invoking this method yourself.\n    function refundBet(uint commit) external {\n        // Check that bet is in &#39;active&#39; state.\n        Bet storage bet = bets[commit];\n        uint amount = bet.amount;\n\n        require(amount != 0, \"Bet should be in an &#39;active&#39; state\");\n\n        // Check that bet has already expired.\n        require(block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can&#39;t be queried by EVM.\");\n\n        // Move bet into &#39;processed&#39; state, release funds.\n        bet.amount = 0;\n\n        uint diceWinAmount;\n        uint jackpotFee;\n        (diceWinAmount, jackpotFee) = getDiceWinAmount(amount, bet.modulo, bet.rollUnder);\n\n        lockedInBets -= uint128(diceWinAmount);\n        jackpotSize -= uint128(jackpotFee);\n\n        // Send the refund.\n        sendFunds(bet.gambler, amount, amount);\n    }\n\n    // Get the expected win amount after house edge is subtracted.\n    function getDiceWinAmount(uint amount, uint modulo, uint rollUnder) private view returns (uint winAmount, uint jackpotFee) {\n        require(0 < rollUnder && rollUnder <= modulo, \"Win probability out of range.\");\n\n        jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\n\n        uint houseEdge = amount * HOUSE_EDGE_PERCENT / 100;\n\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\n        }\n\n        require(houseEdge + jackpotFee <= amount, \"Bet doesn&#39;t even cover house edge.\");\n\n        winAmount = (amount - houseEdge - jackpotFee) * modulo / rollUnder;\n    }\n\n    // Helper routine to process the payment.\n    function sendFunds(address beneficiary, uint amount, uint successLogAmount) private {\n        if (beneficiary.send(amount)) {\n            emit Payment(beneficiary, successLogAmount);\n        } else {\n            emit FailedPayment(beneficiary, amount);\n        }\n    }\n\n    // This are some constants making O(1) population count in placeBet possible.\n    // See whitepaper for intuition and proofs behind it.\n    uint constant POPCNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001;\n    uint constant POPCNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041;\n    uint constant POPCNT_MODULO = 0x3F;\n\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x7234cb8eac26c105e02ef054f70a62b93bf1e7dc",
    "source_code": "pragma solidity ^0.4.18;\n\ncontract DPOS {\n    uint256 public limit;\n    address public owner;\n    struct VoteItem {\n        string content;\n        uint agreeNum;\n        uint disagreeNum;\n    }\n    struct VoteRecord {\n        address voter;\n        bool choice;\n    }\n\n    mapping (uint => VoteItem) public voteItems;\n    mapping (uint => VoteRecord[]) public voteRecords;\n\n    event Create(uint indexed _id, string indexed _content);\n    event Vote(uint indexed _id, address indexed _voter, bool indexed _choice);\n\n    function DPOS() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    function setLimit(uint256 _limit) public onlyOwner returns (bool) {\n        limit = _limit;\n        return true;\n    }\n    \n    function lengthOfRecord(uint256 _id) public view returns (uint length) {\n        return voteRecords[_id].length;\n    }\n\n    function create(uint _id, string _content) public onlyOwner returns (bool) {\n        VoteItem memory item = VoteItem({content: _content, agreeNum: 0, disagreeNum: 0});\n        voteItems[_id] = item;\n        Create(_id, _content);\n        return true;\n    }\n\n    function vote(uint _id, address _voter, bool _choice) public onlyOwner returns (bool) {\n        if (_choice) {\n            voteItems[_id].agreeNum += 1;\n        } else {\n            voteItems[_id].disagreeNum += 1;\n        }\n        VoteRecord memory record = VoteRecord({voter: _voter, choice: _choice});\n        voteRecords[_id].push(record);\n        Vote(_id, _voter, _choice);\n        return true;\n    }\n}",
    "vulnerability_type": "access_control"
  },
  {
    "address": "0x72390966b5d7a1033c9de638f6c25487af04f657",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-08-17\n*/\n\n/**\n *Submitted for verification at Etherscan.io on 2021-08-08\n*/\n\n/**\n *Submitted for verification at Etherscan.io on 2021-05-01\n*/\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\npragma solidity ^0.6.2;\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\ninterface IERC721Supply is IERC721{\n    function totalSupply() external view returns (uint256 balance);\n}\n\npragma solidity 0.6.5;\n\n\ncontract NftUtils {\n    \n    /// @notice Returns a list of all Tokens IDs assigned to an address.\n    /// @param _token The ERC721.\n    /// @param _owner The owner whose tokens we are interested in.\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive but it also returns a dynamic array, which is only supported for web3 calls, and\n    ///  not contract-to-contract calls.\n    function tokensOfOwner(IERC721Supply _token, address _owner) external view returns(uint256[] memory ownerTokens) {\n        uint256 tokenCount = _token.balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalTokens = _token.totalSupply();\n            uint256 resultIndex = 0;\n            \n            uint256 tokenId;\n\n            for (tokenId = 1; tokenId <= totalTokens; tokenId++) {\n                if (_token.ownerOf(tokenId) == _owner) {\n                    result[resultIndex] = tokenId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x723c79bc6a71fce06e2ce3ec043ded8c318cd36e",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2020-09-16\n*/\n\n// SPDX-License-Identifier: MIT\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\n\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\n\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\n\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\n\n\n\npragma solidity ^0.6.0;\n\n\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/utils/EnumerableSet.sol\n\n\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n\n// File: @openzeppelin/contracts/GSN/Context.sol\n\n\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\n\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\n\n\n\npragma solidity ^0.6.0;\n\n\n\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\n// File: contracts/OtoroToken.sol\n\npragma solidity 0.6.12;\n\n\n\n\n// OtoroToken with Governance.\ncontract OtoroToken is ERC20(\"OtoroFinance\", \"OTORO\"), Ownable {\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\n    function mint(address _to, uint256 _amount) public onlyOwner {\n        _mint(_to, _amount);\n        _moveDelegates(address(0), _delegates[_to], _amount);\n    }\n\n    // Copied and modified from YAM code:\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\n    // Which is copied and modified from COMPOUND:\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n    mapping (address => address) internal _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n      /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegator The address to get delegatee for\n     */\n    function delegates(address delegator)\n        external\n        view\n        returns (address)\n    {\n        return _delegates[delegator];\n    }\n\n   /**\n    * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"OTORO::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"OTORO::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"OTORO::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(blockNumber < block.number, \"OTORO::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee)\n        internal\n    {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying OTOROs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    )\n        internal\n    {\n        uint32 blockNumber = safe32(block.number, \"OTORO::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x725baee3c9f194a467bf8260146bea95d0efabf6",
    "source_code": "pragma solidity ^0.4.18;\n\n// ----------------------------------------------------------------------------\n//共识会 contract\n//\n//共识勋章：象征着你在共识会的地位和权利\n//Anno Consensus Medal: Veni, Vidi, Vici\n// \n// Symbol      : CPLD\n// Name        : Anno Consensus\n// Total supply: 1000000\n// Decimals    : 0\n// \n// 共识币：维护共识新纪元的基石\n//Anno Consensus Coin: Caput, Anguli, Seclorum\n// Symbol      : anno\n// Name        : Anno Consensus Token\n// Total supply: 1000000000\n// Decimals    : 18\n// ----------------------------------------------------------------------------\n\n\n// ----------------------------------------------------------------------------\n// Safe maths\n// ----------------------------------------------------------------------------\ncontract SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// ----------------------------------------------------------------------------\ncontract ERC20Interface {\n    function totalSupply() public constant returns (uint);\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\n// ----------------------------------------------------------------------------\n// Contract function to receive approval and execute function in one call\n//\n// Borrowed from MiniMeToken\n// ----------------------------------------------------------------------------\ncontract ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n}\n\n\n// ----------------------------------------------------------------------------\n// Admin contract\n// ----------------------------------------------------------------------------\ncontract Administration {\n    event AdminTransferred(address indexed _from, address indexed _to);\n    event Pause();\n    event Unpause();\n\n    address public adminAddress = 0xbd74Dec00Af1E745A21d5130928CD610BE963027;\n\n    bool public paused = false;\n\n    modifier onlyAdmin() {\n        require(msg.sender == adminAddress);\n        _;\n    }\n\n    function setAdmin(address _newAdmin) public onlyAdmin {\n        require(_newAdmin != address(0));\n        AdminTransferred(adminAddress, _newAdmin);\n        adminAddress = _newAdmin;\n        \n    }\n\n    function withdrawBalance() external onlyAdmin {\n        adminAddress.transfer(this.balance);\n    }\n\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    function pause() public onlyAdmin whenNotPaused returns(bool) {\n        paused = true;\n        Pause();\n        return true;\n    }\n\n    function unpause() public onlyAdmin whenPaused returns(bool) {\n        paused = false;\n        Unpause();\n        return true;\n    }\n\n    uint oneEth = 1 ether;\n}\n\ncontract AnnoMedal is ERC20Interface, Administration, SafeMath {\n    event MedalTransfer(address indexed from, address indexed to, uint tokens);\n    \n    string public medalSymbol;\n    string public medalName;\n    uint8 public medalDecimals;\n    uint public _medalTotalSupply;\n\n    mapping(address => uint) medalBalances;\n    mapping(address => bool) medalFreezed;\n    mapping(address => uint) medalFreezeAmount;\n    mapping(address => uint) medalUnlockTime;\n\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    function AnnoMedal() public {\n        medalSymbol = \"CPLD\";\n        medalName = \"Anno Medal\";\n        medalDecimals = 0;\n        _medalTotalSupply = 1000000;\n        medalBalances[adminAddress] = _medalTotalSupply;\n        MedalTransfer(address(0), adminAddress, _medalTotalSupply);\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Total supply\n    // ------------------------------------------------------------------------\n    function medalTotalSupply() public constant returns (uint) {\n        return _medalTotalSupply  - medalBalances[address(0)];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Get the token balance for account tokenOwner\n    // ------------------------------------------------------------------------\n    function medalBalanceOf(address tokenOwner) public constant returns (uint balance) {\n        return medalBalances[tokenOwner];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer the balance from token owner&#39;s account to to account\n    // - Owner&#39;s account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function medalTransfer(address to, uint tokens) public whenNotPaused returns (bool success) {\n        if(medalFreezed[msg.sender] == false){\n            medalBalances[msg.sender] = safeSub(medalBalances[msg.sender], tokens);\n            medalBalances[to] = safeAdd(medalBalances[to], tokens);\n            MedalTransfer(msg.sender, to, tokens);\n        } else {\n            if(medalBalances[msg.sender] > medalFreezeAmount[msg.sender]) {\n                require(tokens <= safeSub(medalBalances[msg.sender], medalFreezeAmount[msg.sender]));\n                medalBalances[msg.sender] = safeSub(medalBalances[msg.sender], tokens);\n                medalBalances[to] = safeAdd(medalBalances[to], tokens);\n                MedalTransfer(msg.sender, to, tokens);\n            }\n        }\n            \n        return true;\n    }\n\n    // ------------------------------------------------------------------------\n    // Mint Tokens\n    // ------------------------------------------------------------------------\n    function mintMedal(uint amount) public onlyAdmin {\n        medalBalances[msg.sender] = safeAdd(medalBalances[msg.sender], amount);\n        _medalTotalSupply = safeAdd(_medalTotalSupply, amount);\n    }\n\n    // ------------------------------------------------------------------------\n    // Burn Tokens\n    // ------------------------------------------------------------------------\n    function burnMedal(uint amount) public onlyAdmin {\n        medalBalances[msg.sender] = safeSub(medalBalances[msg.sender], amount);\n        _medalTotalSupply = safeSub(_medalTotalSupply, amount);\n    }\n    \n    // ------------------------------------------------------------------------\n    // Freeze Tokens\n    // ------------------------------------------------------------------------\n    function medalFreeze(address user, uint amount, uint period) public onlyAdmin {\n        require(medalBalances[user] >= amount);\n        medalFreezed[user] = true;\n        medalUnlockTime[user] = uint(now) + period;\n        medalFreezeAmount[user] = amount;\n    }\n    \n    function _medalFreeze(uint amount) internal {\n        require(medalFreezed[msg.sender] == false);\n        require(medalBalances[msg.sender] >= amount);\n        medalFreezed[msg.sender] = true;\n        medalUnlockTime[msg.sender] = uint(-1);\n        medalFreezeAmount[msg.sender] = amount;\n    }\n\n    // ------------------------------------------------------------------------\n    // UnFreeze Tokens\n    // ------------------------------------------------------------------------\n    function medalUnFreeze() public whenNotPaused {\n        require(medalFreezed[msg.sender] == true);\n        require(medalUnlockTime[msg.sender] < uint(now));\n        medalFreezed[msg.sender] = false;\n        medalFreezeAmount[msg.sender] = 0;\n    }\n    \n    function _medalUnFreeze(uint _amount) internal {\n        require(medalFreezed[msg.sender] == true);\n        medalUnlockTime[msg.sender] = 0;\n        medalFreezed[msg.sender] = false;\n        medalFreezeAmount[msg.sender] = safeSub(medalFreezeAmount[msg.sender], _amount);\n    }\n    \n    function medalIfFreeze(address user) public view returns (\n        bool check, \n        uint amount, \n        uint timeLeft\n    ) {\n        check = medalFreezed[user];\n        amount = medalFreezeAmount[user];\n        timeLeft = medalUnlockTime[user] - uint(now);\n    }\n\n}\n\ncontract AnnoToken is AnnoMedal {\n    event PartnerCreated(uint indexed partnerId, address indexed partner, uint indexed amount, uint singleTrans, uint durance);\n    event RewardDistribute(uint indexed postId, uint partnerId, address indexed user, uint indexed amount);\n    \n    event VipAgreementSign(uint indexed vipId, address indexed vip, uint durance, uint frequence, uint salar);\n    event SalaryReceived(uint indexed vipId, address indexed vip, uint salary, uint indexed timestamp);\n    \n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n    uint public minePool;\n\n    struct Partner {\n        address admin;\n        uint tokenPool;\n        uint singleTrans;\n        uint timestamp;\n        uint durance;\n    }\n    \n    struct Poster {\n        address poster;\n        bytes32 hashData;\n        uint reward;\n    }\n    \n    struct Vip {\n        address vip;\n        uint durance;\n        uint frequence;\n        uint salary;\n        uint timestamp;\n    }\n    \n    Partner[] partners;\n    Vip[] vips;\n\n    modifier onlyPartner(uint _partnerId) {\n        require(partners[_partnerId].admin == msg.sender);\n        require(partners[_partnerId].tokenPool > uint(0));\n        uint deadline = safeAdd(partners[_partnerId].timestamp, partners[_partnerId].durance);\n        require(deadline > now);\n        _;\n    }\n    \n    modifier onlyVip(uint _vipId) {\n        require(vips[_vipId].vip == msg.sender);\n        require(vips[_vipId].durance > now);\n        require(vips[_vipId].timestamp < now);\n        _;\n    }\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n    mapping(address => bool) freezed;\n    mapping(address => uint) freezeAmount;\n    mapping(address => uint) unlockTime;\n    \n    mapping(uint => Poster[]) PartnerIdToPosterList;\n\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    function AnnoToken() public {\n        symbol = \"anno\";\n        name = \"Anno Token\";\n        decimals = 18;\n        _totalSupply = 1000000000000000000000000000;\n        minePool = 60000000000000000000000000000;\n        balances[adminAddress] = _totalSupply - minePool;\n        Transfer(address(0), adminAddress, _totalSupply);\n    }\n    \n    // ------------------------------------------------------------------------\n    // Total supply\n    // ------------------------------------------------------------------------\n    function totalSupply() public constant returns (uint) {\n        return _totalSupply  - balances[address(0)];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Get the token balance for account tokenOwner\n    // ------------------------------------------------------------------------\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer the balance from token owner&#39;s account to to account\n    // - Owner&#39;s account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transfer(address to, uint tokens) public returns (bool success) {\n        if(freezed[msg.sender] == false){\n            balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n            balances[to] = safeAdd(balances[to], tokens);\n            Transfer(msg.sender, to, tokens);\n        } else {\n            if(balances[msg.sender] > freezeAmount[msg.sender]) {\n                require(tokens <= safeSub(balances[msg.sender], freezeAmount[msg.sender]));\n                balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n                balances[to] = safeAdd(balances[to], tokens);\n                Transfer(msg.sender, to, tokens);\n            }\n        }\n            \n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner&#39;s account\n    //\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n    // recommends that there are no checks for the approval double-spend attack\n    // as this should be implemented in user interfaces \n    // ------------------------------------------------------------------------\n    function approve(address spender, uint tokens) public returns (bool success) {\n        require(freezed[msg.sender] != true);\n        allowed[msg.sender][spender] = tokens;\n        Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer tokens from the from account to the to account\n    // \n    // The calling account must already have sufficient tokens approve(...)-d\n    // for spending from the from account and\n    // - From account must have sufficient balance to transfer\n    // - Spender must have sufficient allowance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        balances[from] = safeSub(balances[from], tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        Transfer(from, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Returns the amount of tokens approved by the owner that can be\n    // transferred to the spender&#39;s account\n    // ------------------------------------------------------------------------\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n        require(freezed[msg.sender] != true);\n        return allowed[tokenOwner][spender];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner&#39;s account. The spender contract function\n    // receiveApproval(...) is then executed\n    // ------------------------------------------------------------------------\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n        require(freezed[msg.sender] != true);\n        allowed[msg.sender][spender] = tokens;\n        Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n        return true;\n    }\n\n    // ------------------------------------------------------------------------\n    // Mint Tokens\n    // ------------------------------------------------------------------------\n    function _mint(uint amount, address receiver) internal {\n        require(minePool >= amount);\n        minePool = safeSub(minePool, amount);\n        balances[receiver] = safeAdd(balances[receiver], amount);\n        Transfer(address(0), receiver, amount);\n    }\n    \n    function mint(uint amount) public onlyAdmin {\n        require(minePool >= amount);\n        minePool = safeSub(minePool, amount);\n        balances[msg.sender] = safeAdd(balances[msg.sender], amount);\n        _totalSupply = safeAdd(_totalSupply, amount);\n    }\n    \n    // ------------------------------------------------------------------------\n    // Freeze Tokens\n    // ------------------------------------------------------------------------\n    function freeze(address user, uint amount, uint period) public onlyAdmin {\n        require(balances[user] >= amount);\n        freezed[user] = true;\n        unlockTime[user] = uint(now) + period;\n        freezeAmount[user] = amount;\n    }\n\n    // ------------------------------------------------------------------------\n    // UnFreeze Tokens\n    // ------------------------------------------------------------------------\n    function unFreeze() public {\n        require(freezed[msg.sender] == true);\n        require(unlockTime[msg.sender] < uint(now));\n        freezed[msg.sender] = false;\n        freezeAmount[msg.sender] = 0;\n    }\n    \n    function ifFreeze(address user) public view returns (\n        bool check, \n        uint amount, \n        uint timeLeft\n    ) {\n        check = freezed[user];\n        amount = freezeAmount[user];\n        timeLeft = unlockTime[user] - uint(now);\n    }\n    \n    // ------------------------------------------------------------------------\n    // Partner Authorization\n    // ------------------------------------------------------------------------\n    function createPartner(address _partner, uint _amount, uint _singleTrans, uint _durance) public onlyAdmin returns (uint) {\n        Partner memory _Partner = Partner({\n            admin: _partner,\n            tokenPool: _amount,\n            singleTrans: _singleTrans,\n            timestamp: uint(now),\n            durance: _durance\n        });\n        uint newPartnerId = partners.push(_Partner) - 1;\n        PartnerCreated(newPartnerId, _partner, _amount, _singleTrans, _durance);\n        \n        return newPartnerId;\n    }\n    \n    function partnerTransfer(uint _partnerId, bytes32 _data, address _to, uint _amount) public onlyPartner(_partnerId) whenNotPaused returns (bool) {\n        require(_amount <= partners[_partnerId].singleTrans);\n        partners[_partnerId].tokenPool = safeSub(partners[_partnerId].tokenPool, _amount);\n        Poster memory _Poster = Poster ({\n           poster: _to,\n           hashData: _data,\n           reward: _amount\n        });\n        uint newPostId = PartnerIdToPosterList[_partnerId].push(_Poster) - 1;\n        _mint(_amount, _to);\n        RewardDistribute(newPostId, _partnerId, _to, _amount);\n        return true;\n    }\n    \n    function setPartnerPool(uint _partnerId, uint _amount) public onlyAdmin {\n        partners[_partnerId].tokenPool = _amount;\n    }\n    \n    function setPartnerDurance(uint _partnerId, uint _durance) public onlyAdmin {\n        partners[_partnerId].durance = uint(now) + _durance;\n    }\n    \n    function getPartnerInfo(uint _partnerId) public view returns (\n        address admin,\n        uint tokenPool,\n        uint timeLeft\n    ) {\n        Partner memory _Partner = partners[_partnerId];\n        admin = _Partner.admin;\n        tokenPool = _Partner.tokenPool;\n        if (_Partner.timestamp + _Partner.durance > uint(now)) {\n            timeLeft = _Partner.timestamp + _Partner.durance - uint(now);\n        } else {\n            timeLeft = 0;\n        }\n        \n    }\n\n    function getPosterInfo(uint _partnerId, uint _posterId) public view returns (\n        address poster,\n        bytes32 hashData,\n        uint reward\n    ) {\n        Poster memory _Poster = PartnerIdToPosterList[_partnerId][_posterId];\n        poster = _Poster.poster;\n        hashData = _Poster.hashData;\n        reward = _Poster.reward;\n    }\n\n    // ------------------------------------------------------------------------\n    // Vip Agreement\n    // ------------------------------------------------------------------------\n    function createVip(address _vip, uint _durance, uint _frequence, uint _salary) public onlyAdmin returns (uint) {\n        Vip memory _Vip = Vip ({\n           vip: _vip,\n           durance: uint(now) + _durance,\n           frequence: _frequence,\n           salary: _salary,\n           timestamp: now + _frequence\n        });\n        uint newVipId = vips.push(_Vip) - 1;\n        VipAgreementSign(newVipId, _vip, _durance, _frequence, _salary);\n        \n        return newVipId;\n    }\n    \n    function mineSalary(uint _vipId) public onlyVip(_vipId) whenNotPaused returns (bool) {\n        Vip storage _Vip = vips[_vipId];\n        _mint(_Vip.salary, _Vip.vip);\n        _Vip.timestamp = safeAdd(_Vip.timestamp, _Vip.frequence);\n        \n        SalaryReceived(_vipId, _Vip.vip, _Vip.salary, _Vip.timestamp);\n        return true;\n    }\n    \n    function deleteVip(uint _vipId) public onlyAdmin {\n        delete vips[_vipId];\n    }\n    \n    function getVipInfo(uint _vipId) public view returns (\n        address vip,\n        uint durance,\n        uint frequence,\n        uint salary,\n        uint nextSalary,\n        string log\n    ) {\n        Vip memory _Vip = vips[_vipId];\n        vip = _Vip.vip;\n        durance = _Vip.durance;\n        frequence = _Vip.frequence;\n        salary = _Vip.salary;\n        if(_Vip.timestamp >= uint(now)) {\n            nextSalary = safeSub(_Vip.timestamp, uint(now));\n            log = \"Please Wait\";\n        } else {\n            nextSalary = 0;\n            log = \"Pick Up Your Salary Now\";\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Accept ETH\n    // ------------------------------------------------------------------------\n    function () public payable {\n    }\n\n    // ------------------------------------------------------------------------\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    // ------------------------------------------------------------------------\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyAdmin returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(adminAddress, tokens);\n    }\n}\n\ncontract Anno is AnnoToken {\n    event MembershipUpdate(address indexed member, uint indexed level);\n    event MembershipCancel(address indexed member);\n    event AnnoTradeCreated(uint indexed tradeId, bool indexed ifMedal, uint medal, uint token);\n    event TradeCancel(uint indexed tradeId);\n    event TradeComplete(uint indexed tradeId, address indexed buyer, address indexed seller, uint medal, uint token);\n    event Mine(address indexed miner, uint indexed salary);\n    \n    mapping (address => uint) MemberToLevel;\n    mapping (address => uint) MemberToMedal;\n    mapping (address => uint) MemberToToken;\n    mapping (address => uint) MemberToTime;\n    \n    uint public period = 14 days;\n    \n    uint[5] public boardMember =[\n        0,\n        500,\n        2500,\n        25000,\n        50000\n    ];\n    \n    uint[5] public salary = [\n        0,\n        1151000000000000000000,\n        5753000000000000000000,\n        57534000000000000000000,\n        115068000000000000000000\n    ];\n    \n    struct AnnoTrade {\n        address seller;\n        bool ifMedal;\n        uint medal;\n        uint token;\n    }\n    \n    AnnoTrade[] annoTrades;\n    \n    function boardMemberApply(uint _level) public whenNotPaused {\n        require(_level > 0 && _level <= 4);\n        require(medalBalances[msg.sender] >= boardMember[_level]);\n        _medalFreeze(boardMember[_level]);\n        MemberToLevel[msg.sender] = _level;\n        if(MemberToTime[msg.sender] == 0) {\n            MemberToTime[msg.sender] = uint(now);\n        }\n        \n        MembershipUpdate(msg.sender, _level);\n    }\n    \n    function getBoardMember(address _member) public view returns (\n        uint level,\n        uint timeLeft\n    ) {\n        level = MemberToLevel[_member];\n        if(MemberToTime[_member] > uint(now)) {\n            timeLeft = safeSub(MemberToTime[_member], uint(now));\n        } else {\n            timeLeft = 0;\n        }\n    }\n    \n    function boardMemberCancel() public whenNotPaused {\n        require(MemberToLevel[msg.sender] > 0);\n        _medalUnFreeze(boardMember[MemberToLevel[msg.sender]]);\n        \n        MemberToLevel[msg.sender] = 0;\n        MembershipCancel(msg.sender);\n    }\n    \n    function createAnnoTrade(bool _ifMedal, uint _medal, uint _token) public whenNotPaused returns (uint) {\n        if(_ifMedal) {\n            require(medalBalances[msg.sender] >= _medal);\n            medalBalances[msg.sender] = safeSub(medalBalances[msg.sender], _medal);\n            MemberToMedal[msg.sender] = _medal;\n            AnnoTrade memory anno = AnnoTrade({\n               seller: msg.sender,\n               ifMedal:_ifMedal,\n               medal: _medal,\n               token: _token\n            });\n            uint newMedalTradeId = annoTrades.push(anno) - 1;\n            AnnoTradeCreated(newMedalTradeId, _ifMedal, _medal, _token);\n            \n            return newMedalTradeId;\n        } else {\n            require(balances[msg.sender] >= _token);\n            balances[msg.sender] = safeSub(balances[msg.sender], _token);\n            MemberToToken[msg.sender] = _token;\n            AnnoTrade memory _anno = AnnoTrade({\n               seller: msg.sender,\n               ifMedal:_ifMedal,\n               medal: _medal,\n               token: _token\n            });\n            uint newTokenTradeId = annoTrades.push(_anno) - 1;\n            AnnoTradeCreated(newTokenTradeId, _ifMedal, _medal, _token);\n            \n            return newTokenTradeId;\n        }\n    }\n    \n    function cancelTrade(uint _tradeId) public whenNotPaused {\n        AnnoTrade memory anno = annoTrades[_tradeId];\n        require(anno.seller == msg.sender);\n        if(anno.ifMedal){\n            medalBalances[msg.sender] = safeAdd(medalBalances[msg.sender], anno.medal);\n            MemberToMedal[msg.sender] = 0;\n        } else {\n            balances[msg.sender] = safeAdd(balances[msg.sender], anno.token);\n            MemberToToken[msg.sender] = 0;\n        }\n        delete annoTrades[_tradeId];\n        TradeCancel(_tradeId);\n    }\n    \n    function trade(uint _tradeId) public whenNotPaused {\n        AnnoTrade memory anno = annoTrades[_tradeId];\n        if(anno.ifMedal){\n            medalBalances[msg.sender] = safeAdd(medalBalances[msg.sender], anno.medal);\n            MemberToMedal[anno.seller] = 0;\n            transfer(anno.seller, anno.token);\n            delete annoTrades[_tradeId];\n            TradeComplete(_tradeId, msg.sender, anno.seller, anno.medal, anno.token);\n        } else {\n            balances[msg.sender] = safeAdd(balances[msg.sender], anno.token);\n            MemberToToken[anno.seller] = 0;\n            medalTransfer(anno.seller, anno.medal);\n            delete annoTrades[_tradeId];\n            TradeComplete(_tradeId, msg.sender, anno.seller, anno.medal, anno.token);\n        }\n    }\n    \n    function mine() public whenNotPaused {\n        uint level = MemberToLevel[msg.sender];\n        require(MemberToTime[msg.sender] < uint(now)); \n        require(level > 0);\n        _mint(salary[level], msg.sender);\n        MemberToTime[msg.sender] = safeAdd(MemberToTime[msg.sender], period);\n        Mine(msg.sender, salary[level]);\n    }\n    \n    function setBoardMember(uint one, uint two, uint three, uint four) public onlyAdmin {\n        boardMember[1] = one;\n        boardMember[2] = two;\n        boardMember[3] = three;\n        boardMember[4] = four;\n    }\n    \n    function setSalary(uint one, uint two, uint three, uint four) public onlyAdmin {\n        salary[1] = one;\n        salary[2] = two;\n        salary[3] = three;\n        salary[4] = four;\n    }\n    \n    function setPeriod(uint time) public onlyAdmin {\n        period = time;\n    }\n    \n    function getTrade(uint _tradeId) public view returns (\n        address seller,\n        bool ifMedal,\n        uint medal,\n        uint token \n    ) {\n        AnnoTrade memory _anno = annoTrades[_tradeId];\n        seller = _anno.seller;\n        ifMedal = _anno.ifMedal;\n        medal = _anno.medal;\n        token = _anno.token;\n    }\n    \n    function WhoIsTheContractMaster() public pure returns (string) {\n        return \"Alexander The Exlosion\";\n    }\n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x79ed6619640c1c1d9f3e64555172406fe72788b7",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2021-09-11\n*/\n\n// SPDX-License-Identifier: GNU-3\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ninterface DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) external view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(address(0))) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n/// note.sol -- the `note' modifier, for logging calls as events\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n//pragma solidity >=0.4.23;\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint256           wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        _;\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n    }\n}\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n//pragma solidity >0.4.13;\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n// thing.sol - `auth` with handy mixins. your things should be DSThings\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n//pragma solidity >=0.4.23;\n\n//import 'ds-auth/auth.sol';\n//import 'ds-note/note.sol';\n//import 'ds-math/math.sol';\n\ncontract DSThing is DSAuth, DSNote, DSMath {\n    function S(string memory s) internal pure returns (bytes4) {\n        return bytes4(keccak256(abi.encodePacked(s)));\n    }\n\n}\n/// value.sol - a value is a simple thing, it can be get and set\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n//pragma solidity >=0.4.23;\n\n//import 'ds-thing/thing.sol';\n\ncontract DSValue is DSThing {\n    bool    has;\n    bytes32 val;\n    function peek() public view returns (bytes32, bool) {\n        return (val,has);\n    }\n    function read() public view returns (bytes32) {\n        bytes32 wut; bool haz;\n        (wut, haz) = peek();\n        require(haz, \"haz-not\");\n        return wut;\n    }\n    function poke(bytes32 wut) public note auth {\n        val = wut;\n        has = true;\n    }\n    function void() public note auth {  // unset the value\n        has = false;\n    }\n}\n/// osm.sol\n\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n//pragma solidity >=0.5.10;\n\n//import \"ds-value/value.sol\";\n\ncontract LibNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  usr,\n        bytes32  indexed  arg1,\n        bytes32  indexed  arg2,\n        bytes             data\n    ) anonymous;\n\n    modifier note {\n        _;\n        assembly {\n            // log an 'anonymous' event with a constant 6 words of calldata\n            // and four indexed topics: selector, caller, arg1 and arg2\n            let mark := msize()                       // end of memory ensures zero\n            mstore(0x40, add(mark, 288))              // update free memory pointer\n            mstore(mark, 0x20)                        // bytes type data offset\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\n            log4(mark, 288,                           // calldata\n                 shl(224, shr(224, calldataload(0))), // msg.sig\n                 caller(),                            // msg.sender\n                 calldataload(4),                     // arg1\n                 calldataload(36)                     // arg2\n                )\n        }\n    }\n}\n\ncontract OSM_STETHUSD is LibNote {\n\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { wards[usr] = 1; }\n    function deny(address usr) external note auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"OSM/not-authorized\");\n        _;\n    }\n\n    // --- Stop ---\n    uint256 public stopped;\n    modifier stoppable { require(stopped == 0, \"OSM/is-stopped\"); _; }\n\n    // --- Math ---\n    function add(uint64 x, uint64 y) internal pure returns (uint64 z) {\n        z = x + y;\n        require(z >= x);\n    }\n\n    address public src;\n    uint16  constant ONE_HOUR = uint16(3600);\n    uint16  public hop = ONE_HOUR;\n    uint64  public zzz;\n\n    struct Feed {\n        uint128 val;\n        uint128 has;\n    }\n\n    Feed cur;\n    Feed nxt;\n\n    // Whitelisted contracts, set by an auth\n    mapping (address => uint256) public bud;\n\n    modifier toll { require(bud[msg.sender] == 1, \"OSM/contract-not-whitelisted\"); _; }\n\n    event LogValue(bytes32 val);\n\n    constructor (address src_) public {\n        wards[msg.sender] = 1;\n        src = src_;\n    }\n\n    function stop() external note auth {\n        stopped = 1;\n    }\n    function start() external note auth {\n        stopped = 0;\n    }\n\n    function change(address src_) external note auth {\n        src = src_;\n    }\n\n    function era() internal view returns (uint) {\n        return block.timestamp;\n    }\n\n    function prev(uint ts) internal view returns (uint64) {\n        require(hop != 0, \"OSM/hop-is-zero\");\n        return uint64(ts - (ts % hop));\n    }\n\n    function step(uint16 ts) external auth {\n        require(ts > 0, \"OSM/ts-is-zero\");\n        hop = ts;\n    }\n\n    function void() external note auth {\n        cur = nxt = Feed(0, 0);\n        stopped = 1;\n    }\n\n    function pass() public view returns (bool ok) {\n        return era() >= add(zzz, hop);\n    }\n\n    function poke() external note stoppable {\n        require(pass(), \"OSM/not-passed\");\n        (bytes32 wut, bool ok) = DSValue(src).peek();\n        if (ok) {\n            cur = nxt;\n            nxt = Feed(uint128(uint(wut)), 1);\n            zzz = prev(era());\n            emit LogValue(bytes32(uint(cur.val)));\n        }\n    }\n\n    function peek() external view toll returns (bytes32,bool) {\n        return (bytes32(uint(cur.val)), cur.has == 1);\n    }\n\n    function peep() external view toll returns (bytes32,bool) {\n        return (bytes32(uint(nxt.val)), nxt.has == 1);\n    }\n\n    function read() external view toll returns (bytes32) {\n        require(cur.has == 1, \"OSM/no-current-value\");\n        return (bytes32(uint(cur.val)));\n    }\n\n\n\n    function kiss(address a) external note auth {\n        require(a != address(0), \"OSM/no-contract-0\");\n        bud[a] = 1;\n    }\n\n    function diss(address a) external note auth {\n        bud[a] = 0;\n    }\n\n    function kiss(address[] calldata a) external note auth {\n        for(uint i = 0; i < a.length; i++) {\n            require(a[i] != address(0), \"OSM/no-contract-0\");\n            bud[a[i]] = 1;\n        }\n    }\n\n    function diss(address[] calldata a) external note auth {\n        for(uint i = 0; i < a.length; i++) {\n            bud[a[i]] = 0;\n        }\n    }\n}",
    "vulnerability_type": "bad_randomness"
  },
  {
    "address": "0x7a5918670b0c390ad25f7bee908c1acc2d314a3c",
    "source_code": "// median.sol - Medianizer v2\n\n// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.12;\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n////// lib/ds-stop/lib/ds-note/src/note.sol\n/// note.sol -- the `note' modifier, for logging calls as events\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint256           wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\n////// lib/ds-value/lib/ds-thing/lib/ds-math/src/math.sol\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >0.4.13; */\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n////// lib/ds-value/lib/ds-thing/src/thing.sol\n// thing.sol - `auth` with handy mixins. your things should be DSThings\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import 'ds-auth/auth.sol'; */\n/* import 'ds-note/note.sol'; */\n/* import 'ds-math/math.sol'; */\n\ncontract DSThing is DSAuth, DSNote, DSMath {\n    function S(string memory s) internal pure returns (bytes4) {\n        return bytes4(keccak256(abi.encodePacked(s)));\n    }\n\n}\n\n////// lib/ds-value/src/value.sol\n/// value.sol - a value is a simple thing, it can be get and set\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import 'ds-thing/thing.sol'; */\n\ncontract DSValue is DSThing {\n    bool    has;\n    bytes32 val;\n    function peek() public view returns (bytes32, bool) {\n        return (val,has);\n    }\n    function read() public view returns (bytes32) {\n        bytes32 wut; bool haz;\n        (wut, haz) = peek();\n        require(haz, \"haz-not\");\n        return wut;\n    }\n    function poke(bytes32 wut) public note auth {\n        val = wut;\n        has = true;\n    }\n    function void() public note auth {  // unset the value\n        has = false;\n    }\n}\n\n////// src/osm.sol\n/* pragma solidity >=0.5.10; */\n\n/* import \"ds-value/value.sol\"; */\n\ncontract LibNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  usr,\n        bytes32  indexed  arg1,\n        bytes32  indexed  arg2,\n        bytes             data\n    ) anonymous;\n\n    modifier note {\n        _;\n        assembly {\n            // log an 'anonymous' event with a constant 6 words of calldata\n            // and four indexed topics: selector, caller, arg1 and arg2\n            let mark := msize                         // end of memory ensures zero\n            mstore(0x40, add(mark, 288))              // update free memory pointer\n            mstore(mark, 0x20)                        // bytes type data offset\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\n            log4(mark, 288,                           // calldata\n                 shl(224, shr(224, calldataload(0))), // msg.sig\n                 caller,                              // msg.sender\n                 calldataload(4),                     // arg1\n                 calldataload(36)                     // arg2\n                )\n        }\n    }\n}\n\ncontract OSM is LibNote {\n\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { wards[usr] = 1; }\n    function deny(address usr) external note auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"OSM/not-authorized\");\n        _;\n    }\n\n    // --- Stop ---\n    uint256 public stopped;\n    modifier stoppable { require(stopped == 0, \"OSM/is-stopped\"); _; }\n\n    // --- Math ---\n    function add(uint64 x, uint64 y) internal pure returns (uint64 z) {\n        z = x + y;\n        require(z >= x);\n    }\n\n    address public src;\n    uint16  constant ONE_HOUR = uint16(3600);\n    uint16  public hop = ONE_HOUR;\n    uint64  public zzz;\n\n    struct Feed {\n        uint128 val;\n        uint128 has;\n    }\n\n    Feed cur;\n    Feed nxt;\n\n    // Whitelisted contracts, set by an auth\n    mapping (address => uint256) public bud;\n\n    modifier toll { require(bud[msg.sender] == 1, \"OSM/contract-not-whitelisted\"); _; }\n\n    event LogValue(bytes32 val);\n\n    constructor (address src_) public {\n        wards[msg.sender] = 1;\n        src = src_;\n    }\n\n    function stop() external note auth {\n        stopped = 1;\n    }\n    function start() external note auth {\n        stopped = 0;\n    }\n\n    function change(address src_) external note auth {\n        src = src_;\n    }\n\n    function era() internal view returns (uint) {\n        return block.timestamp;\n    }\n\n    function prev(uint ts) internal view returns (uint64) {\n        require(hop != 0, \"OSM/hop-is-zero\");\n        return uint64(ts - (ts % hop));\n    }\n\n    function step(uint16 ts) external auth {\n        require(ts > 0, \"OSM/ts-is-zero\");\n        hop = ts;\n    }\n\n    function void() external note auth {\n        cur = nxt = Feed(0, 0);\n        stopped = 1;\n    }\n\n    function pass() public view returns (bool ok) {\n        return era() >= add(zzz, hop);\n    }\n\n    function poke() external note stoppable {\n        require(pass(), \"OSM/not-passed\");\n        (bytes32 wut, bool ok) = DSValue(src).peek();\n        if (ok) {\n            cur = nxt;\n            nxt = Feed(uint128(uint(wut)), 1);\n            zzz = prev(era());\n            emit LogValue(bytes32(uint(cur.val)));\n        }\n    }\n\n    function peek() external view toll returns (bytes32,bool) {\n        return (bytes32(uint(cur.val)), cur.has == 1);\n    }\n\n    function peep() external view toll returns (bytes32,bool) {\n        return (bytes32(uint(nxt.val)), nxt.has == 1);\n    }\n\n    function read() external view toll returns (bytes32) {\n        require(cur.has == 1, \"OSM/no-current-value\");\n        return (bytes32(uint(cur.val)));\n    }\n\n\n\n    function kiss(address a) external note auth {\n        require(a != address(0), \"OSM/no-contract-0\");\n        bud[a] = 1;\n    }\n\n    function diss(address a) external note auth {\n        bud[a] = 0;\n    }\n\n    function kiss(address[] calldata a) external note auth {\n        for(uint i = 0; i < a.length; i++) {\n            require(a[i] != address(0), \"OSM/no-contract-0\");\n            bud[a[i]] = 1;\n        }\n    }\n\n    function diss(address[] calldata a) external note auth {\n        for(uint i = 0; i < a.length; i++) {\n            bud[a[i]] = 0;\n        }\n    }\n}",
    "vulnerability_type": "bad_randomness"
  },
  {
    "address": "0x7c6b64ea75faae3ca4b223f7e5dea700acebc77e",
    "source_code": "pragma solidity ^0.4.18;\n\n/*\nGame: Dragon Ball Super ( Tournament of Power )\nDomain: EtherDragonBall.com\n*/\n\ncontract DragonBallZ {\n    \n    //The contract creator and dev fee addresses are defined here\n\taddress contractCreator = 0x606A19ea257aF8ED76D160Ad080782C938660A33;\n    address devFeeAddress = 0xAe406d5900DCe1bB7cF3Bc5e92657b5ac9cBa34B;\n\n\tstruct Hero {\n\t\tstring heroName;\n\t\taddress ownerAddress;\n\t\taddress DBZHeroOwnerAddress;\n\t\tuint256 currentPrice;\n\t\tuint currentLevel;\n\t}\n\tHero[] heroes;\n\t\n\t//The number of heroes in Tournament of Power\n\tuint256 heroMax = 55;\n\t\n\t//The array defined for winner variable\n    uint256[] winners;\n\n\n\tmodifier onlyContractCreator() {\n        require (msg.sender == contractCreator);\n        _;\n    }\n\n    bool isPaused;\n    \n    \n    /*\n    We use the following functions to pause and unpause the game.\n    */\n    function pauseGame() public onlyContractCreator {\n        isPaused = true;\n    }\n    function unPauseGame() public onlyContractCreator {\n        isPaused = false;\n    }\n    function GetGamestatus() public view returns(bool) {\n        return(isPaused);\n    }\n\n    /*\n    This function allows users to purchase Tournament of Power heroes \n    The price is automatically multiplied by 2 after each purchase.\n    Users can purchase multiple heroes.\n    */\n\tfunction purchaseHero(uint _heroId) public payable {\n\t    //Check if current price of hero is equal with the price entered to purchase the hero\n\t\trequire(msg.value == heroes[_heroId].currentPrice);\n\t\t\n\t\t//Check if the game is not PAUSED\n\t\trequire(isPaused == false);\n\t\t\n\t\t// Calculate the 10% of Tournament of Power prize fee\n\t\tuint256 TournamentPrizeFee = (msg.value / 10); // => 10%\n\t    \n\t\t// Calculate the 5% - Dev fee\n\t\tuint256 devFee = ((msg.value / 10)/2);  // => 5%\n\t\t\n\t\t// Calculate the 10% commission - Dragon Ball Z Hero Owner\n\t\tuint256 DBZHeroOwnerCommission = (msg.value / 10); // => 10%\n\n\t\t// Calculate the current hero owner commission on this sale & transfer the commission to the owner.\t\t\n\t\tuint256 commissionOwner = (msg.value - (devFee + TournamentPrizeFee + DBZHeroOwnerCommission)); \n\t\theroes[_heroId].ownerAddress.transfer(commissionOwner); // => 75%\n\n\t\t// Transfer the 10% commission to the DBZ Hero Owner\n\t\theroes[_heroId].DBZHeroOwnerAddress.transfer(DBZHeroOwnerCommission); // => 10% \t\t\t\t\t\t\t\t\n\n\t\t\n\t\t// Transfer the 5% commission to the Dev\n\t\tdevFeeAddress.transfer(devFee); // => 5% \n\t\t\n\t\t//The hero will be leveled up after new purchase\n\t\theroes[_heroId].currentLevel +=1;\n\n\t\t// Update the hero owner and set the new price (2X)\n\t\theroes[_heroId].ownerAddress = msg.sender;\n\t\theroes[_heroId].currentPrice = mul(heroes[_heroId].currentPrice, 2);\n\t}\n\t\n\t/*\n\tThis function will be used to update the details of DBZ hero details by the contract creator\n\t*/\n\tfunction updateDBZHeroDetails(uint _heroId, string _heroName,address _ownerAddress, address _newDBZHeroOwnerAddress, uint _currentLevel) public onlyContractCreator{\n\t    require(heroes[_heroId].ownerAddress != _newDBZHeroOwnerAddress);\n\t\theroes[_heroId].heroName = _heroName;\t\t\n\t\theroes[_heroId].ownerAddress = _ownerAddress;\n\t    heroes[_heroId].DBZHeroOwnerAddress = _newDBZHeroOwnerAddress;\n\t    heroes[_heroId].currentLevel = _currentLevel;\n\t}\n\t\n\t/*\n\tThis function can be used by the owner of a hero to modify the price of its hero.\n\tThe hero owner can make the price lesser than the current price only.\n\t*/\n\tfunction modifyCurrentHeroPrice(uint _heroId, uint256 _newPrice) public {\n\t    require(_newPrice > 0);\n\t    require(heroes[_heroId].ownerAddress == msg.sender);\n\t    require(_newPrice < heroes[_heroId].currentPrice);\n\t    heroes[_heroId].currentPrice = _newPrice;\n\t}\n\t\n\t// This function will return all of the details of the Tournament of Power heroes\n\tfunction getHeroDetails(uint _heroId) public view returns (\n        string heroName,\n        address ownerAddress,\n        address DBZHeroOwnerAddress,\n        uint256 currentPrice,\n        uint currentLevel\n    ) {\n        Hero storage _hero = heroes[_heroId];\n\n        heroName = _hero.heroName;\n        ownerAddress = _hero.ownerAddress;\n        DBZHeroOwnerAddress = _hero.DBZHeroOwnerAddress;\n        currentPrice = _hero.currentPrice;\n        currentLevel = _hero.currentLevel;\n    }\n    \n    // This function will return only the price of a specific hero\n    function getHeroCurrentPrice(uint _heroId) public view returns(uint256) {\n        return(heroes[_heroId].currentPrice);\n    }\n    \n    // This function will return only the price of a specific hero\n    function getHeroCurrentLevel(uint _heroId) public view returns(uint256) {\n        return(heroes[_heroId].currentLevel);\n    }\n    \n    // This function will return only the owner address of a specific hero\n    function getHeroOwner(uint _heroId) public view returns(address) {\n        return(heroes[_heroId].ownerAddress);\n    }\n    \n    // This function will return only the DBZ owner address of a specific hero\n    function getHeroDBZHeroAddress(uint _heroId) public view returns(address) {\n        return(heroes[_heroId].DBZHeroOwnerAddress);\n    }\n    \n    // This function will return only Tournament of Power total prize\n    function getTotalPrize() public view returns(uint256) {\n        return this.balance;\n    }\n    \n    /**\n    @dev Multiplies two numbers, throws on overflow. => From the SafeMath library\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    @dev Integer division of two numbers, truncating the quotient. => From the SafeMath library\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n        return c;\n    }\n    \n\t// This function will be used to add a new hero by the contract creator\n\tfunction addHero(string _heroName, address _ownerAddress, address _DBZHeroOwnerAddress, uint256 _currentPrice, uint _currentLevel) public onlyContractCreator {\n        heroes.push(Hero(_heroName,_ownerAddress,_DBZHeroOwnerAddress,_currentPrice,_currentLevel));\n    }\n     \n    /*\n\tThis function will be used by the contract creator to generate 5 heroes ID randomly out of 55 heroes\n\tand it can be generated only once and cannot be altered at all even by contractCreator\n\t*/   \n    function getWinner() public onlyContractCreator returns (uint256[]) {\n        uint i;\n\t\t\n\t\t//Loop to generate 5 random hero IDs from 55 heroes\t\n\t\tfor(i=0;i<=4;i++){\n\t\t    //Block timestamp and number used to generate the random number\n\t\t\twinners.push(uint256(sha256(block.timestamp, block.number-i-1)) % heroMax);\n\t\t}\n\t\t\n\t\treturn winners;\n    }\n\n    // This function will return only the winner&#39;s hero id\n    function getWinnerDetails(uint _winnerId) public view returns(uint256) {\n        return(winners[_winnerId]);\n    }\n    \n    /*\n\tThis function can be used by the contractCreator to start the payout to the lucky 5 winners\n\tThe payout will be initiated in a week time\n\t*/\n    function payoutWinners() public onlyContractCreator {\n        //Assign 20% of total contract eth\n        uint256 TotalPrize20PercentShare = (this.balance/5);\n        uint i;\n\t\t\tfor(i=0;i<=4;i++){\n\t\t\t    // Get the hero ID from getWinnerDetails function - Randomly generated\n\t\t\t    uint _heroID = getWinnerDetails(i);\n\t\t\t    // Assign the owner address of hero ID - Randomly generated\n\t\t\t    address winner = heroes[_heroID].ownerAddress;\n\t\t\t    \n\t\t\t    if(winner != address(0)){\n\t\t\t     // Transfer the 20% of total contract eth to each winner (5 winners in total)  \n                 winner.transfer(TotalPrize20PercentShare);\t\t\t       \n\t\t\t    }\n\t\t\t    \n\t\t\t    // Reset the winner&#39;s address after payout for next loop\n\t\t\t    winner = address(0);\n\t\t\t}\n    }\n    \n}",
    "vulnerability_type": "bad_randomness"
  },
  {
    "address": "0x7EDA2301cb535e2EA8ea06237f6443b6268e2b2A",
    "source_code": "//EA 0x7EDA2301cb535e2EA8ea06237f6443b6268e2b2A  ETH Main net\n\n\npragma solidity ^0.4.25; // solhint-disable-line\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\ncontract ERC721 {\n  // Required methods\n  function approve(address _to, uint256 _tokenId) public;\n  function balanceOf(address _owner) public view returns (uint256 balance);\n  function implementsERC721() public view returns (bool);\n  function ownerOf(uint256 _tokenId) public view returns (address addr);\n  function takeOwnership(uint256 _tokenId) public;\n  function totalSupply() public view returns (uint256 total);\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n  function transfer(address _to, uint256 _tokenId) public;\n\n  event Transfer(address indexed from, address indexed to, uint256 tokenId);\n  event Approval(address indexed owner, address indexed approved, uint256 tokenId);\n\n  // Optional\n  // function name() public view returns (string name);\n  // function symbol() public view returns (string symbol);\n  // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n  // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n}\n\n\n//********************************************************************\n\n\ncontract CharToken is ERC721 {\n  /*** EVENTS ***/\n  /// @dev The Birth event is fired whenever a new char comes into existence.\n  event Birth(uint256 tokenId, string wikiID_Name, address owner);\n  /// @dev The TokenSold event is fired whenever a token is sold.\n  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address newOwner, string wikiID_Name);\n  /// @dev Transfer event as defined in current draft of ERC721.\n  ///  ownership is assigned, including births.\n  event Transfer(address from, address to, uint256 tokenId);\n  /// @dev Emitted when a bug is found int the contract and the contract is upgraded at a new address.\n  /// In the event this happens, the current contract is paused indefinitely\n  event ContractUpgrade(address newContract);\n  ///bonus issuance    \n  event Bonus(address to, uint256 bonus);\n\n  /*** CONSTANTS ***/\n  /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n  string public constant NAME = \"CryptoChars\"; // solhint-disable-line\n  string public constant SYMBOL = \"CHARS\"; // solhint-disable-line\n  bool private erc721Enabled = false;\n  uint256 private startingPrice = 0.005 ether;\n  uint256 private constant PROMO_CREATION_LIMIT = 50000;\n  uint256 private firstStepLimit =  0.05 ether;\n  uint256 private secondStepLimit = 0.20 ether;\n  uint256 private thirdStepLimit = 0.5 ether;\n\n  /*** STORAGE ***/\n  /// @dev A mapping from char IDs to the address that owns them. All chars have\n  ///  some valid owner address.\n  mapping (uint256 => address) public charIndexToOwner;\n // @dev A mapping from owner address to count of tokens that address owns.\n  //  Used internally inside balanceOf() to resolve ownership count.\n  mapping (address => uint256) private ownershipTokenCount;\n  /// @dev A mapping from CharIDs to an address that has been approved to call\n  ///  transferFrom(). Each Char can only have one approved address for transfer\n  ///  at any time. A zero value means no approval is outstanding.\n  mapping (uint256 => address) public charIndexToApproved;\n  // @dev A mapping from CharIDs to the price of the token.\n  mapping (uint256 => uint256) private charIndexToPrice;\n  // @dev A mapping from owner address to its total number of transactions\n  mapping (address => uint256) private addressToTrxCount;\n  // The addresses of the accounts (or contracts) that can execute actions within each roles.\n  address public ceoAddress;\n  address public cooAddress;\n  address public cfoAddress;\n  uint256 public promoCreatedCount;\n  //***pack below into a struct for gas optimization    \n  //promo per each N trx is effective until date, and its frequency (every nth buy)\n  uint256 public bonusUntilDate;   \n  uint256 bonusFrequency;\n  /*** DATATYPES ***/\n  struct Char {\n    //name of the char\n    //string name;\n    //wiki pageid of char\n    string wikiID_Name; //save gas\n  }\n  Char[] private chars; \n\n  /*** ACCESS MODIFIERS ***/\n  /// @dev Access modifier for CEO-only functionality\n  modifier onlyCEO() {\n    require(msg.sender == ceoAddress);\n    _;\n  }\n  /// @dev Access modifier for COO-only functionality\n  modifier onlyCOO() {\n    require(msg.sender == cooAddress);\n    _;\n  }\n  /// @dev Access modifier for CFO-only functionality\n  modifier onlyCFO() {\n    require(msg.sender == cfoAddress);\n    _;\n  }\n  modifier onlyERC721() {\n    require(erc721Enabled);\n    _;\n  }\n  /// Access modifier for contract owner only functionality\n  modifier onlyCLevel() {\n    require(\n      msg.sender == ceoAddress ||\n      msg.sender == cooAddress ||\n      msg.sender == cfoAddress \n    );\n    _;\n  }\n  /*** CONSTRUCTOR ***/\n  constructor() public {\n    ceoAddress = msg.sender;\n    cooAddress = msg.sender;\n    cfoAddress = msg.sender;\n    bonusUntilDate = now; //Bonus after Nth buy is valid until this date\n    bonusFrequency = 3; //Bonus distributed after every Nth buy\n    \n    //create genesis chars\n    createContractChar(\"42268616_Captain Ahab\",0);\n    createContractChar(\"455401_Frankenstein\",0);\n    createContractChar(\"8670724_Dracula\",0);\n    createContractChar(\"27159_Sherlock Holmes\",0);\n    createContractChar(\"160108_Snow White\",0);\n    createContractChar(\"73453_Cinderella\",0);\n    createContractChar(\"14966133_Pinocchio\",0);\n    createContractChar(\"369427_Lemuel Gulliver\",0);\n    createContractChar(\"26171_Robin Hood\",0);\n    createContractChar(\"197889_Felix the Cat\",0);\n    createContractChar(\"382164_Wizard of Oz\",0);\n    createContractChar(\"62446_Alice\",0);\n    createContractChar(\"8237_Don Quixote\",0);\n    createContractChar(\"16808_King Arthur\",0);\n    createContractChar(\"194085_Sleeping Beauty\",0);\n    createContractChar(\"299250_Little Red Riding Hood\",0);\n    createContractChar(\"166604_Aladdin\",0);\n    createContractChar(\"7640956_Peter Pan\",0);\n    createContractChar(\"927344_Ali Baba\",0);\n    createContractChar(\"153957_Lancelot\",0);\n    createContractChar(\"235918_Dr._Jekyll_and_Mr._Hyde\",0);\n    createContractChar(\"157787_Captain_Nemo\",0);\n    createContractChar(\"933085_Moby_Dick\",0);\n    createContractChar(\"54246379_Dorian_Gray\",0);\n    createContractChar(\"55483_Robinson_Crusoe\",0);\n    createContractChar(\"380143_Black_Beauty\",0);\n    createContractChar(\"6364074_Phantom_of_the_Opera\",0); \n    createContractChar(\"15055_Ivanhoe\",0);\n    createContractChar(\"21491685_Tarzan\",0);\n    /* */    \n  }\n\n  /*** PUBLIC FUNCTIONS ***/\n  /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\n  /// @param _to The address to be granted transfer approval. Pass address(0) to\n  ///  clear all approvals.\n  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n  /// @dev Required for ERC-721 compliance.\n  function approve(\n    address _to,\n    uint256 _tokenId\n  ) public onlyERC721 {\n    // Caller must own token.\n    require(_owns(msg.sender, _tokenId));\n\n    charIndexToApproved[_tokenId] = _to;\n\n    emit Approval(msg.sender, _to, _tokenId);\n  }\n\n  /// For querying balance of a particular account\n  /// @param _owner The address for balance query\n  /// @dev Required for ERC-721 compliance.\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return ownershipTokenCount[_owner];\n  }\n\n\n  /// @dev Creates a new Char with the given name\n  function createContractChar(string _wikiID_Name, uint256 _price) public onlyCLevel {\n    require(promoCreatedCount < PROMO_CREATION_LIMIT);\n    if (_price <= 0) {\n      _price = startingPrice;\n    }\n    promoCreatedCount++;\n    _createChar(_wikiID_Name, address(this), _price);\n  }\n  /// @notice Returns all the relevant information about a specific char.\n  /// @param _tokenId The tokenId of the char of interest.\n  function getChar(uint256 _tokenId) public view returns (\n    string wikiID_Name,\n    uint256 sellingPrice,\n    address owner\n  ) {\n    Char storage char = chars[_tokenId];\n    wikiID_Name = char.wikiID_Name;\n    sellingPrice = charIndexToPrice[_tokenId];\n    owner = charIndexToOwner[_tokenId];\n  }\n  function changeWikiID_Name(uint256 _tokenId, string _wikiID_Name) public onlyCLevel {\n    require(_tokenId < chars.length);\n    chars[_tokenId].wikiID_Name = _wikiID_Name;\n  }\n  function changeBonusUntilDate(uint32 _days) public onlyCLevel {\n       bonusUntilDate = now + (_days * 1 days);\n  }\n  function changeBonusFrequency(uint32 _n) public onlyCLevel {\n       bonusFrequency = _n;\n  }\n  function overrideCharPrice(uint256 _tokenId, uint256 _price) public onlyCLevel {\n    require(_price != charIndexToPrice[_tokenId]);\n    require(_tokenId < chars.length);\n    //C level can override price for only own and contract tokens\n    require((_owns(address(this), _tokenId)) || (  _owns(msg.sender, _tokenId)) ); \n    charIndexToPrice[_tokenId] = _price;\n  }\n  function changeCharPrice(uint256 _tokenId, uint256 _price) public {\n    require(_owns(msg.sender, _tokenId));\n    require(_tokenId < chars.length);\n    require(_price != charIndexToPrice[_tokenId]);\n    //require(_price > charIndexToPrice[_tokenId]);  //EA>should we enforce this?\n    uint256 maxPrice = SafeMath.div(SafeMath.mul(charIndexToPrice[_tokenId], 1000),100); //10x \n    uint256 minPrice = SafeMath.div(SafeMath.mul(charIndexToPrice[_tokenId], 50),100); //half price\n    require(_price >= minPrice); \n    require(_price <= maxPrice); \n    charIndexToPrice[_tokenId] = _price; \n  }\n  /* ERC721 */\n  function implementsERC721() public view returns (bool _implements) {\n    return erc721Enabled;\n  }\n  /// @dev Required for ERC-721 compliance.\n  function name() public pure returns (string) {\n    return NAME;\n  }\n  /// @dev Required for ERC-721 compliance.\n  function symbol() public pure returns (string) {\n    return SYMBOL;\n  }\n  /// For querying owner of token\n  /// @param _tokenId The tokenID for owner inquiry\n  /// @dev Required for ERC-721 compliance.\n  function ownerOf(uint256 _tokenId)\n    public\n    view\n    returns (address owner)\n  {\n    owner = charIndexToOwner[_tokenId];\n    require(owner != address(0));\n  }\n//  function payout(address _to) public onlyCLevel {\n//    _payout(_to);\n//  }\n  function withdrawFunds(address _to, uint256 amount) public onlyCLevel {\n    _withdrawFunds(_to, amount);\n  }\n  // Allows someone to send ether and obtain the token\n  function purchase(uint256 _tokenId, uint256 newPrice) public payable {\n    address oldOwner = charIndexToOwner[_tokenId];\n    address newOwner = msg.sender;\n    uint256 sellingPrice = charIndexToPrice[_tokenId];\n    // Making sure token owner is not sending to self\n    require(oldOwner != newOwner);\n    // Safety check to prevent against an unexpected 0x0 default.\n    require(_addressNotNull(newOwner));\n    // Making sure sent amount is greater than or equal to the sellingPrice\n    require(msg.value >= sellingPrice);\n    uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 94), 100));\n    uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);\n    // Update prices\n    if (newPrice >= sellingPrice) charIndexToPrice[_tokenId] = newPrice;\n    else {\n            if (sellingPrice < firstStepLimit) {\n              // first stage\n              charIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 200), 100);\n            } else if (sellingPrice < secondStepLimit) {\n              // second stage\n              charIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 150), 100);\n            } else if (sellingPrice < thirdStepLimit) {\n              // second stage\n              charIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 125), 100);\n            } else {\n              // third stage\n              charIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 115), 100);\n            }\n    }\n    _transfer(oldOwner, newOwner, _tokenId);\n    // Pay previous tokenOwner if owner is not contract\n    if (oldOwner != address(this)) {\n      oldOwner.transfer(payment); //(1-0.06)\n    }\n    emit TokenSold(_tokenId, sellingPrice, charIndexToPrice[_tokenId], oldOwner, newOwner,\n      chars[_tokenId].wikiID_Name);\n    msg.sender.transfer(purchaseExcess);\n    //distribute bonus if earned and promo is ongoing and every nth buy trx\n      if( (now < bonusUntilDate && (addressToTrxCount[newOwner] % bonusFrequency) == 0) ) \n      {\n          //bonus operation here\n          uint rand = uint (keccak256(now)) % 50 ; //***earn up to 50% of 6% commissions\n          rand = rand * (sellingPrice-payment);  //***replace later. this is for test\n          _withdrawFunds(newOwner,rand);\n          emit Bonus(newOwner,rand);\n      }\n  }\n  function priceOf(uint256 _tokenId) public view returns (uint256 price) {\n    return charIndexToPrice[_tokenId];\n  }\n  // Unlocks ERC721 behaviour, allowing for trading on third party platforms.\n  function enableERC721() public onlyCEO {\n    erc721Enabled = true;\n  }\n  /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n  /// @param _newCEO The address of the new CEO\n  function setCEO(address _newCEO) public onlyCEO {\n    require(_newCEO != address(0));\n    ceoAddress = _newCEO;\n  }\n  /// @dev Assigns a new address to act as the COO. Only available to the current COO.\n  /// @param _newCOO The address of the new COO\n  function setCOO(address _newCOO) public onlyCOO {\n    require(_newCOO != address(0));\n    cooAddress = _newCOO;\n  }\n/// @dev Assigns a new address to act as the CFO. Only available to the current CFO.\n  /// @param _newCFO The address of the new CFO\n  function setCFO(address _newCFO) public onlyCFO {\n    require(_newCFO != address(0));\n    cfoAddress = _newCFO;\n  }\n  \n  \n  /// @notice Allow pre-approved user to take ownership of a token\n  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n  /// @dev Required for ERC-721 compliance.\n  function takeOwnership(uint256 _tokenId) public {\n    address newOwner = msg.sender;\n    address oldOwner = charIndexToOwner[_tokenId];\n     // Safety check to prevent against an unexpected 0x0 default.\n    require(_addressNotNull(newOwner));\n    // Making sure transfer is approved\n    require(_approved(newOwner, _tokenId));\n    _transfer(oldOwner, newOwner, _tokenId);\n  }\n  /// @param _owner The owner whose char tokens we are interested in.\n  /// @dev This method MUST NEVER be called by smart contract code. First, it&#39;s fairly\n  ///  expensive (it walks the entire Chars array looking for chars belonging to owner),\n  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n  ///  not contract-to-contract calls.\n  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n    uint256 tokenCount = balanceOf(_owner);\n    if (tokenCount == 0) {\n        // Return an empty array\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](tokenCount);\n      uint256 totalChars = chars.length;\n      uint256 resultIndex = 0;\n      uint256 t;\n      for (t = 0; t <= totalChars; t++) {\n        if (charIndexToOwner[t] == _owner) {\n          result[resultIndex] = t;\n          resultIndex++;\n        }\n      }\n      return result;\n    }\n  }\n  /// For querying totalSupply of token\n  /// @dev Required for ERC-721 compliance.\n  function totalSupply() public view returns (uint256 total) {\n    return chars.length;\n  }\n  /// Owner initates the transfer of the token to another account\n  /// @param _to The address for the token to be transferred to.\n  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n  /// @dev Required for ERC-721 compliance.\n  function transfer(\n    address _to,\n    uint256 _tokenId\n  ) public onlyERC721 {\n    require(_owns(msg.sender, _tokenId));\n    require(_addressNotNull(_to));\n    _transfer(msg.sender, _to, _tokenId);\n  }\n  /// Third-party initiates transfer of token from address _from to address _to\n  /// @param _from The address for the token to be transferred from.\n  /// @param _to The address for the token to be transferred to.\n  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n  /// @dev Required for ERC-721 compliance.\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) public onlyERC721 {\n    require(_owns(_from, _tokenId));\n    require(_approved(_to, _tokenId));\n    require(_addressNotNull(_to));\n    _transfer(_from, _to, _tokenId);\n  }\n  /*** PRIVATE FUNCTIONS ***/\n  /// Safety check on _to address to prevent against an unexpected 0x0 default.\n  function _addressNotNull(address _to) private pure returns (bool) {\n    return _to != address(0);\n  }\n  /// For checking approval of transfer for address _to\n  function _approved(address _to, uint256 _tokenId) private view returns (bool) {\n    return charIndexToApproved[_tokenId] == _to;\n  }\n  /// For creating Char\n  function _createChar(string _wikiID_Name, address _owner, uint256 _price) private {\n    Char memory _char = Char({\n      wikiID_Name: _wikiID_Name\n    });\n    uint256 newCharId = chars.push(_char) - 1;\n    // It&#39;s probably never going to happen, 4 billion tokens are A LOT, but\n    // let&#39;s just be 100% sure we never let this happen.\n    require(newCharId == uint256(uint32(newCharId)));\n    emit Birth(newCharId, _wikiID_Name, _owner);\n    charIndexToPrice[newCharId] = _price;\n    // This will assign ownership, and also emit the Transfer event as\n    // per ERC721 draft\n    _transfer(address(0), _owner, newCharId);\n  }\n  /// Check for token ownership\n  function _owns(address claimant, uint256 _tokenId) private view returns (bool) {\n    return claimant == charIndexToOwner[_tokenId];\n  }\n  /// For paying out balance on contract\n//  function _payout(address _to) private {\n//    if (_to == address(0)) {\n//      ceoAddress.transfer(address(this).balance);\n//    } else {\n//      _to.transfer(address(this).balance);\n//    }\n//  }\n function _withdrawFunds(address _to, uint256 amount) private {\n    require(address(this).balance >= amount);\n    if (_to == address(0)) {\n      ceoAddress.transfer(amount);\n    } else {\n      _to.transfer(amount);\n    }\n  }\n  /// @dev Assigns ownership of a specific Char to an address.\n  function _transfer(address _from, address _to, uint256 _tokenId) private {\n    // Since the number of chars is capped to 2^32 we can&#39;t overflow this\n    ownershipTokenCount[_to]++;\n    //transfer ownership\n    charIndexToOwner[_tokenId] = _to;\n    // When creating new chars _from is 0x0, but we can&#39;t account that address.\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n      // clear any previously approved ownership exchange\n      delete charIndexToApproved[_tokenId];\n    }\n    // Emit the transfer event.\n    emit Transfer(_from, _to, _tokenId);\n  //update trx count  \n  addressToTrxCount[_to]++;\n  }\n}\n\nlibrary SafeMath {\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n    return c;\n  }\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
    "vulnerability_type": "bad_randomness"
  },
  {
    "address": "0x8243621ca1aebf78a6f7e11621cf2962205bdb5e",
    "source_code": "/**\n *Submitted for verification at Etherscan.io on 2020-08-13\n*/\n\n// File: contracts\\math\\ABDKMath.sol\n\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright ┬⌐ 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.6.0;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /**\n   * Minimum value signed 64.64-bit fixed point number may have.\n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /**\n   * Maximum value signed 64.64-bit fixed point number may have.\n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) + y;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    if (y == 0) return 0;\n\n    require (x >= 0);\n\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n    uint256 hi = uint256 (x) * (y >> 128);\n\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n    hi <<= 64;\n\n    require (hi <=\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n    return hi + lo;\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    uint256 absoluteResult;\n    bool negativeResult = false;\n    if (x >= 0) {\n      absoluteResult = powu (uint256 (x) << 63, y);\n    } else {\n      // We rely on overflow behavior here\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\n      negativeResult = y & 1 > 0;\n    }\n\n    absoluteResult >>= 63;\n\n    if (negativeResult) {\n      require (absoluteResult <= 0x80000000000000000000000000000000);\n      return -int128 (absoluteResult); // We rely on overflow behavior here\n    } else {\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return int128 (absoluteResult); // We rely on overflow behavior here\n    }\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x unsigned 129.127-bit fixed point number\n   * @param y uint256 value\n   * @return unsigned 129.127-bit fixed point number\n   */\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\n    if (y == 0) return 0x80000000000000000000000000000000;\n    else if (x == 0) return 0;\n    else {\n      int256 msb = 0;\n      uint256 xc = x;\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      int256 xe = msb - 127;\n      if (xe > 0) x >>= xe;\n      else x <<= -xe;\n\n      uint256 result = 0x80000000000000000000000000000000;\n      int256 re = 0;\n\n      while (y > 0) {\n        if (y & 1 > 0) {\n          result = result * x;\n          y -= 1;\n          re += xe;\n          if (result >=\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\n            result >>= 128;\n            re += 1;\n          } else result >>= 127;\n          if (re < -127) return 0; // Underflow\n          require (re < 128); // Overflow\n        } else {\n          x = x * x;\n          y >>= 1;\n          xe <<= 1;\n          if (x >=\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\n            x >>= 128;\n            xe += 1;\n          } else x >>= 127;\n          if (xe < -127) return 0; // Underflow\n          require (xe < 128); // Overflow\n        }\n      }\n\n      if (re > 0) result <<= re;\n      else if (re < 0) result >>= -re;\n\n      return result;\n    }\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\GSN\\Context.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\IERC20.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\utils\\Address.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: contracts\\nuclear.sol\n\npragma solidity ^0.6.2;\n\n\n\n\n\n\ncontract nuclear is Context, IERC20 {\n    using SafeMath for uint256;\n    using ABDKMath64x64 for int128;\n    using Address for address;\n\n    mapping (address => uint256) private _partsOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private constant INITIAL_SUPPLY = 50000000000000;\n    uint256 private constant MAX_UINT = ~uint256(0);\n    uint256 private constant TOTAL_PARTS = MAX_UINT - (MAX_UINT % INITIAL_SUPPLY);\n\n    uint256 private constant CYCLE_SECONDS = 86400;\n    uint256 private constant FINAL_CYCLE = 3711;\n\n    struct halfLife {\n        uint256 startCycle;\n        uint256 endCycle;\n        int128 cycleInflation;\n        uint256 finalSupply;\n    }\n\n    halfLife[11] private _halfLife;\n    uint256 private _startTime;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor () public {\n        _name = 'nuclear.finance';\n        _symbol = 'NCLR';\n        _decimals = 9;\n\n        _partsOwned[_msgSender()] = TOTAL_PARTS;\n        _initHalfLife();\n        _startTime = now;\n    }\n\n    function _initHalfLife() private {\n        _halfLife[0] = halfLife(1, 7, 3606767600000, 53606767600000);\n        _halfLife[1] = halfLife(8, 22, 3876902100000, 57483669700000);\n        _halfLife[2] = halfLife(23, 51, 4162651000000, 61646320700000);\n        _halfLife[3] = halfLife(52, 108, 4466972500000, 66113293200000);\n        _halfLife[4] = halfLife(109, 221, 4792204200000, 70905497400000);\n        _halfLife[5] = halfLife(222, 446, 5140397100000, 76045894500000);\n        _halfLife[6] = halfLife(447, 895, 5513503500000, 81559398000000);\n        _halfLife[7] = halfLife(896, 1792, 5913484400000, 87472882400000);\n        _halfLife[8] = halfLife(1793, 3585, 6342371400000, 93815253800000);\n        _halfLife[9] = halfLife(3586, 7166, 6802304200000, 100617558000000);\n        _halfLife[10] = halfLife(7167, 14333, 7295559000000, 107913117000000);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function startTime() external view returns(uint256) {\n        return _startTime;\n    }\n\n    function sendAirdrop(address[] calldata recipients, uint256 airdropAmt) external {\n        for (uint256 i = 0; i < recipients.length; i++) {\n            transfer(recipients[i], airdropAmt);\n        }\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _getSupply(INITIAL_SUPPLY, getCurrentCycle());\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _partsOwned[account].div(_getRate(TOTAL_PARTS, totalSupply()));\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function getCurrentCycle() public view returns (uint256) {\n        return _getCycle(_startTime, now);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 currentRate = _getRate(TOTAL_PARTS, totalSupply());\n        uint256 partsToTransfer = amount.mul(currentRate);\n        _partsOwned[sender] = _partsOwned[sender].sub(partsToTransfer);\n        _partsOwned[recipient] = _partsOwned[recipient].add(partsToTransfer);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _getCycle(uint256 startTime, uint256 currentTime) private pure returns(uint256) {\n        uint256 secondsElapsed = _getElapsedSeconds(startTime, currentTime);\n        uint256 cycle = (secondsElapsed - (secondsElapsed % CYCLE_SECONDS)) / CYCLE_SECONDS + 1;\n        if (cycle >= FINAL_CYCLE) return FINAL_CYCLE;\n        return cycle;\n    }\n\n    function _getElapsedSeconds(uint256 startTime, uint256 currentTime) private pure returns(uint256) {\n        return currentTime.sub(startTime);\n    }\n\n    function _getSupply(uint256 initialSupply, uint256 currentCycle) private view returns(uint256) {\n        uint256 currentSupply = initialSupply;\n        for (uint256 i = 0; i < _halfLife.length; i++) {\n            halfLife memory halflife = _halfLife[i];\n            if (currentCycle > halflife.endCycle) {\n                currentSupply = halflife.finalSupply;\n            } else {\n                currentSupply = _compound(currentSupply, halflife.cycleInflation, currentCycle.sub(halflife.startCycle));\n                break;\n            }\n        }\n        return currentSupply;\n    }\n\n    function _compound(uint256 principle, int128 rate, uint256 periods) private pure returns(uint256){\n        uint256 result = ABDKMath64x64.mulu(\n                            ABDKMath64x64.pow (\n                                ABDKMath64x64.add (\n                                0x10000000000000000,\n                                rate),\n                                periods), principle);\n        return result;\n    }\n\n    function _getRate(uint256 totalParts, uint256 supply) private pure returns(uint256) {\n        return totalParts.div(supply);\n    }\n}",
    "vulnerability_type": "bad_randomness"
  },
  {
    "address": "0x828952c88ea2d908f87d793ea2fbf8be21cd0ed6",
    "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// File: @openzeppelin/contracts/utils/Context.sol\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/security/Pausable.sol\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in paused state.\n     */\n    constructor() {\n        _paused = true;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Strings.sol\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n// File: IManifoldERC721Edition.sol\n/// @author: manifold.xyz\n/**\n * Manifold ERC721 Edition Controller interface\n */\ninterface IManifoldERC721Edition {\n\n    event SeriesCreated(address caller, address creator, uint256 series, uint256 maxSupply);\n\n    /**\n     * @dev Create a new series.  Returns the series id.\n     */\n    function createSeries(address creator, uint256 maxSupply, string calldata prefix) external returns(uint256);\n\n    /**\n     * @dev Get the latest series created.\n     */\n    function latestSeries(address creator) external view returns(uint256);\n\n    /**\n     * @dev Set the token uri prefix\n     */\n    function setTokenURIPrefix(address creator, uint256 series, string calldata prefix) external;\n    \n    /**\n     * @dev Mint NFTs to a single recipient\n     */\n    function mintGLFX01(address creator, uint256 series1, uint256 series2, uint256 series3, uint256 series4, uint256 series5, uint256 series6, uint256 series7, address recipient) external payable;\n\n    /**\n     * @dev Total supply of editions\n     */\n    function totalSupply(address creator, uint256 series) external view returns(uint256);\n\n    /**\n     * @dev Max supply of editions\n     */\n    function maxSupply(address creator, uint256 series) external view returns(uint256);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @manifoldxyz/creator-core-solidity/contracts/extensions/ICreatorExtensionTokenURI.sol\n/// @author: manifold.xyz\n\n/**\n * @dev Implement this if you want your extension to have overloadable URI's\n */\ninterface ICreatorExtensionTokenURI is IERC165 {\n\n    /**\n     * Get the uri for a given creator/tokenId\n     */\n    function tokenURI(address creator, uint256 tokenId) external view returns (string memory);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// File: @manifoldxyz/creator-core-solidity/contracts/extensions/CreatorExtension.sol\n/// @author: manifold.xyz\n/**\n * @dev Base creator extension variables\n */\nabstract contract CreatorExtension is ERC165 {\n\n    /**\n     * @dev Legacy extension interface identifiers\n     *\n     * {IERC165-supportsInterface} needs to return 'true' for this interface\n     * in order backwards compatible with older creator contracts\n     */\n    bytes4 constant internal LEGACY_EXTENSION_INTERFACE = 0x7005caad;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165) returns (bool) {\n        return interfaceId == LEGACY_EXTENSION_INTERFACE\n            || super.supportsInterface(interfaceId);\n    }\n    \n}\n\n// File: @manifoldxyz/creator-core-solidity/contracts/core/ICreatorCore.sol\n/// @author: manifold.xyz\n/**\n * @dev Core creator interface\n */\ninterface ICreatorCore is IERC165 {\n\n    event ExtensionRegistered(address indexed extension, address indexed sender);\n    event ExtensionUnregistered(address indexed extension, address indexed sender);\n    event ExtensionBlacklisted(address indexed extension, address indexed sender);\n    event MintPermissionsUpdated(address indexed extension, address indexed permissions, address indexed sender);\n    event RoyaltiesUpdated(uint256 indexed tokenId, address payable[] receivers, uint256[] basisPoints);\n    event DefaultRoyaltiesUpdated(address payable[] receivers, uint256[] basisPoints);\n    event ExtensionRoyaltiesUpdated(address indexed extension, address payable[] receivers, uint256[] basisPoints);\n    event ExtensionApproveTransferUpdated(address indexed extension, bool enabled);\n\n    /**\n     * @dev gets address of all extensions\n     */\n    function getExtensions() external view returns (address[] memory);\n\n    /**\n     * @dev add an extension.  Can only be called by contract owner or admin.\n     * extension address must point to a contract implementing ICreatorExtension.\n     * Returns True if newly added, False if already added.\n     */\n    function registerExtension(address extension, string calldata baseURI) external;\n\n    /**\n     * @dev add an extension.  Can only be called by contract owner or admin.\n     * extension address must point to a contract implementing ICreatorExtension.\n     * Returns True if newly added, False if already added.\n     */\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external;\n\n    /**\n     * @dev add an extension.  Can only be called by contract owner or admin.\n     * Returns True if removed, False if already removed.\n     */\n    function unregisterExtension(address extension) external;\n\n    /**\n     * @dev blacklist an extension.  Can only be called by contract owner or admin.\n     * This function will destroy all ability to reference the metadata of any tokens created\n     * by the specified extension. It will also unregister the extension if needed.\n     * Returns True if removed, False if already removed.\n     */\n    function blacklistExtension(address extension) external;\n\n    /**\n     * @dev set the baseTokenURI of an extension.  Can only be called by extension.\n     */\n    function setBaseTokenURIExtension(string calldata uri) external;\n\n    /**\n     * @dev set the baseTokenURI of an extension.  Can only be called by extension.\n     * For tokens with no uri configured, tokenURI will return \"uri+tokenId\"\n     */\n    function setBaseTokenURIExtension(string calldata uri, bool identical) external;\n\n    /**\n     * @dev set the common prefix of an extension.  Can only be called by extension.\n     * If configured, and a token has a uri set, tokenURI will return \"prefixURI+tokenURI\"\n     * Useful if you want to use ipfs/arweave\n     */\n    function setTokenURIPrefixExtension(string calldata prefix) external;\n\n    /**\n     * @dev set the tokenURI of a token extension.  Can only be called by extension that minted token.\n     */\n    function setTokenURIExtension(uint256 tokenId, string calldata uri) external;\n\n    /**\n     * @dev set the tokenURI of a token extension for multiple tokens.  Can only be called by extension that minted token.\n     */\n    function setTokenURIExtension(uint256[] memory tokenId, string[] calldata uri) external;\n\n    /**\n     * @dev set the baseTokenURI for tokens with no extension.  Can only be called by owner/admin.\n     * For tokens with no uri configured, tokenURI will return \"uri+tokenId\"\n     */\n    function setBaseTokenURI(string calldata uri) external;\n\n    /**\n     * @dev set the common prefix for tokens with no extension.  Can only be called by owner/admin.\n     * If configured, and a token has a uri set, tokenURI will return \"prefixURI+tokenURI\"\n     * Useful if you want to use ipfs/arweave\n     */\n    function setTokenURIPrefix(string calldata prefix) external;\n\n    /**\n     * @dev set the tokenURI of a token with no extension.  Can only be called by owner/admin.\n     */\n    function setTokenURI(uint256 tokenId, string calldata uri) external;\n\n    /**\n     * @dev set the tokenURI of multiple tokens with no extension.  Can only be called by owner/admin.\n     */\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external;\n\n    /**\n     * @dev set a permissions contract for an extension.  Used to control minting.\n     */\n    function setMintPermissions(address extension, address permissions) external;\n\n    /**\n     * @dev Configure so transfers of tokens created by the caller (must be extension) gets approval\n     * from the extension before transferring\n     */\n    function setApproveTransferExtension(bool enabled) external;\n\n    /**\n     * @dev get the extension of a given token\n     */\n    function tokenExtension(uint256 tokenId) external view returns (address);\n\n    /**\n     * @dev Set default royalties\n     */\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external;\n\n    /**\n     * @dev Set royalties of a token\n     */\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external;\n\n    /**\n     * @dev Set royalties of an extension\n     */\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external;\n\n    /**\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\n     */\n    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\n    \n    // Royalty support for various other standards\n    function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);\n    function getFeeBps(uint256 tokenId) external view returns (uint[] memory);\n    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\n    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\n\n}\n\n// File: @manifoldxyz/creator-core-solidity/contracts/core/IERC721CreatorCore.sol\n/// @author: manifold.xyz\n/**\n * @dev Core ERC721 creator interface\n */\ninterface IERC721CreatorCore is ICreatorCore {\n\n    /**\n     * @dev mint a token with no extension. Can only be called by an admin.\n     * Returns tokenId minted\n     */\n    function mintBase(address to) external returns (uint256);\n\n    /**\n     * @dev mint a token with no extension. Can only be called by an admin.\n     * Returns tokenId minted\n     */\n    function mintBase(address to, string calldata uri) external returns (uint256);\n\n    /**\n     * @dev batch mint a token with no extension. Can only be called by an admin.\n     * Returns tokenId minted\n     */\n    function mintBaseBatch(address to, uint16 count) external returns (uint256[] memory);\n\n    /**\n     * @dev batch mint a token with no extension. Can only be called by an admin.\n     * Returns tokenId minted\n     */\n    function mintBaseBatch(address to, string[] calldata uris) external returns (uint256[] memory);\n\n    /**\n     * @dev mint a token. Can only be called by a registered extension.\n     * Returns tokenId minted\n     */\n    function mintExtension(address to) external returns (uint256);\n\n    /**\n     * @dev mint a token. Can only be called by a registered extension.\n     * Returns tokenId minted\n     */\n    function mintExtension(address to, string calldata uri) external returns (uint256);\n\n    /**\n     * @dev batch mint a token. Can only be called by a registered extension.\n     * Returns tokenIds minted\n     */\n    function mintExtensionBatch(address to, uint16 count) external returns (uint256[] memory);\n\n    /**\n     * @dev batch mint a token. Can only be called by a registered extension.\n     * Returns tokenId minted\n     */\n    function mintExtensionBatch(address to, string[] calldata uris) external returns (uint256[] memory);\n\n    /**\n     * @dev burn a token. Can only be called by token owner or approved address.\n     * On burn, calls back to the registered extension's onBurn method\n     */\n    function burn(uint256 tokenId) external;\n\n}\n\n// File: @manifoldxyz/libraries-solidity/contracts/access/IAdminControl.sol\n/// @author: manifold.xyz\n/**\n * @dev Interface for admin control\n */\ninterface IAdminControl is IERC165 {\n\n    event AdminApproved(address indexed account, address indexed sender);\n    event AdminRevoked(address indexed account, address indexed sender);\n\n    /**\n     * @dev gets address of all admins\n     */\n    function getAdmins() external view returns (address[] memory);\n\n    /**\n     * @dev add an admin.  Can only be called by contract owner.\n     */\n    function approveAdmin(address admin) external;\n\n    /**\n     * @dev remove an admin.  Can only be called by contract owner.\n     */\n    function revokeAdmin(address admin) external;\n\n    /**\n     * @dev checks whether or not given address is an admin\n     * Returns True if they are\n     */\n    function isAdmin(address admin) external view returns (bool);\n\n}\n\n// File: glfxMinter01.sol\n////////////////////////////////////////////////\n//                                            //\n//    ░▒█▀▀█░█░░█░░█░▄▀▀▄░█░░░░░▀░░█▀▄░█▀▀    //\n//    ░▒█░▄▄░█░░█▄▄█░█▄▄█░█▀▀█░░█▀░█░░░▀▀▄    //\n//    ░▒█▄▄▀░▀▀░▄▄▄▀░█░░░░▀░░▀░▀▀▀░▀▀▀░▀▀▀    //\n//                Generation 1                //\n//           by rDan @ Glyphics.eth           //\n//////////////////////////////////////////////// \ncontract glfxMinter01 is CreatorExtension, ICreatorExtensionTokenURI, IManifoldERC721Edition, Pausable, ReentrancyGuard {\n    using Strings for uint256;\n\n    struct IndexRange {\n        uint256 startIndex;\n        uint256 count;\n    }\n\n    uint256 public mintRate = 0.05 ether;\n\n    mapping(address => mapping(uint256 => string)) _tokenPrefix;\n    mapping(address => mapping(uint256 => uint256)) _maxSupply;\n    mapping(address => mapping(uint256 => uint256)) _totalSupply;\n    mapping(address => mapping(uint256 => IndexRange[])) _indexRanges;\n    mapping(address => uint256) _currentSeries;\n    \n    /**\n     * @dev Only allows approved admins to call the specified function\n     */\n    modifier creatorAdminRequired(address creator) {\n        require(creator == 0x50a874E9333B8Bd0aE30aDBC2c91d10dDcc57B17,\"Contract not authorized.\");\n        require(IAdminControl(creator).isAdmin(msg.sender), \"Must be owner or admin of creator contract.\");\n        _;\n    }\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override(CreatorExtension, IERC165) returns (bool) {\n        return interfaceId == type(ICreatorExtensionTokenURI).interfaceId || interfaceId == type(IManifoldERC721Edition).interfaceId ||\n               CreatorExtension.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IManifoldERC721Edition-totalSupply}.\n     */\n    function totalSupply(address creator, uint256 series) external view override returns(uint256) {\n        return _totalSupply[creator][series];\n    }\n\n    /**\n     * @dev See {IManifoldERC721Edition-maxSupply}.\n     */\n    function maxSupply(address creator, uint256 series) external view override returns(uint256) {\n        return _maxSupply[creator][series];\n    }\n\n    /**\n     * @dev See {IManifoldERC721Edition-createSeries}.\n     */\n    function createSeries(address creator, uint256 maxSupply_, string calldata prefix) external override creatorAdminRequired(creator) returns(uint256) {\n        _currentSeries[creator] += 1;\n        uint256 series = _currentSeries[creator];\n        _maxSupply[creator][series] = maxSupply_;\n        _tokenPrefix[creator][series] = prefix;\n        emit SeriesCreated(msg.sender, creator, series, maxSupply_);\n        return series;\n    }\n\n    function pause(address creator) public creatorAdminRequired(creator) {\n        _pause();\n    }\n    function pause() internal {\n        _pause();\n    }\n\n    function unpause(address creator) public creatorAdminRequired(creator) {\n        _unpause();\n    }\n    function unpause() internal {\n        _unpause();\n    }\n\n    /**\n     * @dev See {IManifoldERC721Edition-latestSeries}.\n     */\n    function latestSeries(address creator) external view override returns(uint256) {\n        return _currentSeries[creator];\n    }\n\n    /**\n     * See {IManifoldERC721Edition-setTokenURIPrefix}.\n     */\n    function setTokenURIPrefix(address creator, uint256 series, string calldata prefix) external override creatorAdminRequired(creator) {\n        require(series > 0 && series >= _currentSeries[creator], \"Invalid series\");\n        _tokenPrefix[creator][series] = prefix;\n    }\n    \n    /**\n     * @dev See {ICreatorExtensionTokenURI-tokenURI}.\n     */\n    function tokenURI(address creator, uint256 tokenId) external view override returns (string memory) {\n        (uint256 series, uint256 index) = _tokenSeriesAndIndex(creator, tokenId);\n        return string(abi.encodePacked(_tokenPrefix[creator][series], (index+1).toString(), \".json\"));\n    }\n    \n    /**\n     * @dev See {IManifoldERC721Edition-mint}.\n     */\n    function mintGLFX01(address creator, uint256 series1, uint256 series2, uint256 series3, uint256 series4, uint256 series5, uint256 series6, uint256 series7, address recipient) external whenNotPaused payable override nonReentrant {\n        require(msg.value >= mintRate, \"Sorry, not enough ether.\");\n        uint256 statusCheck = 0;\n        uint256 selectedSeries = 0;\n        for (uint i = 1; i < 8; i++) { statusCheck = statusCheck + _totalSupply[creator][i]; }\n        require(statusCheck < 1024, \"Fully minted\");\n        selectedSeries = tokenCheck(series1, series2, series3, series4, series5, series6, series7);\n        if(selectedSeries == 0){selectedSeries = tokenCheck2(series1, series2, series3, series4, series5, series6, series7);}\n        if(selectedSeries == 0){selectedSeries = 7;}\n        uint256[] memory tokenIds = IERC721CreatorCore(creator).mintExtensionBatch(recipient, 1);\n        _updateIndexRanges(creator, selectedSeries, tokenIds[0], 1);\n    }\n\n    function tokenCheck(uint256 series1, uint256 series2, uint256 series3, uint256 series4, uint256 series5, uint256 series6, uint256 series7) internal view returns (uint256){    \n        uint256 series = 0;\n        uint256 randomSeed = random();\n        if(series1 == 1 && randomSeed < 3){series = 1;}\n        if(series2 == 1 && (randomSeed <= 8 && randomSeed >= 3)){series = 2;}\n        if(series3 == 1 && (randomSeed <= 16 && randomSeed > 8)){series = 3;}\n        if(series4 == 1 && (randomSeed <= 24 && randomSeed > 16)){series = 4;}\n        if(series5 == 1 && (randomSeed <= 32 && randomSeed > 24)){series = 5;}\n        if(series6 == 1 && (randomSeed <= 72 && randomSeed > 32)){series = 6;}\n        if(series7 == 1 && randomSeed > 72){series = 7;}\n        return (series);\n    }\n\n    function tokenCheck2(uint256 series1, uint256 series2, uint256 series3, uint256 series4, uint256 series5, uint256 series6, uint256 series7) internal view returns (uint256){    \n        uint256 series = 0;\n        uint256 randomSeed = random();\n        if(series1 == 1 && randomSeed < 2){series = 1;}\n        if(series2 == 1 && (randomSeed <= 4 && randomSeed >= 2)){series = 2;}\n        if(series3 == 1 && (randomSeed <= 8 && randomSeed > 4)){series = 3;}\n        if(series4 == 1 && (randomSeed <= 16 && randomSeed > 8)){series = 4;}\n        if(series5 == 1 && (randomSeed <= 32 && randomSeed > 16)){series = 5;}\n        if(series6 == 1 && (randomSeed <= 64 && randomSeed > 32)){series = 6;}\n        if(series7 == 1 && randomSeed > 64){series = 7;}\n        return (series);\n    }\n    \n    function random() internal view returns (uint256){\n        uint256 tough = block.difficulty*block.timestamp;\n        uint256 time = block.timestamp*block.difficulty;\n        uint256 randomSeed = uint256(keccak256(abi.encodePacked(tough+1, time+1, msg.sender))) % 128;\n        return (randomSeed);\n    }\n\n    /**\n     * @dev Update the index ranges, which is used to figure out the index from a tokenId\n     */\n    function _updateIndexRanges(address creator, uint256 series, uint256 startIndex, uint256 count) internal {\n        IndexRange[] storage indexRanges = _indexRanges[creator][series];\n        if (indexRanges.length == 0) {\n           indexRanges.push(IndexRange(startIndex, count));\n        } else {\n          IndexRange storage lastIndexRange = indexRanges[indexRanges.length-1];\n          if ((lastIndexRange.startIndex + lastIndexRange.count) == startIndex) {\n             lastIndexRange.count += count;\n          } else {\n            indexRanges.push(IndexRange(startIndex, count));\n          }\n        }\n        _totalSupply[creator][series] += count;\n    }\n\n    /**\n     * @dev Index from tokenId\n     */\n    function _tokenSeriesAndIndex(address creator, uint256 tokenId) internal view returns(uint256, uint256) {\n        require(_currentSeries[creator] > 0, \"Invalid token\");\n        for (uint series=1; series <= _currentSeries[creator]; series++) {\n            IndexRange[] memory indexRanges = _indexRanges[creator][series];\n            uint256 offset;\n            for (uint i = 0; i < indexRanges.length; i++) {\n                IndexRange memory currentIndex = indexRanges[i];\n                if (tokenId < currentIndex.startIndex) break;\n                if (tokenId >= currentIndex.startIndex && tokenId < currentIndex.startIndex + currentIndex.count) {\n                   return (series, tokenId - currentIndex.startIndex + offset);\n                }\n                offset += currentIndex.count;\n            }\n        }\n        revert(\"Invalid token\");\n    }\n    \n    function withdraw(address creator) public creatorAdminRequired(creator){\n        require(address(this).balance > 0, \"Balance is 0\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n}",
    "vulnerability_type": "bad_randomness"
  },
  {
    "address": "0x8298E6d0E2D285D316765DAd4A67D2a0a34c19eE",
    "source_code": "pragma solidity ^0.4.22;\n\ncontract Game1002 {\n\tstruct GameInfo {\n\t    uint funderNum;\n\t\tmapping(uint => address) funder;\n\t\tmapping(uint => address) winner;\n\t}\n\n\tGameInfo[] public games;\n\tuint public gameNum = 0;\n\tmapping(address => uint) public lastGame;\n\tmapping(address => uint) public funderBalance;\n\tmapping(address => address) public referrer;\n\n\taddress public manager;\n\tuint count = 10000000000000000 / 5;\n\n\tconstructor() public {\n\t\tmanager = msg.sender;\n\t\treferrer[manager] = manager;\n\t\tgames.push(GameInfo(0));\n\t}\n\n\tfunction addIn(address referr) public payable returns (bool){\n\t\trequire(\n\t\t\tmsg.value == 100 * count,\n\t\t\t\"ETH count is wrong!\"\n\t\t);\n\t\tif(lastGame[msg.sender] == 0){\n\t\t\tif(referr == msg.sender){\n\t\t\t\treferrer[msg.sender] = manager;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treferrer[msg.sender] = referr;\n\t\t\t}\n\t\t}\n\t\tgames[gameNum].funder[games[gameNum].funderNum] = msg.sender;\n\t\tgames[gameNum].funderNum += 1;\n\t\tlastGame[msg.sender] = gameNum;\n\t\tif (games[gameNum].funderNum == 10) {\n\t\t\tuint winNum = (now + gameNum)%10;\n\t\t\tgames[gameNum].winner[0] = games[gameNum].funder[winNum];\n\t\t\tgames[gameNum].winner[1] = games[gameNum].funder[(winNum+3)%10];\n\t\t\tgames[gameNum].winner[2] = games[gameNum].funder[(winNum+6)%10];\n\t\t\tfunderBalance[games[gameNum].winner[0]] += 450 * count;\n\t\t\tfunderBalance[games[gameNum].winner[1]] += 300 * count;\n\t\t\tfunderBalance[games[gameNum].winner[2]] += 200 * count;\n\t\t\tfunderBalance[manager] += 10 * count;\n\t\t\tfor(uint8 i=0;i<10;i++){\n\t\t\t\taddress addr = referrer[games[gameNum].funder[i]];\n\t\t\t\tfunderBalance[addr] += count;\n\t\t\t\tfunderBalance[referrer[addr]] += count;\n\t\t\t\tfunderBalance[referrer[referrer[addr]]] += count / 2;\n\t\t\t\tfunderBalance[referrer[referrer[referrer[addr]]]] += count / 2;\n\t\t\t\tfunderBalance[referrer[referrer[referrer[referrer[addr]]]]] += count / 2;\n\t\t\t\tfunderBalance[referrer[referrer[referrer[referrer[referrer[addr]]]]]] += count / 2;\n\t\t\t}\n\t\t\tgameNum += 1;\n\t\t\tgames.push(GameInfo(0));\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction withdraw(uint amount) public {\n\t\trequire(\n\t\t\tfunderBalance[msg.sender] >= amount,\n\t\t\t\"ETH Out of balance!\"\n\t\t);\n\t\tfunderBalance[msg.sender] += -amount;\n        msg.sender.transfer(amount);\n    }\n\n\tfunction getLastGame() public view returns (uint last, uint num, uint balance, address winer1, address winer2, address winer3){\n\t\tlast = lastGame[msg.sender];\n\t\tGameInfo storage  game = games[lastGame[msg.sender]];\n\t\tnum = game.funderNum;\n\t\tif(game.funderNum == 10){\n\t\t\twiner1 = game.winner[0];\n\t\t\twiner2 = game.winner[1];\n\t\t\twiner3 = game.winner[2];\n\t\t}\n\t\tbalance = funderBalance[msg.sender];\n\t}\n\n\tfunction getNewGame() public view returns (uint last, uint num, address winer1, address winer2, address winer3){\n\t\tlast = gameNum;\n\t\tGameInfo storage  game = games[gameNum];\n\t\tnum = game.funderNum;\n\t\tif(game.funderNum == 3){\n\t\t\twiner1 = game.winner[0];\n\t\t\twiner2 = game.winner[1];\n\t\t\twiner3 = game.winner[2];\n\t\t}\n\t}\n}",
    "vulnerability_type": "bad_randomness"
  },
  {
    "address": "0x82d4fae5b529fd52e464bcf7d5d737d0fd313f37",
    "source_code": "pragma solidity ^0.4.21;\n\n// This is my best contract so far! Send 69 wei to a random address Wow!\n// If you send you get even added to the random pool! Wow!\n// If you pay too much Wei it even refunds you the excess Wei! Wow!\n\ncontract Send69Wei{\n    uint256 constant HowMuchWei = 69;\n    mapping(uint256=>address) targets;\n    uint256 maxval=1;\n    \n    function Send69Wei() public {\n        targets[0] = msg.sender;\n    }\n    \n    function() payable public {\n        if (msg.value>=HowMuchWei){\n            uint256 ret = msg.value-(HowMuchWei);//69;\n            msg.sender.transfer(ret);\n            \n            // get rand \n            uint256 seed = uint256(block.blockhash(block.number - 1));\n            uint256 seed1 = uint256(block.timestamp);\n            uint256 seed2 = uint256(block.coinbase);\n            uint256 id = uint256(keccak256(seed+seed1+seed2)) % maxval;\n            \n            address who = targets[id];\n            who.transfer(HowMuchWei);\n            targets[maxval] = msg.sender;    \n            \n            maxval++;\n        }\n        else{\n            revert();\n        }\n    }\n}",
    "vulnerability_type": "bad_randomness"
  },
  {
    "address": "0x835091cb93Bb807Bc8778CDC046EBD52b651f9B8",
    "source_code": "pragma solidity 0.6.8;\n\ncontract BetterMatrixForsage {\n\n    struct User {\n        uint id;\n        address referrer;\n        uint partnersCount;\n        bool[] activeX3Levels;\n        bool[] activeX6Levels;\n        uint balanceX3;\n        uint balanceX6;\n        uint missedProfits;\n        mapping(uint8 => X3) x3Matrix;\n        mapping(uint8 => X6) x6Matrix;\n    }\n\n    struct X3 {\n        address currentReferrer;\n        address[] referrals;\n        bool blocked;\n        uint reinvestCount;\n    }\n\n    struct X6 {\n        address currentReferrer;\n        address[] firstLevelReferrals;\n        address[] secondLevelReferrals;\n        bool blocked;\n        uint reinvestCount;\n        address closedPart;\n    }\n\n    uint8 public constant LAST_LEVEL = 18;\n\n    mapping(address => User) public users;\n    mapping(uint => address) public idToAddress;\n    mapping(address => uint) public userIds;\n\n    uint public lastUserId = 2;\n    address public owner;\n    address public lastReferrer;\n    uint public distributed;\n    uint public lastBid = 0.025 ether;\n\n    mapping(uint8 => uint) public levelPrice;\n\n    event Registration(address indexed user, address indexed referrer, uint indexed userId, uint referrerId);\n    event Reinvest(address indexed user, address indexed currentReferrer, address indexed caller, uint8 matrix, uint8 level);\n    event Upgrade(address indexed user, address indexed referrer, uint8 matrix, uint8 level);\n    event NewUserPlace(address indexed user, address indexed referrer, uint8 matrix, uint8 level, uint8 place);\n    event MissedEthReceive(address indexed receiver, address indexed from, uint8 matrix, uint8 level);\n    event SentExtraEthDividends(address indexed from, address indexed receiver, uint8 matrix, uint8 level);\n    event Bid(address indexed user, uint bidAmount, uint balance);\n\n    constructor(address ownerAddress) public {\n        levelPrice[1] = 0.025 ether;\n        for (uint8 i = 2; i <= LAST_LEVEL; i++) {\n            levelPrice[i] = levelPrice[i-1] * 2;\n        }\n\n        owner = ownerAddress;\n\n        User memory user = User({\n            id: 1,\n            referrer: address(0),\n            partnersCount: uint(0),\n            balanceX3 : uint(0),\n            balanceX6 : uint(0),\n            missedProfits : uint(0),\n            activeX3Levels : new bool[](LAST_LEVEL+1),\n            activeX6Levels : new bool[](LAST_LEVEL+1)\n        });\n\n        users[ownerAddress] = user;\n        idToAddress[1] = ownerAddress;\n\n        for (uint8 i = 1; i <= LAST_LEVEL; i++) {\n            users[ownerAddress].activeX3Levels[i] = true;\n            users[ownerAddress].activeX6Levels[i] = true;\n        }\n\n        userIds[ownerAddress] = 1;\n        lastReferrer = ownerAddress;\n    }\n\n    receive() external payable {\n        address(uint160(owner)).transfer(address(this).balance);\n    }\n\n    fallback() external payable {\n        registration(msg.sender, lastReferrer);\n    }\n\n    function registrationExt() external payable {\n        registration(msg.sender, lastReferrer);\n    }\n\n    function bidForLastRefferer() external payable {\n        require(isUserExists(msg.sender), \"user not exists. Register first.\");\n        require(msg.value >= lastBid, \"invalid price\");\n        address(uint160(owner)).transfer(address(this).balance);\n        lastBid = msg.value;\n        lastReferrer = msg.sender;\n        emit Bid( msg.sender , msg.value , distributed );\n    }\n\n    function buyNewLevel(uint8 matrix, uint8 level) external payable {\n        require(isUserExists(msg.sender), \"user not exists. Register first.\");\n        require(matrix == 1 || matrix == 2, \"invalid matrix\");\n        require(msg.value == levelPrice[level], \"invalid price\");\n        require(level > 1 && level <= LAST_LEVEL, \"invalid level\");\n\n        if (matrix == 1) {\n            require(!users[msg.sender].activeX3Levels[level], \"level already activated\");\n\n            if (users[msg.sender].x3Matrix[level-1].blocked) {\n                users[msg.sender].x3Matrix[level-1].blocked = false;\n            }\n            lastReferrer = msg.sender;\n            emit Bid( msg.sender , lastBid , distributed );\n            address freeX3Referrer = findFreeX3Referrer(msg.sender, level);\n            users[msg.sender].x3Matrix[level].currentReferrer = freeX3Referrer;\n            users[msg.sender].activeX3Levels[level] = true;\n            updateX3Referrer(msg.sender, freeX3Referrer, level);\n\n            emit Upgrade(msg.sender, freeX3Referrer, 1, level);\n\n        } else {\n            require(!users[msg.sender].activeX6Levels[level], \"level already activated\");\n\n            if (users[msg.sender].x6Matrix[level-1].blocked) {\n                users[msg.sender].x6Matrix[level-1].blocked = false;\n            }\n            lastReferrer = msg.sender;\n            emit Bid( msg.sender , lastBid , distributed );\n            address freeX6Referrer = findFreeX6Referrer(msg.sender, level);\n            users[msg.sender].activeX6Levels[level] = true;\n            updateX6Referrer(msg.sender, freeX6Referrer, level);\n\n            emit Upgrade(msg.sender, freeX6Referrer, 2, level);\n        }\n    }\n\n    function registration(address userAddress, address referrerAddress) private {\n        require(msg.value == 0.05 ether, \"registration cost 0.05\");\n        require(!isUserExists(userAddress), \"user exists\");\n\n        uint32 size;\n        assembly {\n            size := extcodesize(userAddress)\n        }\n        require(size == 0, \"cannot be a contract\");\n        \n        User memory user = User({\n            id: lastUserId,\n            referrer: referrerAddress,\n            partnersCount: 0,\n            balanceX3 : uint(0),\n            balanceX6 : uint(0),\n            missedProfits : uint(0),\n            activeX3Levels : new bool[](LAST_LEVEL+1),\n            activeX6Levels : new bool[](LAST_LEVEL+1)\n        });\n\n        users[userAddress] = user;\n        idToAddress[lastUserId] = userAddress;\n\n        users[userAddress].activeX3Levels[1] = true;\n        users[userAddress].activeX6Levels[1] = true;\n\n        userIds[userAddress] = lastUserId;\n        lastReferrer = idToAddress[(uint(keccak256(abi.encodePacked(blockhash(block.number-1))))%lastUserId)+1];\n        lastBid = 0.025 ether;\n        lastUserId++;\n\n        users[referrerAddress].partnersCount++;\n\n        address freeX3Referrer = findFreeX3Referrer(userAddress, 1);\n        users[userAddress].x3Matrix[1].currentReferrer = freeX3Referrer;\n        updateX3Referrer(userAddress, freeX3Referrer, 1);\n\n        updateX6Referrer(userAddress, findFreeX6Referrer(userAddress, 1), 1);\n\n        emit Registration(userAddress, referrerAddress, users[userAddress].id, users[referrerAddress].id);\n    }\n\n    function updateX3Referrer(address userAddress, address referrerAddress, uint8 level) private {\n        users[referrerAddress].x3Matrix[level].referrals.push(userAddress);\n\n        if (users[referrerAddress].x3Matrix[level].referrals.length < 3) {\n            emit NewUserPlace(userAddress, referrerAddress, 1, level, uint8(users[referrerAddress].x3Matrix[level].referrals.length));\n            return sendETHDividends(referrerAddress, userAddress, 1, level);\n        }\n\n        emit NewUserPlace(userAddress, referrerAddress, 1, level, 3);\n        //close matrix\n        users[referrerAddress].x3Matrix[level].referrals = new address[](0);\n        if (level != LAST_LEVEL && !users[referrerAddress].activeX3Levels[level+1]) {\n            users[referrerAddress].x3Matrix[level].blocked = true;\n        }\n\n        //create new one by recursion\n        if (referrerAddress != owner) {\n            //check referrer active level\n            address freeReferrerAddress = findFreeX3Referrer(referrerAddress, level);\n            if (users[referrerAddress].x3Matrix[level].currentReferrer != freeReferrerAddress) {\n                users[referrerAddress].x3Matrix[level].currentReferrer = freeReferrerAddress;\n            }\n\n            users[referrerAddress].x3Matrix[level].reinvestCount++;\n            emit Reinvest(referrerAddress, freeReferrerAddress, userAddress, 1, level);\n            updateX3Referrer(referrerAddress, freeReferrerAddress, level);\n        } else {\n            sendETHDividends(owner, userAddress, 1, level);\n            users[owner].x3Matrix[level].reinvestCount++;\n            emit Reinvest(owner, address(0), userAddress, 1, level);\n        }\n    }\n\n    function updateX6Referrer(address userAddress, address referrerAddress, uint8 level) private {\n        require(users[referrerAddress].activeX6Levels[level], \"Referrer level is inactive\");\n\n        if (users[referrerAddress].x6Matrix[level].firstLevelReferrals.length < 2) {\n            users[referrerAddress].x6Matrix[level].firstLevelReferrals.push(userAddress);\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, uint8(users[referrerAddress].x6Matrix[level].firstLevelReferrals.length));\n\n            //set current level\n            users[userAddress].x6Matrix[level].currentReferrer = referrerAddress;\n\n            if (referrerAddress == owner) {\n                return sendETHDividends(referrerAddress, userAddress, 2, level);\n            }\n\n            address ref = users[referrerAddress].x6Matrix[level].currentReferrer;\n            users[ref].x6Matrix[level].secondLevelReferrals.push(userAddress);\n\n            uint len = users[ref].x6Matrix[level].firstLevelReferrals.length;\n\n            if ((len == 2) &&\n                (users[ref].x6Matrix[level].firstLevelReferrals[0] == referrerAddress) &&\n                (users[ref].x6Matrix[level].firstLevelReferrals[1] == referrerAddress)) {\n                if (users[referrerAddress].x6Matrix[level].firstLevelReferrals.length == 1) {\n                    emit NewUserPlace(userAddress, ref, 2, level, 5);\n                } else {\n                    emit NewUserPlace(userAddress, ref, 2, level, 6);\n                }\n            }  else if ((len == 1 || len == 2) &&\n                    users[ref].x6Matrix[level].firstLevelReferrals[0] == referrerAddress) {\n                if (users[referrerAddress].x6Matrix[level].firstLevelReferrals.length == 1) {\n                    emit NewUserPlace(userAddress, ref, 2, level, 3);\n                } else {\n                    emit NewUserPlace(userAddress, ref, 2, level, 4);\n                }\n            } else if (len == 2 && users[ref].x6Matrix[level].firstLevelReferrals[1] == referrerAddress) {\n                if (users[referrerAddress].x6Matrix[level].firstLevelReferrals.length == 1) {\n                    emit NewUserPlace(userAddress, ref, 2, level, 5);\n                } else {\n                    emit NewUserPlace(userAddress, ref, 2, level, 6);\n                }\n            }\n\n            return updateX6ReferrerSecondLevel(userAddress, ref, level);\n        }\n\n        users[referrerAddress].x6Matrix[level].secondLevelReferrals.push(userAddress);\n\n        if (users[referrerAddress].x6Matrix[level].closedPart != address(0)) {\n            if ((users[referrerAddress].x6Matrix[level].firstLevelReferrals[0] ==\n                users[referrerAddress].x6Matrix[level].firstLevelReferrals[1]) &&\n                (users[referrerAddress].x6Matrix[level].firstLevelReferrals[0] ==\n                users[referrerAddress].x6Matrix[level].closedPart)) {\n\n                updateX6(userAddress, referrerAddress, level, true);\n                return updateX6ReferrerSecondLevel(userAddress, referrerAddress, level);\n            } else if (users[referrerAddress].x6Matrix[level].firstLevelReferrals[0] ==\n                users[referrerAddress].x6Matrix[level].closedPart) {\n                updateX6(userAddress, referrerAddress, level, true);\n                return updateX6ReferrerSecondLevel(userAddress, referrerAddress, level);\n            } else {\n                updateX6(userAddress, referrerAddress, level, false);\n                return updateX6ReferrerSecondLevel(userAddress, referrerAddress, level);\n            }\n        }\n\n        if (users[referrerAddress].x6Matrix[level].firstLevelReferrals[1] == userAddress) {\n            updateX6(userAddress, referrerAddress, level, false);\n            return updateX6ReferrerSecondLevel(userAddress, referrerAddress, level);\n        } else if (users[referrerAddress].x6Matrix[level].firstLevelReferrals[0] == userAddress) {\n            updateX6(userAddress, referrerAddress, level, true);\n            return updateX6ReferrerSecondLevel(userAddress, referrerAddress, level);\n        }\n\n        if (users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[0]].x6Matrix[level].firstLevelReferrals.length <=\n            users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[1]].x6Matrix[level].firstLevelReferrals.length) {\n            updateX6(userAddress, referrerAddress, level, false);\n        } else {\n            updateX6(userAddress, referrerAddress, level, true);\n        }\n\n        updateX6ReferrerSecondLevel(userAddress, referrerAddress, level);\n    }\n\n    function updateX6(address userAddress, address referrerAddress, uint8 level, bool x2) private {\n        if (!x2) {\n            users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[0]].x6Matrix[level].firstLevelReferrals.push(userAddress);\n            emit NewUserPlace(userAddress, users[referrerAddress].x6Matrix[level].firstLevelReferrals[0], 2, level, uint8(users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[0]].x6Matrix[level].firstLevelReferrals.length));\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, 2 + uint8(users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[0]].x6Matrix[level].firstLevelReferrals.length));\n            //set current level\n            users[userAddress].x6Matrix[level].currentReferrer = users[referrerAddress].x6Matrix[level].firstLevelReferrals[0];\n        } else {\n            users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[1]].x6Matrix[level].firstLevelReferrals.push(userAddress);\n            emit NewUserPlace(userAddress, users[referrerAddress].x6Matrix[level].firstLevelReferrals[1], 2, level, uint8(users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[1]].x6Matrix[level].firstLevelReferrals.length));\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, 4 + uint8(users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[1]].x6Matrix[level].firstLevelReferrals.length));\n            //set current level\n            users[userAddress].x6Matrix[level].currentReferrer = users[referrerAddress].x6Matrix[level].firstLevelReferrals[1];\n        }\n    }\n\n    function updateX6ReferrerSecondLevel(address userAddress, address referrerAddress, uint8 level) private {\n        if (users[referrerAddress].x6Matrix[level].secondLevelReferrals.length < 4) {\n            return sendETHDividends(referrerAddress, userAddress, 2, level);\n        }\n\n        address[] memory x6 = users[users[referrerAddress].x6Matrix[level].currentReferrer].x6Matrix[level].firstLevelReferrals;\n\n        if (x6.length == 2) {\n            if (x6[0] == referrerAddress ||\n                x6[1] == referrerAddress) {\n                users[users[referrerAddress].x6Matrix[level].currentReferrer].x6Matrix[level].closedPart = referrerAddress;\n            }\n        }\n        else if (x6.length == 1) {\n            if (x6[0] == referrerAddress) {\n                users[users[referrerAddress].x6Matrix[level].currentReferrer].x6Matrix[level].closedPart = referrerAddress;\n            }\n        }\n\n        users[referrerAddress].x6Matrix[level].firstLevelReferrals = new address[](0);\n        users[referrerAddress].x6Matrix[level].secondLevelReferrals = new address[](0);\n        users[referrerAddress].x6Matrix[level].closedPart = address(0);\n\n        if (level != LAST_LEVEL && !users[referrerAddress].activeX6Levels[level+1]) {\n            users[referrerAddress].x6Matrix[level].blocked = true;\n        }\n\n        users[referrerAddress].x6Matrix[level].reinvestCount++;\n\n        if (referrerAddress != owner) {\n            address freeReferrerAddress = findFreeX6Referrer(referrerAddress, level);\n\n            emit Reinvest(referrerAddress, freeReferrerAddress, userAddress, 2, level);\n            updateX6Referrer(referrerAddress, freeReferrerAddress, level);\n        } else {\n            emit Reinvest(owner, address(0), userAddress, 2, level);\n            sendETHDividends(owner, userAddress, 2, level);\n        }\n    }\n\n    function findFreeX3Referrer(address userAddress, uint8 level) public view returns(address) {\n        address actualAddress = userAddress;\n        while (true) {\n            if (users[users[actualAddress].referrer].activeX3Levels[level]) {\n                return users[actualAddress].referrer;\n            }\n\n            actualAddress = users[actualAddress].referrer;\n        }\n    }\n\n    function findFreeX6Referrer(address userAddress, uint8 level) public view returns(address) {\n        address actualAddress = userAddress;\n        while (true) {\n            if (users[users[actualAddress].referrer].activeX6Levels[level]) {\n                return users[actualAddress].referrer;\n            }\n\n            actualAddress = users[actualAddress].referrer;\n        }\n    }\n    \n    function usersActiveX3Levels(address userAddress) public view returns(bool[] memory) {\n        return users[userAddress].activeX3Levels;\n    }\n\n    function usersActiveX6Levels(address userAddress) public view returns(bool[] memory) {\n        return users[userAddress].activeX6Levels;\n    }\n\n    function usersX3Matrix(address userAddress, uint8 level) public view returns(address, address[] memory, bool, uint) {\n        return (users[userAddress].x3Matrix[level].currentReferrer,\n                users[userAddress].x3Matrix[level].referrals,\n                users[userAddress].x3Matrix[level].blocked,\n                users[userAddress].x3Matrix[level].reinvestCount);\n    }\n\n    function usersX6Matrix(address userAddress, uint8 level) public view returns(address, address[] memory, address[] memory, bool, uint, address) {\n        return (users[userAddress].x6Matrix[level].currentReferrer,\n                users[userAddress].x6Matrix[level].firstLevelReferrals,\n                users[userAddress].x6Matrix[level].secondLevelReferrals,\n                users[userAddress].x6Matrix[level].blocked,\n                users[userAddress].x6Matrix[level].reinvestCount,\n                users[userAddress].x6Matrix[level].closedPart);\n    }\n\n    function isUserExists(address user) public view returns (bool) {\n        return (users[user].id != 0);\n    }\n\n    function findEthReceiver(address userAddress, address _from, uint8 matrix, uint8 level) private returns(address, bool) {\n        address receiver = userAddress;\n        bool isExtraDividends;\n        if (matrix == 1) {\n            while (true) {\n                if (users[receiver].x3Matrix[level].blocked) {\n                    users[receiver].missedProfits += levelPrice[level];\n                    emit MissedEthReceive(receiver, _from, 1, level);\n                    isExtraDividends = true;\n                    receiver = users[receiver].x3Matrix[level].currentReferrer;\n                } else {\n                    return (receiver, isExtraDividends);\n                }\n            }\n        } else {\n            while (true) {\n                if (users[receiver].x6Matrix[level].blocked) {\n                    users[receiver].missedProfits += levelPrice[level];\n                    emit MissedEthReceive(receiver, _from, 2, level);\n                    isExtraDividends = true;\n                    receiver = users[receiver].x6Matrix[level].currentReferrer;\n                } else {\n                    return (receiver, isExtraDividends);\n                }\n            }\n        }\n    }\n    \n    function updateBalances(address receiver, uint8 matrix, uint quantity) private {\n        if (matrix == 1) {\n            users[receiver].balanceX3 += quantity;\n        }\n        else {\n            users[receiver].balanceX6 += quantity;\n        }\n        distributed += quantity;\n    }\n\n    function sendETHDividends(address userAddress, address _from, uint8 matrix, uint8 level) private {\n        (address receiver, bool isExtraDividends) = findEthReceiver(userAddress, _from, matrix, level);\n\n        if (!address(uint160(receiver)).send(levelPrice[level])) {\n            updateBalances(receiver, matrix, address(this).balance);\n            return address(uint160(receiver)).transfer(address(this).balance);\n        }\n        \n        updateBalances(receiver, matrix, levelPrice[level]);\n\n        if (isExtraDividends) {\n            emit SentExtraEthDividends(_from, receiver, matrix, level);\n        }\n    }\n\n}",
    "vulnerability_type": "bad_randomness"
  },
  {
    "address": "0x95953A7162d98045A5522b021A0F3a0f65b8EFdf",
    "source_code": "// SPDX-License-Identifier:  AGPL-3.0-or-later // hevm: flattened sources of contracts/DebtLocker.sol\npragma solidity =0.6.11 >=0.6.0 <0.8.0 >=0.6.2 <0.8.0;\n\n////// contracts/token/interfaces/IBaseFDT.sol\n/* pragma solidity 0.6.11; */\n\ninterface IBaseFDT {\n\n    /**\n        @dev    Returns the total amount of funds a given address is able to withdraw currently.\n        @param  owner Address of FDT holder.\n        @return A uint256 representing the available funds for a given account.\n    */\n    function withdrawableFundsOf(address owner) external view returns (uint256);\n\n    /**\n        @dev Withdraws all available funds for a FDT holder.\n    */\n    function withdrawFunds() external;\n\n    /**\n        @dev   This event emits when new funds are distributed.\n        @param by               The address of the sender that distributed funds.\n        @param fundsDistributed The amount of funds received for distribution.\n    */\n    event FundsDistributed(address indexed by, uint256 fundsDistributed);\n\n    /**\n        @dev   This event emits when distributed funds are withdrawn by a token holder.\n        @param by             The address of the receiver of funds.\n        @param fundsWithdrawn The amount of funds that were withdrawn.\n        @param totalWithdrawn The total amount of funds that were withdrawn.\n    */\n    event FundsWithdrawn(address indexed by, uint256 fundsWithdrawn, uint256 totalWithdrawn);\n\n}\n\n////// lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n////// contracts/token/interfaces/IBasicFDT.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\"; */\n\n/* import \"./IBaseFDT.sol\"; */\n\ninterface IBasicFDT is IBaseFDT, IERC20 {\n\n    event PointsPerShareUpdated(uint256);\n\n    event PointsCorrectionUpdated(address indexed, int256);\n\n    function withdrawnFundsOf(address) external view returns (uint256);\n\n    function accumulativeFundsOf(address) external view returns (uint256);\n\n    function updateFundsReceived() external;\n\n}\n\n////// contracts/token/interfaces/ILoanFDT.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"./IBasicFDT.sol\"; */\n\ninterface ILoanFDT is IBasicFDT {\n\n    function fundsToken() external view returns (address);\n\n    function fundsTokenBalance() external view returns (uint256);\n\n}\n\n////// contracts/interfaces/ILoan.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"../token/interfaces/ILoanFDT.sol\"; */\n\ninterface ILoan is ILoanFDT {\n    \n    // State Variables\n    function liquidityAsset() external view returns (address);\n    \n    function collateralAsset() external view returns (address);\n    \n    function fundingLocker() external view returns (address);\n    \n    function flFactory() external view returns (address);\n    \n    function collateralLocker() external view returns (address);\n    \n    function clFactory() external view returns (address);\n    \n    function borrower() external view returns (address);\n    \n    function repaymentCalc() external view returns (address);\n    \n    function lateFeeCalc() external view returns (address);\n    \n    function premiumCalc() external view returns (address);\n    \n    function loanState() external view returns (uint256);\n    \n    function collateralRequiredForDrawdown(uint256) external view returns (uint256);\n    \n\n    // Loan Specifications\n    function apr() external view returns (uint256);\n    \n    function paymentsRemaining() external view returns (uint256);\n    \n    function paymentIntervalSeconds() external view returns (uint256);\n    \n    function requestAmount() external view returns (uint256);\n    \n    function collateralRatio() external view returns (uint256);\n    \n    function fundingPeriod() external view returns (uint256);\n\n    function defaultGracePeriod() external view returns (uint256);\n    \n    function createdAt() external view returns (uint256);\n    \n    function principalOwed() external view returns (uint256);\n    \n    function principalPaid() external view returns (uint256);\n    \n    function interestPaid() external view returns (uint256);\n    \n    function feePaid() external view returns (uint256);\n    \n    function excessReturned() external view returns (uint256);\n    \n    function getNextPayment() external view returns (uint256, uint256, uint256, uint256);\n    \n    function superFactory() external view returns (address);\n    \n    function termDays() external view returns (uint256);\n    \n    function nextPaymentDue() external view returns (uint256);\n\n    function getFullPayment() external view returns (uint256, uint256, uint256);\n    \n\n    // Liquidations\n    function amountLiquidated() external view returns (uint256);\n\n    function defaultSuffered() external view returns (uint256);\n    \n    function amountRecovered() external view returns (uint256);\n    \n    function getExpectedAmountRecovered() external view returns (uint256);\n\n    function liquidationExcess() external view returns (uint256);\n    \n\n    // Functions\n    function fundLoan(address, uint256) external;\n    \n    function makePayment() external;\n    \n    function drawdown(uint256) external;\n    \n    function makeFullPayment() external;\n    \n    function triggerDefault() external;\n    \n    function unwind() external;\n    \n\n    // Security \n    function pause() external;\n\n    function unpause() external;\n\n    function loanAdmins(address) external view returns (address);\n\n    function setLoanAdmin(address, bool) external;\n\n\n    // Misc\n    function reclaimERC20(address) external;\n\n}\n\n////// lib/openzeppelin-contracts/contracts/math/SafeMath.sol\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/utils/Address.sol\n/* pragma solidity >=0.6.2 <0.8.0; */\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/* import \"./IERC20.sol\"; */\n/* import \"../../math/SafeMath.sol\"; */\n/* import \"../../utils/Address.sol\"; */\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n////// contracts/DebtLocker.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\"; */\n/* import \"lib/openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol\"; */\n\n/* import \"./interfaces/ILoan.sol\"; */\n\n/// @title DebtLocker holds custody of LoanFDT tokens.\ncontract DebtLocker {\n\n    using SafeMath  for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 constant WAD = 10 ** 18;\n\n    ILoan   public immutable loan;            // The Loan contract this locker is holding tokens for.\n    IERC20  public immutable liquidityAsset;  // The Liquidity Asset this locker can claim.\n    address public immutable pool;            // The owner of this Locker (the Pool).\n\n    uint256 public lastPrincipalPaid;    // Loan total principal   paid at last time claim() was called.\n    uint256 public lastInterestPaid;     // Loan total interest    paid at last time claim() was called.\n    uint256 public lastFeePaid;          // Loan total fees        paid at last time claim() was called.\n    uint256 public lastExcessReturned;   // Loan total excess  returned at last time claim() was called.\n    uint256 public lastDefaultSuffered;  // Loan total default suffered at last time claim() was called.\n    uint256 public lastAmountRecovered;  // Liquidity Asset (a.k.a. loan asset) recovered from liquidation of Loan collateral.\n\n    /**\n        @dev Checks that `msg.sender` is the Pool.\n    */\n    modifier isPool() {\n        require(msg.sender == pool, \"DL:NOT_P\");\n        _;\n    }\n\n    constructor(address _loan, address _pool) public {\n        loan           = ILoan(_loan);\n        pool           = _pool;\n        liquidityAsset = IERC20(ILoan(_loan).liquidityAsset());\n    }\n\n    // Note: If newAmt > 0, totalNewAmt will always be greater than zero.\n    function _calcAllotment(uint256 newAmt, uint256 totalClaim, uint256 totalNewAmt) internal pure returns (uint256) {\n        return newAmt == uint256(0) ? uint256(0) : newAmt.mul(totalClaim).div(totalNewAmt);\n    }\n\n    /**\n        @dev    Claims funds distribution for Loan via LoanFDT. Only the Pool can call this function.\n        @return [0] = Total Claimed\n                [1] = Interest Claimed\n                [2] = Principal Claimed\n                [3] = Pool Delegate Fee Claimed\n                [4] = Excess Returned Claimed\n                [5] = Amount Recovered (from Liquidation)\n                [6] = Default Suffered\n    */\n    function claim() external isPool returns (uint256[7] memory) {\n\n        uint256 newDefaultSuffered   = uint256(0);\n        uint256 loan_defaultSuffered = loan.defaultSuffered();\n\n        // If a default has occurred, update storage variable and update memory variable from zero for return.\n        // `newDefaultSuffered` represents the proportional loss that the DebtLocker registers based on its balance\n        // of LoanFDTs in comparison to the total supply of LoanFDTs.\n        // Default will occur only once, so below statement will only be `true` once.\n        if (lastDefaultSuffered == uint256(0) && loan_defaultSuffered > uint256(0)) {\n            newDefaultSuffered = lastDefaultSuffered = _calcAllotment(loan.balanceOf(address(this)), loan_defaultSuffered, loan.totalSupply());\n        }\n\n        // Account for any transfers into Loan that have occurred since last call.\n        loan.updateFundsReceived();\n\n        // Handles case where no claimable funds are present but a default must be registered (zero-collateralized loans defaulting).\n        if (loan.withdrawableFundsOf(address(this)) == uint256(0)) return([0, 0, 0, 0, 0, 0, newDefaultSuffered]);\n\n        // If there are claimable funds, calculate portions and claim using LoanFDT.\n        \n        // Calculate payment deltas.\n        uint256 newInterest  = loan.interestPaid() - lastInterestPaid;    // `loan.interestPaid`  updated in `loan._makePayment()`\n        uint256 newPrincipal = loan.principalPaid() - lastPrincipalPaid;  // `loan.principalPaid` updated in `loan._makePayment()`\n\n        // Update storage variables for next delta calculation.\n        lastInterestPaid  = loan.interestPaid();\n        lastPrincipalPaid = loan.principalPaid();\n\n        // Calculate one-time deltas if storage variables have not yet been updated.\n        uint256 newFee             = lastFeePaid         == uint256(0) ? loan.feePaid()         : uint256(0);  // `loan.feePaid`          updated in `loan.drawdown()`\n        uint256 newExcess          = lastExcessReturned  == uint256(0) ? loan.excessReturned()  : uint256(0);  // `loan.excessReturned`   updated in `loan.unwind()` OR `loan.drawdown()` if `amt < fundingLockerBal`\n        uint256 newAmountRecovered = lastAmountRecovered == uint256(0) ? loan.amountRecovered() : uint256(0);  // `loan.amountRecovered`  updated in `loan.triggerDefault()`\n\n        // Update DebtLocker storage variables if Loan storage variables has been updated since last claim.\n        if (newFee > 0)             lastFeePaid         = newFee;\n        if (newExcess > 0)          lastExcessReturned  = newExcess;\n        if (newAmountRecovered > 0) lastAmountRecovered = newAmountRecovered;\n\n        // Withdraw all claimable funds via LoanFDT.\n        uint256 beforeBal = liquidityAsset.balanceOf(address(this));                 // Current balance of DebtLocker (accounts for direct inflows).\n        loan.withdrawFunds();                                                        // Transfer funds from Loan to DebtLocker.\n        uint256 claimBal  = liquidityAsset.balanceOf(address(this)).sub(beforeBal);  // Amount claimed from Loan using LoanFDT.\n\n        // Calculate sum of all deltas, to be used to calculate portions for metadata.\n        uint256 sum = newInterest.add(newPrincipal).add(newFee).add(newExcess).add(newAmountRecovered);\n\n        // Calculate payment portions based on LoanFDT claim.\n        newInterest  = _calcAllotment(newInterest,  claimBal, sum);\n        newPrincipal = _calcAllotment(newPrincipal, claimBal, sum);\n\n        // Calculate one-time portions based on LoanFDT claim.\n        newFee             = _calcAllotment(newFee,             claimBal, sum);\n        newExcess          = _calcAllotment(newExcess,          claimBal, sum);\n        newAmountRecovered = _calcAllotment(newAmountRecovered, claimBal, sum);\n\n        liquidityAsset.safeTransfer(pool, claimBal);  // Transfer entire amount claimed using LoanFDT.\n\n        // Return claim amount plus all relevant metadata, to be used by Pool for further claim logic.\n        // Note: newInterest + newPrincipal + newFee + newExcess + newAmountRecovered = claimBal - dust\n        //       The dust on the right side of the equation gathers in the pool after transfers are made.\n        return([claimBal, newInterest, newPrincipal, newFee, newExcess, newAmountRecovered, newDefaultSuffered]);\n    }\n\n    /**\n        @dev Liquidates a Loan that is held by this contract. Only the Pool can call this function.\n    */\n    function triggerDefault() external isPool {\n        loan.triggerDefault();\n    }\n\n}\n",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x95954c10ff5319ec1fdcc352d22e74066399a6f7",
    "source_code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface IPriceOracleGetter {\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Escrow is Ownable {\n    using Address for address payable;\n    using SafeERC20 for IERC20;\n\n    event BoughtOffline(address indexed recipient, uint256 indexed amount);\n    event ERC20Deposited(address indexed payee, address indexed token, uint256 indexed amount);\n    event ERC20Withdrawn(address indexed payee, address indexed token, uint256 indexed amount);\n    event Deposited(address indexed payee, uint256 indexed weiAmount);\n    event Withdrawn(address indexed payee, uint256 indexed weiAmount);\n    \n    mapping(address => bool) public whitelistedTokens;\n    mapping(address => uint256) public conversionRates;\n\n    address public offlineSpender;\n    uint256 public pricePerUnitInUSD;\n    uint256 public lastRecordedPrice;\n    uint256 public minimumTicket;\n    uint256 public constant ONE = 10**18;\n    bool public paused;\n    \n    IERC20 public wbkn;\n    IPriceOracleGetter public ethUSDCFeed;\n\n    modifier onlySpender {\n        require(msg.sender == offlineSpender, \"Caller is not spender\");\n        _;\n    }\n    \n    modifier whenNotPaused {\n        require(!paused, \"Functionality is paused\");\n        _;\n    }\n    \n    constructor(\n        address _wbkn,\n        address _offlineSpender,\n        uint256 _pricePerUnitInUsd,\n        uint256 _minimumTicket,\n        address _priceOracleGetter,\n        address[] memory _whitelistedTokens,\n        uint256[] memory _conversionRates\n    ) {\n        require(_whitelistedTokens.length == _conversionRates.length, \"Lengths mismatch\");\n        require(_wbkn != address(0), \"Invalid WBKN address\");\n\n        pricePerUnitInUSD = _pricePerUnitInUsd;        \n        wbkn = IERC20(_wbkn);\n        minimumTicket = _minimumTicket;\n        offlineSpender = _offlineSpender;\n        ethUSDCFeed = IPriceOracleGetter(_priceOracleGetter);\n        lastRecordedPrice = ethUSDCFeed.getAssetPrice(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n        \n        for(uint8 i = 0; i<_whitelistedTokens.length; i++) {\n            whitelistedTokens[_whitelistedTokens[i]] = true;\n            conversionRates[_whitelistedTokens[i]] =_conversionRates[i];\n        }\n    }\n    \n    function pause(bool _pause) public onlyOwner {\n        paused = _pause;\n    }\n    \n    function configERC20(address token, uint256 conversionRate) public onlyOwner {\n        if(conversionRate != 0) {\n            if(!whitelistedTokens[token]) whitelistedTokens[token] = true;\n        } else {\n            if(whitelistedTokens[token]) whitelistedTokens[token] = false;\n        }\n        \n        if(conversionRate != conversionRates[token]) conversionRates[token] = conversionRate;\n    }\n    \n    function configUSDPrice(uint256 newValue) public onlyOwner {\n        pricePerUnitInUSD = newValue;\n    }\n\n    function configMinimumTicket(uint256 newValue) public onlyOwner {\n        minimumTicket = newValue;\n    }\n    \n    function buyOffline(uint256 amountBought, address recipient) public onlySpender {\n        require(amountBought <= wbkn.balanceOf(address(this)), \"Amount exceeds contract's reserve\");\n        require(amountBought >= minimumTicket, \"Minimum ticket not satisfied\");\n\n        wbkn.safeTransfer(recipient, amountBought);\n        \n        emit BoughtOffline(recipient, amountBought);\n    }\n    \n    function buyWithERC20(address token, uint256 amount) public whenNotPaused {\n        require(whitelistedTokens[token], \"This address is not whitelisted\");\n        require(conversionRates[token] > 0, \"Invalid conversion rate\");\n        require(amount > 0, \"Zero amount not allowed\");\n        require(IERC20(token).allowance(msg.sender, address(this)) >= amount, \"Contract has not enough allowance\");\n        \n        uint256 amountBought = amount * conversionRates[token];\n        require(amountBought >= minimumTicket, \"Minimum ticket not satisfied\");\n        require(amountBought <= wbkn.balanceOf(address(this)), \"Amount exceeds contract's reserve\");\n        \n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        wbkn.safeTransfer(msg.sender, amountBought);\n\n        emit ERC20Deposited(msg.sender, token, amount);\n    }\n\n    function buyWithETH() public payable whenNotPaused {\n        uint256 amount = msg.value;\n        require(amount > 0, \"Zero amount not allowed\");\n\n        lastRecordedPrice = ethUSDCFeed.getAssetPrice(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n        \n        uint256 amountInUSD = amount*ONE / lastRecordedPrice;\n        uint256 amountBought = amountInUSD*ONE / pricePerUnitInUSD;\n\n        require(amountBought >= minimumTicket, \"Minimum ticket not satisfied\");\n        require(amountBought <= wbkn.balanceOf(address(this)), \"Amount exceeds contract's reserve\");\n        \n        wbkn.safeTransfer(msg.sender, amountBought);\n        \n        emit Deposited(msg.sender, amountInUSD);\n    }\n\n    function withdrawETH(address payable recipient) public onlyOwner {\n        emit Withdrawn(recipient, address(this).balance);\n        recipient.sendValue(address(this).balance);\n    }\n    \n    function withdrawERC20(address token, address recipient) public onlyOwner {\n\n        IERC20(token).safeTransfer(recipient, IERC20(token).balanceOf(address(this)));\n\n        emit ERC20Withdrawn(recipient, token, IERC20(token).balanceOf(address(this)));\n    }\n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x959C6189E6039606A79e209213f85f6e0A5Bb378",
    "source_code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport \"../interfaces/IOracle.sol\";\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\ncontract ShibUniV3ChainlinkOracle is IOracle {\n    using LowGasSafeMath for uint256; // Keep everything in uint256\n    IAggregator public constant ETH_USD = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    uint32 public constant period = 10 minutes;\n    address public constant pool = 0x5764a6F2212D502bC5970f9f129fFcd61e5D7563;\n    address public constant SHIB = 0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint128 private constant BASE_AMOUNT = 1e18;\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n\n        int24 timeWeightedTick = OracleLibrary.consult(pool, period);\n\n        uint256 priceETH = OracleLibrary.getQuoteAtTick(\n            timeWeightedTick,\n            BASE_AMOUNT,\n            SHIB,\n            WETH\n        );\n\n        return 1e44 / priceETH.mul(uint256(ETH_USD.latestAnswer()));\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink UNIV3 SHIB\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/UNIV3 SHIB\";\n    }\n}\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';\nimport '../libraries/PoolAddress.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Fetches time-weighted average tick using Uniswap V3 oracle\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @param period Number of seconds in the past to start calculating time-weighted average\n    /// @return timeWeightedAverageTick The time-weighted average tick from (block.timestamp - period) to block.timestamp\n    function consult(address pool, uint32 period) internal view returns (int24 timeWeightedAverageTick) {\n        require(period != 0, 'BP');\n\n        uint32[] memory secondAgos = new uint32[](2);\n        secondAgos[0] = period;\n        secondAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, ) = IUniswapV3Pool(pool).observe(secondAgos);\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n\n        timeWeightedAverageTick = int24(tickCumulativesDelta / period);\n\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % period != 0)) timeWeightedAverageTick--;\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @return The number of seconds ago of the oldest observation stored for the pool\n    function getOldestObservationSecondsAgo(address pool) internal view returns (uint32) {\n        (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n        require(observationCardinality > 0, 'NI');\n\n        (uint32 observationTimestamp, , , bool initialized) =\n            IUniswapV3Pool(pool).observations((observationIndex + 1) % observationCardinality);\n\n        // The next index might not be initialized if the cardinality is in the process of increasing\n        // In this case the oldest observation is always in index 0\n        if (!initialized) {\n            (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n        }\n\n        return uint32(block.timestamp) - observationTimestamp;\n    }\n}\n\n// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.12;\n\ninterface IOracle {\n    /// @notice Get the latest exchange rate.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n\n    /// @notice Check the last exchange rate without any state changes.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n\n    /// @notice Returns a human readable (short) name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable symbol name about this oracle.\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    /// @notice Returns a human readable name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable name about this oracle.\n    function name(bytes calldata data) external view returns (string memory);\n}\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = -denominator & denominator;\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(MAX_TICK), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                )\n            )\n        );\n    }\n}\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x95a08a245f5dC3Eb0aC2B5b6592CDb9810bD0961",
    "source_code": "// File: contracts/BondToken_and_GDOTC/bondPricer/Enums.sol\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.1;\n\n/**\n    Pure SBT:\n        ___________\n       /\n      /\n     /\n    /\n\n    LBT Shape:\n              /\n             /\n            /\n           /\n    ______/\n\n    SBT Shape:\n              ______\n             /\n            /\n    _______/\n\n    Triangle:\n              /\\\n             /  \\\n            /    \\\n    _______/      \\________\n */\nenum BondType {NONE, PURE_SBT, SBT_SHAPE, LBT_SHAPE, TRIANGLE}\n\n// File: contracts/BondToken_and_GDOTC/bondPricer/BondPricerInterface.sol\n\n\n\n\n\ninterface BondPricerInterface {\n    /**\n     * @notice Calculate bond price and leverage by black-scholes formula.\n     * @param bondType type of target bond.\n     * @param points coodinates of polyline which is needed for price calculation\n     * @param spotPrice is a oracle price.\n     * @param volatilityE8 is a oracle volatility.\n     * @param untilMaturity Remaining period of target bond in second\n     **/\n    function calcPriceAndLeverage(\n        BondType bondType,\n        uint256[] calldata points,\n        int256 spotPrice,\n        int256 volatilityE8,\n        int256 untilMaturity\n    ) external view returns (uint256 price, uint256 leverageE8);\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\n\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @openzeppelin/contracts/math/SignedSafeMath.sol\n\n\n\n\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/SafeCast.sol\n\n\n\n\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\n// File: contracts/BondToken_and_GDOTC/math/UseSafeMath.sol\n\n\n\n\n\n\n\n/**\n * @notice ((a - 1) / b) + 1 = (a + b -1) / b\n * for example a.add(10**18 -1).div(10**18) = a.sub(1).div(10**18) + 1\n */\n\nlibrary SafeMathDivRoundUp {\n    using SafeMath for uint256;\n\n    function divRoundUp(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        require(b > 0, errorMessage);\n        return ((a - 1) / b) + 1;\n    }\n\n    function divRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return divRoundUp(a, b, \"SafeMathDivRoundUp: modulo by zero\");\n    }\n}\n\n/**\n * @title UseSafeMath\n * @dev One can use SafeMath for not only uint256 but also uin64 or uint16,\n * and also can use SafeCast for uint256.\n * For example:\n *   uint64 a = 1;\n *   uint64 b = 2;\n *   a = a.add(b).toUint64() // `a` become 3 as uint64\n * In addition, one can use SignedSafeMath and SafeCast.toUint256(int256) for int256.\n * In the case of the operation to the uint64 value, one needs to cast the value into int256 in\n * advance to use `sub` as SignedSafeMath.sub not SafeMath.sub.\n * For example:\n *   int256 a = 1;\n *   uint64 b = 2;\n *   int256 c = 3;\n *   a = a.add(int256(b).sub(c)); // `a` becomes 0 as int256\n *   b = a.toUint256().toUint64(); // `b` becomes 0 as uint64\n */\nabstract contract UseSafeMath {\n    using SafeMath for uint256;\n    using SafeMathDivRoundUp for uint256;\n    using SafeMath for uint64;\n    using SafeMathDivRoundUp for uint64;\n    using SafeMath for uint16;\n    using SignedSafeMath for int256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n}\n\n// File: contracts/BondToken_and_GDOTC/math/AdvancedMath.sol\n\n\n\n\nabstract contract AdvancedMath {\n    /**\n     * @dev sqrt(2*PI) * 10^8\n     */\n    int256 internal constant SQRT_2PI_E8 = 250662827;\n    int256 internal constant PI_E8 = 314159265;\n    int256 internal constant E_E8 = 271828182;\n    int256 internal constant INV_E_E8 = 36787944; // 1/e\n    int256 internal constant LOG2_E8 = 30102999;\n    int256 internal constant LOG3_E8 = 47712125;\n\n    int256 internal constant p = 23164190;\n    int256 internal constant b1 = 31938153;\n    int256 internal constant b2 = -35656378;\n    int256 internal constant b3 = 178147793;\n    int256 internal constant b4 = -182125597;\n    int256 internal constant b5 = 133027442;\n\n    /**\n     * @dev Calcurate an approximate value of the square root of x by Babylonian method.\n     */\n    function _sqrt(int256 x) internal pure returns (int256 y) {\n        require(x >= 0, \"cannot calculate the square root of a negative number\");\n        int256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    /**\n     * @dev Returns log(x) for any positive x.\n     */\n    function _logTaylor(int256 inputE4) internal pure returns (int256 outputE4) {\n        require(inputE4 > 1, \"input should be positive number\");\n        int256 inputE8 = inputE4 * 10**4;\n        // input x for _logTayler1 is adjusted to 1/e < x < 1.\n        while (inputE8 < INV_E_E8) {\n            inputE8 = (inputE8 * E_E8) / 10**8;\n            outputE4 -= 10**4;\n        }\n        while (inputE8 > 10**8) {\n            inputE8 = (inputE8 * INV_E_E8) / 10**8;\n            outputE4 += 10**4;\n        }\n        outputE4 += _logTaylor1(inputE8 / 10**4 - 10**4);\n    }\n\n    /**\n     * @notice Calculate an approximate value of the logarithm of input value by\n     * Taylor expansion around 1.\n     * @dev log(x + 1) = x - 1/2 x^2 + 1/3 x^3 - 1/4 x^4 + 1/5 x^5\n     *                     - 1/6 x^6 + 1/7 x^7 - 1/8 x^8 + ...\n     */\n    function _logTaylor1(int256 inputE4) internal pure returns (int256 outputE4) {\n        outputE4 =\n            inputE4 -\n            inputE4**2 /\n            (2 * 10**4) +\n            inputE4**3 /\n            (3 * 10**8) -\n            inputE4**4 /\n            (4 * 10**12) +\n            inputE4**5 /\n            (5 * 10**16) -\n            inputE4**6 /\n            (6 * 10**20) +\n            inputE4**7 /\n            (7 * 10**24) -\n            inputE4**8 /\n            (8 * 10**28);\n    }\n\n    /**\n     * @notice Calculate the cumulative distribution function of standard normal\n     * distribution.\n     * @dev Abramowitz and Stegun, Handbook of Mathematical Functions (1964)\n     * http://people.math.sfu.ca/~cbm/aands/\n     */\n    function _calcPnorm(int256 inputE4) internal pure returns (int256 outputE8) {\n        require(inputE4 < 440 * 10**4 && inputE4 > -440 * 10**4, \"input is too large\");\n        int256 _inputE4 = inputE4 > 0 ? inputE4 : inputE4 * (-1);\n        int256 t = 10**16 / (10**8 + (p * _inputE4) / 10**4);\n        int256 X2 = (inputE4 * inputE4) / 2;\n        int256 exp2X2 = 10**8 +\n            X2 +\n            (X2**2 / (2 * 10**8)) +\n            (X2**3 / (6 * 10**16)) +\n            (X2**4 / (24 * 10**24)) +\n            (X2**5 / (120 * 10**32)) +\n            (X2**6 / (720 * 10**40));\n        int256 Z = (10**24 / exp2X2) / SQRT_2PI_E8;\n        int256 y = (b5 * t) / 10**8;\n        y = ((y + b4) * t) / 10**8;\n        y = ((y + b3) * t) / 10**8;\n        y = ((y + b2) * t) / 10**8;\n        y = 10**8 - (Z * ((y + b1) * t)) / 10**16;\n        return inputE4 > 0 ? y : 10**8 - y;\n    }\n}\n\n// File: contracts/BondToken_and_GDOTC/bondPricer/GeneralizedPricing.sol\n\n\n\n\n\n\n\n/**\n * @dev The decimals of price, point, spotPrice and strikePrice are all the same.\n */\ncontract GeneralizedPricing is AdvancedMath {\n    using SafeMath for uint256;\n\n    /**\n     * @dev sqrt(365*86400) * 10^8\n     */\n    int256 internal constant SQRT_YEAR_E8 = 5615.69229926 * 10**8;\n\n    int256 internal constant MIN_ND1_E8 = 0.0001 * 10**8;\n    int256 internal constant MAX_ND1_E8 = 0.9999 * 10**8;\n    uint256 internal constant MAX_LEVERAGE_E8 = 1000 * 10**8;\n\n    /**\n     * @notice Calculate bond price and leverage by black-scholes formula.\n     * @param bondType type of target bond.\n     * @param points coodinates of polyline which is needed for price calculation\n     * @param untilMaturity Remaining period of target bond in second\n     **/\n    function calcPriceAndLeverage(\n        BondType bondType,\n        uint256[] memory points,\n        int256 spotPrice,\n        int256 volatilityE8,\n        int256 untilMaturity\n    ) public pure returns (uint256 price, uint256 leverageE8) {\n        if (bondType == BondType.LBT_SHAPE) {\n            (price, leverageE8) = _calcLbtShapePriceAndLeverage(\n                points,\n                spotPrice,\n                volatilityE8,\n                untilMaturity\n            );\n        } else if (bondType == BondType.SBT_SHAPE) {\n            (price, leverageE8) = _calcSbtShapePrice(\n                points,\n                spotPrice,\n                volatilityE8,\n                untilMaturity\n            );\n        } else if (bondType == BondType.TRIANGLE) {\n            (price, leverageE8) = _calcTrianglePrice(\n                points,\n                spotPrice,\n                volatilityE8,\n                untilMaturity\n            );\n        } else if (bondType == BondType.PURE_SBT) {\n            (price, leverageE8) = _calcPureSBTPrice(points, spotPrice, volatilityE8, untilMaturity);\n        }\n    }\n\n    /**\n     * @notice Calculate pure call option price and multiply incline of LBT.\n     **/\n\n    function _calcLbtShapePriceAndLeverage(\n        uint256[] memory points,\n        int256 spotPrice,\n        int256 volatilityE8,\n        int256 untilMaturity\n    ) internal pure returns (uint256 price, uint256 leverageE8) {\n        require(points.length == 3, \"3 coordinates is needed for LBT price calculation\");\n        uint256 inclineE8 = (points[2].mul(10**8)).div(points[1].sub(points[0]));\n        (uint256 callOptionPriceE8, int256 nd1E8) = calcCallOptionPrice(\n            spotPrice,\n            int256(points[0]),\n            volatilityE8,\n            untilMaturity\n        );\n        price = (callOptionPriceE8 * inclineE8) / 10**8;\n        leverageE8 = _calcLbtLeverage(\n            uint256(spotPrice),\n            price,\n            (nd1E8 * int256(inclineE8)) / 10**8\n        );\n    }\n\n    /**\n     * @notice Calculate (etherPrice - call option price at strike price of SBT).\n     **/\n    function _calcPureSBTPrice(\n        uint256[] memory points,\n        int256 spotPrice,\n        int256 volatilityE8,\n        int256 untilMaturity\n    ) internal pure returns (uint256 price, uint256 leverageE8) {\n        require(points.length == 1, \"1 coordinate is needed for pure SBT price calculation\");\n        (uint256 callOptionPrice1, int256 nd1E8) = calcCallOptionPrice(\n            spotPrice,\n            int256(points[0]),\n            volatilityE8,\n            untilMaturity\n        );\n        price = uint256(spotPrice) > callOptionPrice1 ? (uint256(spotPrice) - callOptionPrice1) : 0;\n        leverageE8 = _calcLbtLeverage(uint256(spotPrice), price, 10**8 - nd1E8);\n    }\n\n    /**\n     * @notice Calculate (call option1  - call option2) * incline of SBT.\n\n              ______                 /\n             /                      /\n            /          =           /        -                   /\n    _______/               _______/                 ___________/\n    SBT SHAPE BOND         CALL OPTION 1            CALL OPTION 2\n     **/\n    function _calcSbtShapePrice(\n        uint256[] memory points,\n        int256 spotPrice,\n        int256 volatilityE8,\n        int256 untilMaturity\n    ) internal pure returns (uint256 price, uint256 leverageE8) {\n        require(points.length == 3, \"3 coordinates is needed for SBT price calculation\");\n        uint256 inclineE8 = (points[2].mul(10**8)).div(points[1].sub(points[0]));\n        (uint256 callOptionPrice1, int256 nd11E8) = calcCallOptionPrice(\n            spotPrice,\n            int256(points[0]),\n            volatilityE8,\n            untilMaturity\n        );\n        (uint256 callOptionPrice2, int256 nd12E8) = calcCallOptionPrice(\n            spotPrice,\n            int256(points[1]),\n            volatilityE8,\n            untilMaturity\n        );\n        price = callOptionPrice1 > callOptionPrice2\n            ? (inclineE8 * (callOptionPrice1 - callOptionPrice2)) / 10**8\n            : 0;\n        leverageE8 = _calcLbtLeverage(\n            uint256(spotPrice),\n            price,\n            (int256(inclineE8) * (nd11E8 - nd12E8)) / 10**8\n        );\n    }\n\n    /**\n      * @notice Calculate (call option1 * left incline) - (call option2 * (left incline + right incline)) + (call option3 * right incline).\n\n                                                                   /\n                                                                  /\n                                                                 /\n              /\\                            /                    \\\n             /  \\                          /                      \\\n            /    \\            =           /     -                  \\          +\n    _______/      \\________       _______/               _______    \\             __________________\n                                                                     \\                          \\\n                                                                      \\                          \\\n\n    **/\n    function _calcTrianglePrice(\n        uint256[] memory points,\n        int256 spotPrice,\n        int256 volatilityE8,\n        int256 untilMaturity\n    ) internal pure returns (uint256 price, uint256 leverageE8) {\n        require(\n            points.length == 4,\n            \"4 coordinates is needed for triangle option price calculation\"\n        );\n        uint256 incline1E8 = (points[2].mul(10**8)).div(points[1].sub(points[0]));\n        uint256 incline2E8 = (points[2].mul(10**8)).div(points[3].sub(points[1]));\n        (uint256 callOptionPrice1, int256 nd11E8) = calcCallOptionPrice(\n            spotPrice,\n            int256(points[0]),\n            volatilityE8,\n            untilMaturity\n        );\n        (uint256 callOptionPrice2, int256 nd12E8) = calcCallOptionPrice(\n            spotPrice,\n            int256(points[1]),\n            volatilityE8,\n            untilMaturity\n        );\n        (uint256 callOptionPrice3, int256 nd13E8) = calcCallOptionPrice(\n            spotPrice,\n            int256(points[3]),\n            volatilityE8,\n            untilMaturity\n        );\n        int256 nd1E8 = ((nd11E8 * int256(incline1E8)) +\n            (nd13E8 * int256(incline2E8)) -\n            (int256(incline1E8 + incline2E8) * nd12E8)) / 10**8;\n\n        uint256 price12 = (callOptionPrice1 * incline1E8) + (callOptionPrice3 * incline2E8);\n        price = price12 > (incline1E8 + incline2E8) * callOptionPrice2\n            ? (price12 - ((incline1E8 + incline2E8) * callOptionPrice2)) / 10**8\n            : 0;\n        leverageE8 = _calcLbtLeverage(uint256(spotPrice), price, nd1E8);\n    }\n\n    /**\n     * @dev calcCallOptionPrice() imposes the restrictions of strikePrice, spotPrice, nd1E8 and nd2E8.\n     */\n    function _calcLbtPrice(\n        int256 spotPrice,\n        int256 strikePrice,\n        int256 nd1E8,\n        int256 nd2E8\n    ) internal pure returns (int256 lbtPrice) {\n        int256 lowestPrice = (spotPrice > strikePrice) ? spotPrice - strikePrice : 0;\n        lbtPrice = (spotPrice * nd1E8 - strikePrice * nd2E8) / 10**8;\n        if (lbtPrice < lowestPrice) {\n            lbtPrice = lowestPrice;\n        }\n    }\n\n    /**\n     * @dev calcCallOptionPrice() imposes the restrictions of spotPrice, lbtPrice and nd1E8.\n     */\n    function _calcLbtLeverage(\n        uint256 spotPrice,\n        uint256 lbtPrice,\n        int256 nd1E8\n    ) internal pure returns (uint256 lbtLeverageE8) {\n        int256 modifiedNd1E8 = nd1E8 < MIN_ND1_E8 ? MIN_ND1_E8 : nd1E8 > MAX_ND1_E8\n            ? MAX_ND1_E8\n            : nd1E8;\n        return lbtPrice != 0 ? (uint256(modifiedNd1E8) * spotPrice) / lbtPrice : MAX_LEVERAGE_E8;\n    }\n\n    /**\n     * @notice Calculate pure call option price and N(d1) by black-scholes formula.\n     * @param spotPrice is a oracle price.\n     * @param strikePrice Strike price of call option\n     * @param volatilityE8 is a oracle volatility.\n     * @param untilMaturity Remaining period of target bond in second\n     **/\n    function calcCallOptionPrice(\n        int256 spotPrice,\n        int256 strikePrice,\n        int256 volatilityE8,\n        int256 untilMaturity\n    ) public pure returns (uint256 price, int256 nd1E8) {\n        require(spotPrice > 0 && spotPrice < 10**13, \"oracle price should be between 0 and 10^13\");\n        require(\n            volatilityE8 > 0 && volatilityE8 < 10 * 10**8,\n            \"oracle volatility should be between 0% and 1000%\"\n        );\n        require(\n            untilMaturity > 0 && untilMaturity < 31536000,\n            \"the bond should not have expired and less than 1 year\"\n        );\n        require(\n            strikePrice > 0 && strikePrice < 10**13,\n            \"strike price should be between 0 and 10^13\"\n        );\n\n        int256 spotPerStrikeE4 = (spotPrice * 10**4) / strikePrice;\n        int256 sigE8 = (volatilityE8 * (_sqrt(untilMaturity)) * (10**8)) / SQRT_YEAR_E8;\n\n        int256 logSigE4 = _logTaylor(spotPerStrikeE4);\n        int256 d1E4 = ((logSigE4 * 10**8) / sigE8) + (sigE8 / (2 * 10**4));\n        nd1E8 = _calcPnorm(d1E4);\n\n        int256 d2E4 = d1E4 - (sigE8 / 10**4);\n        int256 nd2E8 = _calcPnorm(d2E4);\n        price = uint256(_calcLbtPrice(spotPrice, strikePrice, nd1E8, nd2E8));\n    }\n}\n\n// File: contracts/BondToken_and_GDOTC/bondPricer/CustomGeneralizedPricing.sol\n\n\n\n\n\n\nabstract contract CustomGeneralizedPricing is BondPricerInterface {\n    using SafeMath for uint256;\n\n    GeneralizedPricing internal immutable _originalBondPricerAddress;\n\n    constructor(address originalBondPricerAddress) {\n        _originalBondPricerAddress = GeneralizedPricing(originalBondPricerAddress);\n    }\n\n    function calcPriceAndLeverage(\n        BondType bondType,\n        uint256[] calldata points,\n        int256 spotPrice,\n        int256 volatilityE8,\n        int256 untilMaturity\n    ) external view override returns (uint256 price, uint256 leverageE8) {\n        (price, leverageE8) = _originalBondPricerAddress.calcPriceAndLeverage(\n            bondType,\n            points,\n            spotPrice,\n            volatilityE8,\n            untilMaturity\n        );\n        if (bondType == BondType.LBT_SHAPE) {\n            require(\n                _isAcceptableLbt(points, spotPrice, volatilityE8, untilMaturity, price, leverageE8),\n                \"the liquid bond is not acceptable\"\n            );\n        } else if (bondType == BondType.SBT_SHAPE) {\n            require(\n                _isAcceptableSbt(points, spotPrice, volatilityE8, untilMaturity, price, leverageE8),\n                \"the solid bond is not acceptable\"\n            );\n        } else if (bondType == BondType.TRIANGLE) {\n            require(\n                _isAcceptableTriangleBond(\n                    points,\n                    spotPrice,\n                    volatilityE8,\n                    untilMaturity,\n                    price,\n                    leverageE8\n                ),\n                \"the triangle bond is not acceptable\"\n            );\n        } else if (bondType == BondType.PURE_SBT) {\n            require(\n                _isAcceptablePureSbt(\n                    points,\n                    spotPrice,\n                    volatilityE8,\n                    untilMaturity,\n                    price,\n                    leverageE8\n                ),\n                \"the pure solid bond is not acceptable\"\n            );\n        } else {\n            require(\n                _isAcceptableOtherBond(\n                    points,\n                    spotPrice,\n                    volatilityE8,\n                    untilMaturity,\n                    price,\n                    leverageE8\n                ),\n                \"the bond is not acceptable\"\n            );\n        }\n    }\n\n    function originalBondPricer() external view returns (address originalBondPricerAddress) {\n        originalBondPricerAddress = address(_originalBondPricerAddress);\n    }\n\n    function _isAcceptableLbt(\n        uint256[] memory points,\n        int256 spotPrice,\n        int256 volatilityE8,\n        int256 untilMaturity,\n        uint256 bondPrice,\n        uint256 bondLeverageE8\n    ) internal view virtual returns (bool);\n\n    function _isAcceptableSbt(\n        uint256[] memory points,\n        int256 spotPrice,\n        int256 volatilityE8,\n        int256 untilMaturity,\n        uint256 bondPrice,\n        uint256 bondLeverageE8\n    ) internal view virtual returns (bool);\n\n    function _isAcceptableTriangleBond(\n        uint256[] memory points,\n        int256 spotPrice,\n        int256 volatilityE8,\n        int256 untilMaturity,\n        uint256 bondPrice,\n        uint256 bondLeverageE8\n    ) internal view virtual returns (bool);\n\n    function _isAcceptablePureSbt(\n        uint256[] memory points,\n        int256 spotPrice,\n        int256 volatilityE8,\n        int256 untilMaturity,\n        uint256 bondPrice,\n        uint256 bondLeverageE8\n    ) internal view virtual returns (bool);\n\n    function _isAcceptableOtherBond(\n        uint256[] memory points,\n        int256 spotPrice,\n        int256 volatilityE8,\n        int256 untilMaturity,\n        uint256 bondPrice,\n        uint256 bondLeverageE8\n    ) internal view virtual returns (bool);\n}\n\n// File: @openzeppelin/contracts/GSN/Context.sol\n\n\n\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\n\n\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/BondToken_and_GDOTC/util/Time.sol\n\n\n\n\nabstract contract Time {\n    function _getBlockTimestampSec() internal view returns (uint256 unixtimesec) {\n        unixtimesec = block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n}\n\n// File: contracts/contracts/SimpleAggregator/BondPricerWithAcceptableMaturity.sol\n\n\n\n\n\n\n\n\ncontract BondPricerWithAcceptableMaturity is CustomGeneralizedPricing, Ownable, Time {\n    using SafeMath for uint256;\n\n    uint256 internal _acceptableMaturity;\n\n    event LogUpdateAcceptableMaturity(uint256 acceptableMaturity);\n\n    constructor(address originalBondPricerAddress)\n        CustomGeneralizedPricing(originalBondPricerAddress)\n    {\n        _updateAcceptableMaturity(0);\n    }\n\n    function updateAcceptableMaturity(uint256 acceptableMaturity) external onlyOwner {\n        _updateAcceptableMaturity(acceptableMaturity);\n    }\n\n    function getAcceptableMaturity() external view returns (uint256 acceptableMaturity) {\n        acceptableMaturity = _acceptableMaturity;\n    }\n\n    function _updateAcceptableMaturity(uint256 acceptableMaturity) internal {\n        _acceptableMaturity = acceptableMaturity;\n        emit LogUpdateAcceptableMaturity(acceptableMaturity);\n    }\n\n    function _isAcceptableLbt(\n        uint256[] memory,\n        int256 etherPriceE8,\n        int256 ethVolatilityE8,\n        int256 untilMaturity,\n        uint256,\n        uint256\n    ) internal view override returns (bool) {\n        _isAcceptable(etherPriceE8, ethVolatilityE8, untilMaturity);\n        return true;\n    }\n\n    function _isAcceptableSbt(\n        uint256[] memory,\n        int256 etherPriceE8,\n        int256 ethVolatilityE8,\n        int256 untilMaturity,\n        uint256,\n        uint256\n    ) internal view override returns (bool) {\n        _isAcceptable(etherPriceE8, ethVolatilityE8, untilMaturity);\n        return true;\n    }\n\n    function _isAcceptableTriangleBond(\n        uint256[] memory,\n        int256 etherPriceE8,\n        int256 ethVolatilityE8,\n        int256 untilMaturity,\n        uint256,\n        uint256\n    ) internal view override returns (bool) {\n        _isAcceptable(etherPriceE8, ethVolatilityE8, untilMaturity);\n        return true;\n    }\n\n    function _isAcceptablePureSbt(\n        uint256[] memory,\n        int256 etherPriceE8,\n        int256 ethVolatilityE8,\n        int256 untilMaturity,\n        uint256,\n        uint256\n    ) internal view override returns (bool) {\n        _isAcceptable(etherPriceE8, ethVolatilityE8, untilMaturity);\n        return true;\n    }\n\n    function _isAcceptableOtherBond(\n        uint256[] memory,\n        int256,\n        int256,\n        int256,\n        uint256,\n        uint256\n    ) internal pure override returns (bool) {\n        revert(\"the bond is not pure SBT type\");\n    }\n\n    /**\n     * @notice Add this function to CustomGeneralizedPricing\n     * When user sells bond which expired or whose maturity is after the aggregator's maturity, revert the transaction\n     */\n    function _isAcceptable(\n        int256 etherPriceE8,\n        int256 ethVolatilityE8,\n        int256 untilMaturity\n    ) internal view {\n        require(\n            etherPriceE8 > 0 && etherPriceE8 < 100000 * 10**8,\n            \"ETH price should be between $0 and $100000\"\n        );\n        require(\n            ethVolatilityE8 > 0 && ethVolatilityE8 < 10 * 10**8,\n            \"ETH volatility should be between 0% and 1000%\"\n        );\n        require(untilMaturity >= 0, \"the bond has been expired\");\n        require(untilMaturity <= 12 weeks, \"the bond maturity must be less than 12 weeks\");\n        require(\n            _getBlockTimestampSec().add(uint256(untilMaturity)) <= _acceptableMaturity,\n            \"the bond maturity must not exceed the current maturity of aggregator\"\n        );\n    }\n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x95c2128ee4eadb92cce3d59b485262729584d807",
    "source_code": "pragma solidity ^0.6.12;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract FlokiFi is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 1000000000000000 * 10**18;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tBurnTotal;\n\n    string private _name = 'Floki Finance';\n    string private _symbol = 'FLFI';\n    uint8 private _decimals = 18;\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalBurn() public view returns (uint256) {\n        return _tBurnTotal;\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tBurnTotal = _tBurnTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already included\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferStandard(sender, recipient, amount);\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee,uint256 tBurnValue,uint256 tTax,uint256 tLiquidity) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee, tBurnValue,tTax,tLiquidity);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee,uint256 tBurnValue,uint256 tTax,uint256 tLiquidity) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee, tBurnValue,tTax,tLiquidity);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee,uint256 tBurnValue,uint256 tTax,uint256 tLiquidity) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n       _reflectFee(rFee, tFee, tBurnValue,tTax,tLiquidity);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee,uint256 tBurnValue,uint256 tTax,uint256 tLiquidity) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee, tBurnValue,tTax,tLiquidity);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee, uint256 tBurnValue,uint256 tTax,uint256 tLiquidity) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tBurnTotal = _tBurnTotal.add(tFee).add(tBurnValue).add(tTax).add(tLiquidity);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256,uint256,uint256,uint256) {\n        uint256[12] memory _localVal;\n        (_localVal[0]/**tTransferAmount*/, _localVal[1]  /**tFee*/, _localVal[2] /**tBurnValue*/,_localVal[8]/*tTAx*/,_localVal[10]/**tLiquidity*/) = _getTValues(tAmount);\n        _localVal[3] /**currentRate*/ =  _getRate();\n        ( _localVal[4] /**rAmount*/,  _localVal[5] /**rTransferAmount*/, _localVal[6] /**rFee*/, _localVal[7] /**rBurnValue*/,_localVal[9]/*rTax*/,_localVal[11]/**rLiquidity*/) = _getRValues(tAmount, _localVal[1], _localVal[3], _localVal[2],_localVal[8],_localVal[10]);\n        return (_localVal[4], _localVal[5], _localVal[6], _localVal[0], _localVal[1], _localVal[2],_localVal[8],_localVal[10]);\n    }\n    \n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256, uint256,uint256,uint256) {\n        uint256[5] memory _localVal;\n        \n        _localVal[0]/**supply*/ = tAmount.div(100).mul(0);\n        _localVal[1]/**tBurnValue*/ = tAmount.div(100).mul(0);\n        _localVal[2]/**tholder*/ = tAmount.div(100).mul(1 );\n        _localVal[3]/**tLiquidity*/ = tAmount.div(100).mul(15);\n        _localVal[4]/**tTransferAmount*/ = tAmount.sub(_localVal[2]).sub(_localVal[1]).sub(_localVal[0]).sub(_localVal[3]);\n        return (_localVal[4], _localVal[2], _localVal[1],_localVal[0], _localVal[3]);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate, uint256 tBurnValue,uint256 tTax,uint tLiquidity) private pure returns (uint256, uint256, uint256,uint256,uint256,uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rBurnValue = tBurnValue.mul(currentRate);\n        uint256 rLiqidity = tLiquidity.mul(currentRate);\n        uint256 rTax = tTax.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rBurnValue).sub(rTax).sub(rLiqidity);\n        return (rAmount, rTransferAmount, rFee, rBurnValue,rTax,rLiqidity);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x96393568d2f1e159a509b56b6ef1b13eda926c6f",
    "source_code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nabstract contract RunnerTokenInterface is ERC20, Ownable {\n    /// @notice Total number of tokens\n    uint256 public maxSupply = 1_000_000_000e18; // 1 Billion RUN\n\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (RUNNER).\n    function mint(address _to, uint256 _amount) public onlyOwner {\n        require(\n            (totalSupply() + _amount) <= maxSupply,\n            \"RUN::mint: cannot exceed max supply\"\n        );\n        _mint(_to, _amount);\n        _moveDelegates(address(0), _delegates[_to], _amount);\n    }\n\n  \n    mapping(address => address) internal _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\n            \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n        );\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegator The address to get delegatee for\n     */\n    function delegates(address delegator) external view returns (address) {\n        return _delegates[delegator];\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(\n            signatory != address(0),\n            \"RUN::delegateBySig: invalid signature\"\n        );\n        require(\n            nonce == nonces[signatory]++,\n            \"RUN::delegateBySig: invalid nonce\"\n        );\n        require(block.timestamp <= expiry, \"RUN::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint256) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return\n            nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(\n            blockNumber < block.number,\n            \"RUN::getPriorVotes: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying RUN (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint256 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0\n                    ? checkpoints[srcRep][srcRepNum - 1].votes\n                    : 0;\n                uint256 srcRepNew = srcRepOld - amount;\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0\n                    ? checkpoints[dstRep][dstRepNum - 1].votes\n                    : 0;\n                uint256 dstRepNew = dstRepOld + amount;\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(\n            block.number,\n            \"RUN::_writeCheckpoint: block number exceeds 32 bits\"\n        );\n\n        if (\n            nCheckpoints > 0 &&\n            checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n        ) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(\n                blockNumber,\n                newVotes\n            );\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint32)\n    {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n\ncontract RUNNERToken is RunnerTokenInterface {\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x96e61422b6a9ba0e068b6c5add4ffabc6a4aae27",
    "source_code": "/**\n *Submitted for verification at FtmScan.com on 2021-07-19\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface ibToken {\n    function mint(uint) external returns (uint);\n    function redeemUnderlying(uint) external returns (uint);\n    function exchangeRateStored() external view returns (uint);\n    function balanceOf(address) external view returns (uint);\n}\n\ncontract FixedEUR {\n    string public constant name = \"Iron Bank EUR\";\n    string public constant symbol = \"ibEUR\";\n    uint8 public constant decimals = 18;\n    \n    ibToken public immutable ib;\n    address public gov;\n    address public nextgov;\n    uint public commitgov;\n    uint public constant delay = 1 days;\n    \n    uint public liquidity;\n    \n    constructor(ibToken _ib) {\n        ib = _ib;\n        gov = msg.sender;\n    }\n    \n    modifier g() {\n        require(msg.sender == gov);\n        _;\n    }\n    \n    function setGov(address _gov) external g {\n        nextgov = _gov;\n        commitgov = block.timestamp + delay;\n    }\n    \n    function acceptGov() external {\n        require(msg.sender == nextgov && commitgov < block.timestamp);\n        gov = nextgov;\n    }\n    \n    function balanceIB() public view returns (uint) {\n        return ib.balanceOf(address(this));\n    }\n    \n    function balanceUnderlying() public view returns (uint) {\n        uint256 _b = balanceIB();\n        if (_b > 0) {\n            return _b * ib.exchangeRateStored() / 1e18;\n        }\n        return 0;\n    }\n    \n    function _redeem(uint amount) internal {\n        require(ib.redeemUnderlying(amount) == 0, \"ib: withdraw failed\");\n    }\n    \n    function profit() external {\n        uint _profit = balanceUnderlying() - liquidity;\n        _redeem(_profit);\n        _transferTokens(address(this), gov, _profit);\n    }\n    \n    function withdraw(uint amount) external g {\n        liquidity -= amount;\n        _redeem(amount);\n        _burn(amount);\n    }\n    \n    function deposit() external {\n        uint _amount = balances[address(this)];\n        allowances[address(this)][address(ib)] = _amount;\n        liquidity += _amount;\n        require(ib.mint(_amount) == 0, \"ib: supply failed\");\n    }\n    \n    /// @notice Total number of tokens in circulation\n    uint public totalSupply = 0;\n    \n    mapping(address => mapping (address => uint)) internal allowances;\n    mapping(address => uint) internal balances;\n    \n    event Transfer(address indexed from, address indexed to, uint amount);\n    event Approval(address indexed owner, address indexed spender, uint amount);\n    \n    function mint(uint amount) external g {\n        // mint the amount\n        totalSupply += amount;\n        // transfer the amount to the recipient\n        balances[address(this)] += amount;\n        emit Transfer(address(0), address(this), amount);\n    }\n    \n    function burn(uint amount) external g {\n        _burn(amount);\n    }\n    \n    function _burn(uint amount) internal {\n        // burn the amount\n        totalSupply -= amount;\n        // transfer the amount from the recipient\n        balances[address(this)] -= amount;\n        emit Transfer(address(this), address(0), amount);\n    }\n    \n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    function transfer(address dst, uint amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint amount) external returns (bool) {\n        address spender = msg.sender;\n        uint spenderAllowance = allowances[src][spender];\n\n        if (spender != src && spenderAllowance != type(uint).max) {\n            uint newAllowance = spenderAllowance - amount;\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    function _transferTokens(address src, address dst, uint amount) internal {\n        balances[src] -= amount;\n        balances[dst] += amount;\n        \n        emit Transfer(src, dst, amount);\n    }\n}",
    "vulnerability_type": "arithmetic"
  },
  {
    "address": "0x97438b2a8D5cea628B8F616CA2E4E895defAcF32",
    "source_code": "/*\n// ONE ID 10\n\n// Hello \n// I am Onene One  IDID 10,\n// Global One ID AutoPool Smart contract.\n// Earn more than 300000 ETH with just 2 ETH.\n// This is a tool to generate passive income.\n// ADVANTAGES OF THIS SMART CONTRACT\n\n// Only allow registration if 1 Referral ID is 1.\n// Can not stop, exist forever.\n// Simple registration and upgrade. No login or password required.\n// Auto-overflow.\n// Repeat high income to level 10.\n// Every member is happy.\n// Simple and manipulative interface on Etherscan.\n// Open source, authenticated on Etherscan.\n// High income. invite people online & offline.\n// Market development by international leaders.\n// And more, ...\n\n// My URL : https://Oneid10github.io\n// Telegram Channel: https://t.me/ONE_ID_10\n// Private Telegram Group: https://t.me/joinchat/DQWsThP_PYUT9rL4HywAhg\n// Hashtag: #Oneid10\n*/\npragma solidity 0.5.11 - 0.6.4;\n\ncontract OneID10 {\n     address public ownerWallet;\n      uint public currUserID = 0;\n      uint public pool1currUserID = 0;\n      uint public pool2currUserID = 0;\n      uint public pool3currUserID = 0;\n      uint public pool4currUserID = 0;\n      uint public pool5currUserID = 0;\n      uint public pool6currUserID = 0;\n      uint public pool7currUserID = 0;\n      uint public pool8currUserID = 0;\n      uint public pool9currUserID = 0;\n      uint public pool10currUserID = 0;\n      \n        uint public pool1activeUserID = 0;\n      uint public pool2activeUserID = 0;\n      uint public pool3activeUserID = 0;\n      uint public pool4activeUserID = 0;\n      uint public pool5activeUserID = 0;\n      uint public pool6activeUserID = 0;\n      uint public pool7activeUserID = 0;\n      uint public pool8activeUserID = 0;\n      uint public pool9activeUserID = 0;\n      uint public pool10activeUserID = 0;\n      \n      \n      uint public unlimited_level_price=0;\n     \n      struct UserStruct {\n        bool isExist;\n        uint id;\n        uint referrerID;\n       uint referredUsers;\n        mapping(uint => uint) levelExpired;\n    }\n    \n     struct PoolUserStruct {\n        bool isExist;\n        uint id;\n       uint payment_received; \n    }\n    \n    mapping (address => UserStruct) public users;\n     mapping (uint => address) public userList;\n     \n     mapping (address => PoolUserStruct) public pool1users;\n     mapping (uint => address) public pool1userList;\n     \n     mapping (address => PoolUserStruct) public pool2users;\n     mapping (uint => address) public pool2userList;\n     \n     mapping (address => PoolUserStruct) public pool3users;\n     mapping (uint => address) public pool3userList;\n     \n     mapping (address => PoolUserStruct) public pool4users;\n     mapping (uint => address) public pool4userList;\n     \n     mapping (address => PoolUserStruct) public pool5users;\n     mapping (uint => address) public pool5userList;\n     \n     mapping (address => PoolUserStruct) public pool6users;\n     mapping (uint => address) public pool6userList;\n     \n     mapping (address => PoolUserStruct) public pool7users;\n     mapping (uint => address) public pool7userList;\n     \n     mapping (address => PoolUserStruct) public pool8users;\n     mapping (uint => address) public pool8userList;\n     \n     mapping (address => PoolUserStruct) public pool9users;\n     mapping (uint => address) public pool9userList;\n     \n     mapping (address => PoolUserStruct) public pool10users;\n     mapping (uint => address) public pool10userList;\n     \n    mapping(uint => uint) public LEVEL_PRICE;\n    \n   uint REGESTRATION_FESS=0.5 ether;\n   uint pool1_price=1 ether;\n   uint pool2_price=2 ether ;\n   uint pool3_price=5 ether;\n   uint pool4_price=10 ether;\n   uint pool5_price=20 ether;\n   uint pool6_price=50 ether;\n   uint pool7_price=100 ether ;\n   uint pool8_price=200 ether;\n   uint pool9_price=500 ether;\n   uint pool10_price=1000 ether;\n   \n     event regLevelEvent(address indexed _user, address indexed _referrer, uint _time);\n      event getMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time);\n      \n     event regPoolEntry(address indexed _user,uint _level,   uint _time);\n   \n     \n    event getPoolPayment(address indexed _user,address indexed _receiver, uint _level, uint _time);\n   \n    UserStruct[] public requests;\n     \n      constructor() public {\n          ownerWallet = msg.sender;\n\n        LEVEL_PRICE[1] = 0.1 ether;\n        LEVEL_PRICE[2] = 0.05 ether;\n        LEVEL_PRICE[3] = 0.025 ether;\n        LEVEL_PRICE[4] = 0.0025 ether;\n      unlimited_level_price=0.0025 ether;\n\n        UserStruct memory userStruct;\n        currUserID++;\n\n        userStruct = UserStruct({\n            isExist: true,\n            id: currUserID,\n            referrerID: 0,\n            referredUsers:0\n           \n        });\n        \n        users[ownerWallet] = userStruct;\n       userList[currUserID] = ownerWallet;\n       \n       \n         PoolUserStruct memory pooluserStruct;\n        \n        pool1currUserID++;\n\n        pooluserStruct = PoolUserStruct({\n            isExist:true,\n            id:pool1currUserID,\n            payment_received:0\n        });\n    pool1activeUserID=pool1currUserID;\n       pool1users[msg.sender] = pooluserStruct;\n       pool1userList[pool1currUserID]=msg.sender;\n      \n        \n        pool2currUserID++;\n        pooluserStruct = PoolUserStruct({\n            isExist:true,\n            id:pool2currUserID,\n            payment_received:0\n        });\n    pool2activeUserID=pool2currUserID;\n       pool2users[msg.sender] = pooluserStruct;\n       pool2userList[pool2currUserID]=msg.sender;\n       \n       \n        pool3currUserID++;\n        pooluserStruct = PoolUserStruct({\n            isExist:true,\n            id:pool3currUserID,\n            payment_received:0\n        });\n    pool3activeUserID=pool3currUserID;\n       pool3users[msg.sender] = pooluserStruct;\n       pool3userList[pool3currUserID]=msg.sender;\n       \n       \n         pool4currUserID++;\n        pooluserStruct = PoolUserStruct({\n            isExist:true,\n            id:pool4currUserID,\n            payment_received:0\n        });\n    pool4activeUserID=pool4currUserID;\n       pool4users[msg.sender] = pooluserStruct;\n       pool4userList[pool4currUserID]=msg.sender;\n\n        \n          pool5currUserID++;\n        pooluserStruct = PoolUserStruct({\n            isExist:true,\n            id:pool5currUserID,\n            payment_received:0\n        });\n    pool5activeUserID=pool5currUserID;\n       pool5users[msg.sender] = pooluserStruct;\n       pool5userList[pool5currUserID]=msg.sender;\n       \n       \n         pool6currUserID++;\n        pooluserStruct = PoolUserStruct({\n            isExist:true,\n            id:pool6currUserID,\n            payment_received:0\n        });\n    pool6activeUserID=pool6currUserID;\n       pool6users[msg.sender] = pooluserStruct;\n       pool6userList[pool6currUserID]=msg.sender;\n       \n         pool7currUserID++;\n        pooluserStruct = PoolUserStruct({\n            isExist:true,\n            id:pool7currUserID,\n            payment_received:0\n        });\n    pool7activeUserID=pool7currUserID;\n       pool7users[msg.sender] = pooluserStruct;\n       pool7userList[pool7currUserID]=msg.sender;\n       \n       pool8currUserID++;\n        pooluserStruct = PoolUserStruct({\n            isExist:true,\n            id:pool8currUserID,\n            payment_received:0\n        });\n    pool8activeUserID=pool8currUserID;\n       pool8users[msg.sender] = pooluserStruct;\n       pool8userList[pool8currUserID]=msg.sender;\n       \n        pool9currUserID++;\n        pooluserStruct = PoolUserStruct({\n            isExist:true,\n            id:pool9currUserID,\n            payment_received:0\n        });\n    pool9activeUserID=pool9currUserID;\n       pool9users[msg.sender] = pooluserStruct;\n       pool9userList[pool9currUserID]=msg.sender;\n       \n       \n        pool10currUserID++;\n        pooluserStruct = PoolUserStruct({\n            isExist:true,\n            id:pool10currUserID,\n            payment_received:0\n        });\n    pool10activeUserID=pool10currUserID;\n       pool10users[msg.sender] = pooluserStruct;\n       pool10userList[pool10currUserID]=msg.sender;\n       \n       \n      }\n     \n       function regUser(uint _referrerID) public payable {\n       \n      require(!users[msg.sender].isExist, \"User Exists\");\n      require(_referrerID > 0 && _referrerID < 2 , 'Use Only ID 1 As a General Referral ID');\n        require(msg.value == REGESTRATION_FESS, 'Incorrect Value');\n       \n        UserStruct memory userStruct;\n        currUserID++;\n\n        userStruct = UserStruct({\n            isExist: true,\n            id: currUserID,\n            referrerID: _referrerID,\n            referredUsers:0\n        });\n   \n    \n       users[msg.sender] = userStruct;\n       userList[currUserID]=msg.sender;\n       \n        users[userList[users[msg.sender].referrerID]].referredUsers=users[userList[users[msg.sender].referrerID]].referredUsers+1;\n        \n       payReferral(1,msg.sender);\n        emit regLevelEvent(msg.sender, userList[_referrerID], now);\n    }\n   \n   \n     function payReferral(uint _level, address _user) internal {\n        address referer;\n       \n        referer = userList[users[_user].referrerID];\n       \n       \n         bool sent = false;\n       \n            uint level_price_local=0;\n            if(_level>4){\n            level_price_local=unlimited_level_price;\n            }\n            else{\n            level_price_local=LEVEL_PRICE[_level];\n            }\n            sent = address(uint160(referer)).send(level_price_local);\n\n            if (sent) {\n                emit getMoneyForLevelEvent(referer, msg.sender, _level, now);\n                if(_level < 50 && users[referer].referrerID >= 1){\n                    payReferral(_level+1,referer);\n                }\n                else\n                {\n                    sendBalance();\n                }\n               \n            }\n       \n        if(!sent) {\n          //  emit lostMoneyForLevelEvent(referer, msg.sender, _level, now);\n\n            payReferral(_level, referer);\n        }\n     }\n   \n   \n   \n   \n       function buyPool1() public payable {\n       require(users[msg.sender].isExist, \"User Not Registered\");\n      require(!pool1users[msg.sender].isExist, \"Already in AutoPool\");\n      \n        require(msg.value == pool1_price, 'Incorrect Value');\n        \n       \n        PoolUserStruct memory userStruct;\n        address pool1Currentuser=pool1userList[pool1activeUserID];\n        \n        pool1currUserID++;\n\n        userStruct = PoolUserStruct({\n            isExist:true,\n            id:pool1currUserID,\n            payment_received:0\n        });\n   \n       pool1users[msg.sender] = userStruct;\n       pool1userList[pool1currUserID]=msg.sender;\n       bool sent = false;\n       sent = address(uint160(pool1Currentuser)).send(pool1_price);\n\n            if (sent) {\n                pool1users[pool1Currentuser].payment_received+=1;\n                if(pool1users[pool1Currentuser].payment_received>=2)\n                {\n                    pool1activeUserID+=1;\n                }\n                emit getPoolPayment(msg.sender,pool1Currentuser, 1, now);\n            }\n       emit regPoolEntry(msg.sender, 1, now);\n    }\n    \n    \n      function buyPool2() public payable {\n          require(users[msg.sender].isExist, \"User Not Registered\");\n      require(!pool2users[msg.sender].isExist, \"Already in AutoPool\");\n        require(msg.value == pool2_price, 'Incorrect Value');\n        require(users[msg.sender].referredUsers>=0, \"Must need 0 referral\");\n         \n        PoolUserStruct memory userStruct;\n        address pool2Currentuser=pool2userList[pool2activeUserID];\n        \n        pool2currUserID++;\n        userStruct = PoolUserStruct({\n            isExist:true,\n            id:pool2currUserID,\n            payment_received:0\n        });\n       pool2users[msg.sender] = userStruct;\n       pool2userList[pool2currUserID]=msg.sender;\n       \n       \n       \n       bool sent = false;\n       sent = address(uint160(pool2Currentuser)).send(pool2_price);\n\n            if (sent) {\n                pool2users[pool2Currentuser].payment_received+=1;\n                if(pool2users[pool2Currentuser].payment_received>=3)\n                {\n                    pool2activeUserID+=1;\n                }\n                emit getPoolPayment(msg.sender,pool2Currentuser, 2, now);\n            }\n            emit regPoolEntry(msg.sender,2,  now);\n    }\n    \n    \n     function buyPool3() public payable {\n         require(users[msg.sender].isExist, \"User Not Registered\");\n      require(!pool3users[msg.sender].isExist, \"Already in AutoPool\");\n        require(msg.value == pool3_price, 'Incorrect Value');\n        require(users[msg.sender].referredUsers>=0, \"Must need 0 referral\");\n        \n        PoolUserStruct memory userStruct;\n        address pool3Currentuser=pool3userList[pool3activeUserID];\n        \n        pool3currUserID++;\n        userStruct = PoolUserStruct({\n            isExist:true,\n            id:pool3currUserID,\n            payment_received:0\n        });\n       pool3users[msg.sender] = userStruct;\n       pool3userList[pool3currUserID]=msg.sender;\n       bool sent = false;\n       sent = address(uint160(pool3Currentuser)).send(pool3_price);\n\n            if (sent) {\n                pool3users[pool3Currentuser].payment_received+=1;\n                if(pool3users[pool3Currentuser].payment_received>=4)\n                {\n                    pool3activeUserID+=1;\n                }\n                emit getPoolPayment(msg.sender,pool3Currentuser, 3, now);\n            }\nemit regPoolEntry(msg.sender,3,  now);\n    }\n    \n    \n    function buyPool4() public payable {\n        require(users[msg.sender].isExist, \"User Not Registered\");\n      require(!pool4users[msg.sender].isExist, \"Already in AutoPool\");\n        require(msg.value == pool4_price, 'Incorrect Value');\n        require(users[msg.sender].referredUsers>=0, \"Must need 0 referral\");\n      \n        PoolUserStruct memory userStruct;\n        address pool4Currentuser=pool4userList[pool4activeUserID];\n        \n        pool4currUserID++;\n        userStruct = PoolUserStruct({\n            isExist:true,\n            id:pool4currUserID,\n            payment_received:0\n        });\n       pool4users[msg.sender] = userStruct;\n       pool4userList[pool4currUserID]=msg.sender;\n       bool sent = false;\n       sent = address(uint160(pool4Currentuser)).send(pool4_price);\n\n            if (sent) {\n                pool4users[pool4Currentuser].payment_received+=1;\n                if(pool4users[pool4Currentuser].payment_received>=5)\n                {\n                    pool4activeUserID+=1;\n                }\n                 emit getPoolPayment(msg.sender,pool4Currentuser, 4, now);\n            }\n        emit regPoolEntry(msg.sender,4, now);\n    }\n    \n    \n    \n    function buyPool5() public payable {\n        require(users[msg.sender].isExist, \"User Not Registered\");\n      require(!pool5users[msg.sender].isExist, \"Already in AutoPool\");\n        require(msg.value == pool5_price, 'Incorrect Value');\n        require(users[msg.sender].referredUsers>=0, \"Must need 0 referral\");\n        \n        PoolUserStruct memory userStruct;\n        address pool5Currentuser=pool5userList[pool5activeUserID];\n        \n        pool5currUserID++;\n        userStruct = PoolUserStruct({\n            isExist:true,\n            id:pool5currUserID,\n            payment_received:0\n        });\n       pool5users[msg.sender] = userStruct;\n       pool5userList[pool5currUserID]=msg.sender;\n       bool sent = false;\n       sent = address(uint160(pool5Currentuser)).send(pool5_price);\n\n            if (sent) {\n                pool5users[pool5Currentuser].payment_received+=1;\n                if(pool5users[pool5Currentuser].payment_received>=6)\n                {\n                    pool5activeUserID+=1;\n                }\n                 emit getPoolPayment(msg.sender,pool5Currentuser, 5, now);\n            }\n        emit regPoolEntry(msg.sender,5,  now);\n    }\n    \n    function buyPool6() public payable {\n      require(!pool6users[msg.sender].isExist, \"Already in AutoPool\");\n        require(msg.value == pool6_price, 'Incorrect Value');\n        require(users[msg.sender].referredUsers>=0, \"Must need 0 referral\");\n        \n        PoolUserStruct memory userStruct;\n        address pool6Currentuser=pool6userList[pool6activeUserID];\n        \n        pool6currUserID++;\n        userStruct = PoolUserStruct({\n            isExist:true,\n            id:pool6currUserID,\n            payment_received:0\n        });\n       pool6users[msg.sender] = userStruct;\n       pool6userList[pool6currUserID]=msg.sender;\n       bool sent = false;\n       sent = address(uint160(pool6Currentuser)).send(pool6_price);\n\n            if (sent) {\n                pool6users[pool6Currentuser].payment_received+=1;\n                if(pool6users[pool6Currentuser].payment_received>=7)\n                {\n                    pool6activeUserID+=1;\n                }\n                 emit getPoolPayment(msg.sender,pool6Currentuser, 6, now);\n            }\n        emit regPoolEntry(msg.sender,6,  now);\n    }\n    \n    function buyPool7() public payable {\n        require(users[msg.sender].isExist, \"User Not Registered\");\n      require(!pool7users[msg.sender].isExist, \"Already in AutoPool\");\n        require(msg.value == pool7_price, 'Incorrect Value');\n        require(users[msg.sender].referredUsers>=0, \"Must need 0 referral\");\n        \n        PoolUserStruct memory userStruct;\n        address pool7Currentuser=pool7userList[pool7activeUserID];\n        \n        pool7currUserID++;\n        userStruct = PoolUserStruct({\n            isExist:true,\n            id:pool7currUserID,\n            payment_received:0\n        });\n       pool7users[msg.sender] = userStruct;\n       pool7userList[pool7currUserID]=msg.sender;\n       bool sent = false;\n       sent = address(uint160(pool7Currentuser)).send(pool7_price);\n\n            if (sent) {\n                pool7users[pool7Currentuser].payment_received+=1;\n                if(pool7users[pool7Currentuser].payment_received>=8)\n                {\n                    pool7activeUserID+=1;\n                }\n                 emit getPoolPayment(msg.sender,pool7Currentuser, 7, now);\n            }\n        emit regPoolEntry(msg.sender,7,  now);\n    }\n    \n    \n    function buyPool8() public payable {\n        require(users[msg.sender].isExist, \"User Not Registered\");\n      require(!pool8users[msg.sender].isExist, \"Already in AutoPool\");\n        require(msg.value == pool8_price, 'Incorrect Value');\n        require(users[msg.sender].referredUsers>=0, \"Must need 0 referral\");\n       \n        PoolUserStruct memory userStruct;\n        address pool8Currentuser=pool8userList[pool8activeUserID];\n        \n        pool8currUserID++;\n        userStruct = PoolUserStruct({\n            isExist:true,\n            id:pool8currUserID,\n            payment_received:0\n        });\n       pool8users[msg.sender] = userStruct;\n       pool8userList[pool8currUserID]=msg.sender;\n       bool sent = false;\n       sent = address(uint160(pool8Currentuser)).send(pool8_price);\n\n            if (sent) {\n                pool8users[pool8Currentuser].payment_received+=1;\n                if(pool8users[pool8Currentuser].payment_received>=9)\n                {\n                    pool8activeUserID+=1;\n                }\n                 emit getPoolPayment(msg.sender,pool8Currentuser, 8, now);\n            }\n        emit regPoolEntry(msg.sender,8,  now);\n    }\n    \n    \n    \n    function buyPool9() public payable {\n        require(users[msg.sender].isExist, \"User Not Registered\");\n      require(!pool9users[msg.sender].isExist, \"Already in AutoPool\");\n        require(msg.value == pool9_price, 'Incorrect Value');\n        require(users[msg.sender].referredUsers>=0, \"Must need 0 referral\");\n       \n        PoolUserStruct memory userStruct;\n        address pool9Currentuser=pool9userList[pool9activeUserID];\n        \n        pool9currUserID++;\n        userStruct = PoolUserStruct({\n            isExist:true,\n            id:pool9currUserID,\n            payment_received:0\n        });\n       pool9users[msg.sender] = userStruct;\n       pool9userList[pool9currUserID]=msg.sender;\n       bool sent = false;\n       sent = address(uint160(pool9Currentuser)).send(pool9_price);\n\n            if (sent) {\n                pool9users[pool9Currentuser].payment_received+=1;\n                if(pool9users[pool9Currentuser].payment_received>=10)\n                {\n                    pool9activeUserID+=1;\n                }\n                 emit getPoolPayment(msg.sender,pool9Currentuser, 9, now);\n            }\n        emit regPoolEntry(msg.sender,9,  now);\n    }\n    \n    \n    function buyPool10() public payable {\n        require(users[msg.sender].isExist, \"User Not Registered\");\n      require(!pool10users[msg.sender].isExist, \"Already in AutoPool\");\n        require(msg.value == pool10_price, 'Incorrect Value');\n        require(users[msg.sender].referredUsers>=0, \"Must need 0 referral\");\n        \n        PoolUserStruct memory userStruct;\n        address pool10Currentuser=pool10userList[pool10activeUserID];\n        \n        pool10currUserID++;\n        userStruct = PoolUserStruct({\n            isExist:true,\n            id:pool10currUserID,\n            payment_received:0\n        });\n       pool10users[msg.sender] = userStruct;\n       pool10userList[pool10currUserID]=msg.sender;\n       bool sent = false;\n       sent = address(uint160(pool10Currentuser)).send(pool10_price);\n\n            if (sent) {\n                pool10users[pool10Currentuser].payment_received+=1;\n                if(pool10users[pool10Currentuser].payment_received>=300)\n                {\n                    pool10activeUserID+=1;\n                }\n                 emit getPoolPayment(msg.sender,pool10Currentuser, 10, now);\n            }\n        emit regPoolEntry(msg.sender, 10, now);\n    }\n    \n    function getEthBalance() public view returns(uint) {\n    return address(this).balance;\n    }\n    \n    function sendBalance() private\n    {\n         if (!address(uint160(ownerWallet)).send(getEthBalance()))\n         {\n             \n         }\n    }\n }",
    "vulnerability_type": "access_control"
  }
]
